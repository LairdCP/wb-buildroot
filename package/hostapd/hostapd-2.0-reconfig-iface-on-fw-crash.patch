diff --git a/hostapd/main.c b/hostapd/main.c
index 56f0002..86a3da3 100644
--- a/hostapd/main.c
+++ b/hostapd/main.c
@@ -331,6 +331,36 @@ static int handle_reload_iface(struct hostapd_iface *iface, void *ctx)
 	return 0;
 }
 
+int hostapd_reconfig_iface(struct hostapd_iface *iface, void *ctx)
+{
+	const struct wpa_driver_ops *driver;
+	void *drv_priv;
+
+	if (iface == NULL)
+		goto fail;
+
+	driver = iface->bss[0]->driver;
+	drv_priv = iface->bss[0]->drv_priv;
+	hostapd_interface_deinit(iface);
+	if (driver && driver->hapd_deinit && drv_priv)
+		driver->hapd_deinit(drv_priv);
+
+	if (iface->conf->bss[0].iface[0] != 0 ||
+	    hostapd_drv_none(iface->bss[0])) {
+		if (hostapd_driver_init(iface) || hostapd_setup_interface(iface)) {
+			hostapd_interface_deinit_free(iface);
+			goto fail;
+		}
+	} else
+		goto fail;
+
+	return 0;
+
+fail:
+	wpa_printf(MSG_WARNING, "Failed to reconfigure driver and "
+	           "interface.");
+	return 0;
+}
 
 /**
  * handle_reload - SIGHUP handler to reload configuration
@@ -343,6 +373,16 @@ static void handle_reload(int sig, void *signal_ctx)
 	hostapd_for_each_interface(interfaces, handle_reload_iface, NULL);
 }
 
+/**
+ * handle_reconfig_ifaces - SIGUS2 handler to reconfigure drivers and interfaces
+ */
+static void handle_reconfig_ifaces(int sig, void *signal_ctx)
+{
+	struct hapd_interfaces *interfaces = signal_ctx;
+	wpa_printf(MSG_DEBUG, "Signal %d received - reconfiguring drivers and interfaces",
+		   sig);
+	hostapd_for_each_interface(interfaces, hostapd_reconfig_iface, NULL);
+}
 
 static void handle_dump_state(int sig, void *signal_ctx)
 {
@@ -378,6 +418,7 @@ static int hostapd_global_init(struct hapd_interfaces *interfaces,
 #ifndef CONFIG_NATIVE_WINDOWS
 	eloop_register_signal(SIGHUP, handle_reload, interfaces);
 	eloop_register_signal(SIGUSR1, handle_dump_state, interfaces);
+	eloop_register_signal(SIGUSR2, handle_reconfig_ifaces, interfaces);
 #endif /* CONFIG_NATIVE_WINDOWS */
 	eloop_register_signal_terminate(handle_term, interfaces);
 
diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index 37b6be9..b570b27 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -23,6 +23,7 @@
 #include <netpacket/packet.h>
 #include <linux/filter.h>
 #include <linux/errqueue.h>
+#include <signal.h>
 #include "nl80211_copy.h"
 
 #include "common.h"
@@ -291,6 +292,7 @@ struct wpa_driver_nl80211_data {
 	int auth_p2p;
 };
 
+static unsigned int reg_change_seen = 0;
 
 static void wpa_driver_nl80211_scan_timeout(void *eloop_ctx,
 					    void *timeout_ctx);
@@ -2262,6 +2264,17 @@ static void do_process_drv_event(struct i802_bss *bss, int cmd,
 		break;
 	case NL80211_CMD_REG_CHANGE:
 		wpa_printf(MSG_DEBUG, "nl80211: Regulatory domain change");
+		/* On start a regulatory domain change event should happen.
+		 * If another REG_CHANGE event happens, it likely means the
+		 * firmware restarted. So send a signal to ourselves to
+		 * reconfigure the driver and interface.
+		 */
+		if(reg_change_seen) {
+			reg_change_seen = 0;
+			raise(SIGUSR2);
+		} else {
+			reg_change_seen = 1;
+		}
 		wpa_supplicant_event(drv->ctx, EVENT_CHANNEL_LIST_CHANGED,
 				     NULL);
 		break;
