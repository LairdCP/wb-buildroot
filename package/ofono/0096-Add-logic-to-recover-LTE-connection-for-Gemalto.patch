From e65d5ed38b381cf78c688a63f6e9f8e50a6f9ef4 Mon Sep 17 00:00:00 2001
From: Don Ferencz <Donald.Ferencz@lairdconnect.com>
Date: Wed, 31 Aug 2022 18:16:50 +0000
Subject: [PATCH] Add logic to recover LTE connection for Gemalto

Gemalto modems fail to re-register on LTE once de-registered
(e.g., due to signal loss) since they apparently revert to 3G
and then the registration is denied.  Recovery logic detects
the de-register and restarts the operator selection logic
which returns to LTE.
---
 drivers/atmodem/network-registration.c | 63 ++++++++++++++++++++++++--
 1 file changed, 58 insertions(+), 5 deletions(-)

diff --git a/drivers/atmodem/network-registration.c b/drivers/atmodem/network-registration.c
index 2e9dcd40..f47625ae 100644
--- a/drivers/atmodem/network-registration.c
+++ b/drivers/atmodem/network-registration.c
@@ -64,6 +64,8 @@ struct netreg_data {
 	guint nitz_timeout;
 	unsigned int vendor;
 	gboolean ltereg;
+	int prev_status;
+	gboolean recovering;
 };
 
 struct tech_query {
@@ -1515,6 +1517,37 @@ static void option_query_tech_cb(gboolean ok, GAtResult *result,
 			tq->status, tq->lac, tq->ci, tech);
 }
 
+static void gemalto_cops_on_cb(gboolean ok, GAtResult *result,
+					gpointer user_data)
+{
+	struct ofono_netreg *netreg = user_data;
+	struct netreg_data *nd = ofono_netreg_get_data(netreg);
+
+	/*
+	 * We ignore the result, since AT+COPS=0 can report fail failure
+	 * if the registration times out, but is successful since the
+	 * operator selection has been reset and the modem should register
+	 * once LTE becomes available.
+	 */
+	 nd->recovering = FALSE;
+	 ofono_warn("Gemalto recovery complete (%d)", (int)ok);
+}
+
+static void gemalto_cops_off_cb(gboolean ok, GAtResult *result,
+					gpointer user_data)
+{
+	struct ofono_netreg *netreg = user_data;
+	struct netreg_data *nd = ofono_netreg_get_data(netreg);
+
+	if (ok) {
+		g_at_chat_send(nd->chat, "AT+COPS=0", none_prefix,
+					gemalto_cops_on_cb, netreg, NULL);
+	} else {
+		ofono_warn("Gemalto LTE recovery (cops on) failed!");
+		nd->recovering = FALSE;
+	}
+}
+
 static void creg_notify(GAtResult *result, gpointer user_data)
 {
 	struct ofono_netreg *netreg = user_data;
@@ -1526,20 +1559,38 @@ static void creg_notify(GAtResult *result, gpointer user_data)
 				&lac, &ci, &tech, nd->vendor) == FALSE)
 		return;
 
-	/*
-	 * LTE attach can cause +CREG to report registered (1) followed
-	 * by denied (3), then registered; if registered on LTE,
-	 * ignore the denied state.
-	 */
 	if (status != 1 && status != 5) {
+		/*
+		 * LTE attach can cause +CREG to report registered (1) followed
+		 * by denied (3), then registered; if registered on LTE,
+		 * ignore the denied state.
+		 */
 		if (status == 3 && nd->ltereg) {
 			return;
 		} else {
 			nd->ltereg = FALSE;
+		}
+		if (!nd->recovering && nd->vendor == OFONO_VENDOR_GEMALTO &&
+				(nd->prev_status == 1 || nd->prev_status == 5)) {
+			/*
+			 * Gemalto modem fails to re-register on LTE due to 3G
+			 * sunset: start recovery by forcing restart of
+			 * operator selection
+			 */
+			if (g_at_chat_send(nd->chat, "AT+COPS=2", none_prefix,
+						gemalto_cops_off_cb, netreg, NULL) <= 0) {
+				ofono_warn("Gemalto LTE recovery (cops off) failed!");
+			} else {
+				nd->recovering = TRUE;
+				ofono_warn("Perfoming Gemalto LTE recovery!");
+			}
+			nd->prev_status = status;
 			goto notify;
 		}
 	}
 
+	nd->prev_status = status;
+
 	if (tech == 7)
 		nd->ltereg = TRUE;
 
@@ -2152,6 +2203,8 @@ static int at_netreg_probe(struct ofono_netreg *netreg, unsigned int vendor,
 	nd->time.dst = 0;
 	nd->time.utcoff = 0;
 	nd->ltereg = FALSE;
+	nd->prev_status = 0;
+	nd->recovering = FALSE;
 	ofono_netreg_set_data(netreg, nd);
 
 	g_at_chat_send(nd->chat, "AT+CREG=?", creg_prefix,
-- 
2.17.1

