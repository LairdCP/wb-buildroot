From b489627e7ce00dda36da782226237a8db2e7a1bf Mon Sep 17 00:00:00 2001
From: Boris Krasnovskiy <boris.krasnovskiy@lairdconnect.com>
Date: Fri, 6 May 2022 11:29:01 -0400
Subject: [PATCH] Revert "tools: Remove legacy code for CSR controllers"

This reverts commit e2e198ced468122df7b431cb06158123ba60a2f2.
---
 Makefile.tools    |   14 +-
 tools/bccmd.1     |  130 +++
 tools/bccmd.c     | 1248 ++++++++++++++++++++
 tools/csr.c       | 2856 +++++++++++++++++++++++++++++++++++++++++++++
 tools/csr.h       |  555 +++++++++
 tools/csr_3wire.c |   62 +
 tools/csr_bcsp.c  |  257 ++++
 tools/csr_h4.c    |  166 +++
 tools/csr_hci.c   |  160 +++
 tools/csr_usb.c   |  308 +++++
 tools/hciconfig.c |   28 +
 tools/ubcsp.c     | 1180 +++++++++++++++++++
 tools/ubcsp.h     |  208 ++++
 13 files changed, 7168 insertions(+), 4 deletions(-)
 create mode 100644 tools/bccmd.1
 create mode 100644 tools/bccmd.c
 create mode 100644 tools/csr.c
 create mode 100644 tools/csr.h
 create mode 100644 tools/csr_3wire.c
 create mode 100644 tools/csr_bcsp.c
 create mode 100644 tools/csr_h4.c
 create mode 100644 tools/csr_hci.c
 create mode 100644 tools/csr_usb.c
 create mode 100644 tools/ubcsp.c
 create mode 100644 tools/ubcsp.h

diff --git a/Makefile.tools b/Makefile.tools
index b7d893248..8b32a57f1 100644
--- a/Makefile.tools
+++ b/Makefile.tools
@@ -207,7 +207,7 @@ endif
 
 if TOOLS
 bin_PROGRAMS += tools/rctest tools/l2test tools/l2ping tools/bluemoon \
-		tools/hex2hcd tools/mpris-proxy tools/btattach tools/isotest
+		tools/hex2hcd tools/mpris-proxy tools/btattach tools/isotest tools/bccmd
 
 noinst_PROGRAMS += tools/bdaddr tools/avinfo tools/avtest \
 			tools/scotest tools/amptest tools/hwdb \
@@ -307,6 +307,12 @@ tools_l2test_LDADD = lib/libbluetooth-internal.la
 
 tools_l2ping_LDADD = lib/libbluetooth-internal.la
 
+tools_bccmd_SOURCES = tools/bccmd.c tools/csr.h tools/csr.c \
+			tools/csr_hci.c tools/csr_usb.c \
+			tools/csr_h4.c tools/csr_3wire.c \
+			tools/csr_bcsp.c tools/ubcsp.h tools/ubcsp.c
+tools_bccmd_LDADD = lib/libbluetooth-internal.la
+
 tools_bluemoon_SOURCES = tools/bluemoon.c monitor/bt.h
 tools_bluemoon_LDADD = src/libshared-mainloop.la
 
@@ -325,7 +331,7 @@ profiles_iap_iapd_SOURCES = profiles/iap/main.c
 profiles_iap_iapd_LDADD = gdbus/libgdbus-internal.la $(GLIB_LIBS) $(DBUS_LIBS)
 
 if MANPAGES
-man_MANS += tools/rctest.1 tools/l2ping.1 tools/btattach.1 tools/isotest.1
+man_MANS += tools/rctest.1 tools/l2ping.1 tools/btattach.1 tools/isotest.1 tools/bccmd.1
 endif
 
 if MESH
@@ -392,7 +398,7 @@ tools_hciattach_SOURCES = tools/hciattach.c tools/hciattach.h \
 						tools/hciattach_bcm43xx.c
 tools_hciattach_LDADD = lib/libbluetooth-internal.la
 
-tools_hciconfig_SOURCES = tools/hciconfig.c
+tools_hciconfig_SOURCES = tools/hciconfig.c tools/csr.h tools/csr.c
 tools_hciconfig_LDADD = lib/libbluetooth-internal.la
 
 tools_hcitool_SOURCES = tools/hcitool.c src/oui.h src/oui.c
@@ -443,7 +449,7 @@ manual_pages += tools/hciattach.1 tools/hciconfig.1 \
 			tools/hcitool.1 tools/hcidump.1 \
 			tools/rfcomm.1 tools/sdptool.1 tools/ciptool.1 \
 			tools/rctest.1 tools/l2ping.1 tools/btattach.1 \
-			tools/bdaddr.1 tools/isotest.1
+			tools/bdaddr.1 tools/isotest.1 tools/bccmd.1
 
 if HID2HCI
 udevdir = $(UDEV_DIR)
diff --git a/tools/bccmd.1 b/tools/bccmd.1
new file mode 100644
index 000000000..26c83a6a2
--- /dev/null
+++ b/tools/bccmd.1
@@ -0,0 +1,130 @@
+.TH BCCMD 1 "Jun 20 2006" BlueZ "Linux System Administration"
+.SH NAME
+bccmd \- Utility for the CSR BCCMD interface
+.SH SYNOPSIS
+.B bccmd
+.br
+.B bccmd [-t <transport>] [-d <device>] <command> [<args>]
+.br
+.B bccmd [-h --help]
+.br
+.SH DESCRIPTION
+.B
+bccmd
+issues BlueCore commands to
+.B
+Cambridge Silicon Radio
+devices. If run without the <command> argument, a short help page will be displayed.
+.SH OPTIONS
+.TP
+.BI -t\ <transport>
+Specify the communication transport. Valid options are:
+.RS
+.TP
+.BI HCI
+Local device with Host Controller Interface (default).
+.TP
+.BI USB
+Direct USB connection.
+.TP
+.BI BCSP
+Blue Core Serial Protocol.
+.TP
+.BI H4
+H4 serial protocol.
+.TP
+.BI 3WIRE
+3WIRE protocol (not implemented).
+.SH
+.TP
+.BI -d\ <dev>
+Specify a particular device to operate on. If not specified, default is the first available HCI device
+or /dev/ttyS0 for serial transports.
+.SH COMMANDS
+.TP
+.BI builddef
+Get build definitions
+.TP
+.BI keylen\ <handle>
+Get current crypt key length
+.TP
+.BI clock
+Get local Bluetooth clock
+.TP
+.BI rand
+Get random number
+.TP
+.BI chiprev
+Get chip revision
+.TP
+.BI buildname
+Get the full build name
+.TP
+.BI panicarg
+Get panic code argument
+.TP
+.BI faultarg
+Get fault code argument
+.TP
+.BI coldreset
+Perform cold reset
+.TP
+.BI warmreset
+Perform warm reset
+.TP
+.BI disabletx
+Disable TX on the device
+.TP
+.BI enabletx
+Enable TX on the device
+.TP
+.BI singlechan\ <channel>
+Lock radio on specific channel
+.TP
+.BI hoppingon
+Revert to channel hopping
+.TP
+.BI rttxdata1\ <decimal\ freq\ MHz>\ <level>
+TXData1 radio test
+.TP
+.BI radiotest\ <decimal\ freq\ MHz>\ <level>\ <id>
+Run radio tests, tests 4, 6 and 7 are transmit tests
+.TP
+.BI memtypes
+Get memory types
+.TP
+.BI psget\ [-r]\ [-s\ <stores>]\ <key>
+Get value for PS key.
+-r sends a warm reset afterwards
+.TP
+.BI psset\ [-r]\ [-s\ <stores>]\ <key>\ <value>
+Set value for PS key.
+-r sends a warm reset afterwards
+.TP
+.BI psclr\ [-r]\ [-s\ <stores>]\ <key>
+Clear value for PS key.
+-r sends a warm reset afterwards
+.TP
+.BI pslist\ [-r]\ [-s\ <stores>]
+List all PS keys.
+-r sends a warm reset afterwards
+.TP
+.BI psread\ [-r]\ [-s\ <stores>]
+Read all PS keys.
+-r sends a warm reset afterwards
+.TP
+.BI psload\ [-r]\ [-s\ <stores>]\ <file>
+Load all PS keys from PSR file.
+-r sends a warm reset afterwards
+.TP
+.BI pscheck\ [-r]\ [-s\ <stores>]\ <file>
+Check syntax of PSR file.
+-r sends a warm reset afterwards
+.SH KEYS
+bdaddr country devclass keymin keymax features commands version
+remver hciextn mapsco baudrate hostintf anafreq anaftrim usbvid
+usbpid dfupid bootmode
+.SH AUTHORS
+Written by Marcel Holtmann <marcel@holtmann.org>,
+man page by Adam Laurie <adam@algroup.co.uk>
+.PP
diff --git a/tools/bccmd.c b/tools/bccmd.c
new file mode 100644
index 000000000..2c215ace7
--- /dev/null
+++ b/tools/bccmd.c
@@ -0,0 +1,1248 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <sys/socket.h>
+#include <unistd.h>
+
+#include "lib/bluetooth.h"
+#include "lib/hci.h"
+#include "lib/hci_lib.h"
+
+#include "src/shared/tty.h"
+
+#include "csr.h"
+
+#define CSR_TRANSPORT_UNKNOWN	0
+#define CSR_TRANSPORT_HCI	1
+#define CSR_TRANSPORT_USB	2
+#define CSR_TRANSPORT_BCSP	3
+#define CSR_TRANSPORT_H4	4
+#define CSR_TRANSPORT_3WIRE	5
+
+#define CSR_STORES_PSI		(0x0001)
+#define CSR_STORES_PSF		(0x0002)
+#define CSR_STORES_PSROM	(0x0004)
+#define CSR_STORES_PSRAM	(0x0008)
+#define CSR_STORES_DEFAULT	(CSR_STORES_PSI | CSR_STORES_PSF)
+
+#define CSR_TYPE_NULL		0
+#define CSR_TYPE_COMPLEX	1
+#define CSR_TYPE_UINT8		2
+#define CSR_TYPE_UINT16		3
+#define CSR_TYPE_UINT32		4
+
+#define CSR_TYPE_ARRAY		CSR_TYPE_COMPLEX
+#define CSR_TYPE_BDADDR		CSR_TYPE_COMPLEX
+
+static inline int transport_open(int transport, char *device, speed_t bcsp_rate)
+{
+	switch (transport) {
+	case CSR_TRANSPORT_HCI:
+		return csr_open_hci(device);
+	case CSR_TRANSPORT_USB:
+		return csr_open_usb(device);
+	case CSR_TRANSPORT_BCSP:
+		return csr_open_bcsp(device, bcsp_rate);
+	case CSR_TRANSPORT_H4:
+		return csr_open_h4(device);
+	case CSR_TRANSPORT_3WIRE:
+		return csr_open_3wire(device);
+	default:
+		fprintf(stderr, "Unsupported transport\n");
+		return -1;
+	}
+}
+
+static inline int transport_read(int transport, uint16_t varid, uint8_t *value, uint16_t length)
+{
+	switch (transport) {
+	case CSR_TRANSPORT_HCI:
+		return csr_read_hci(varid, value, length);
+	case CSR_TRANSPORT_USB:
+		return csr_read_usb(varid, value, length);
+	case CSR_TRANSPORT_BCSP:
+		return csr_read_bcsp(varid, value, length);
+	case CSR_TRANSPORT_H4:
+		return csr_read_h4(varid, value, length);
+	case CSR_TRANSPORT_3WIRE:
+		return csr_read_3wire(varid, value, length);
+	default:
+		errno = EOPNOTSUPP;
+		return -1;
+	}
+}
+
+static inline int transport_write(int transport, uint16_t varid, uint8_t *value, uint16_t length)
+{
+	switch (transport) {
+	case CSR_TRANSPORT_HCI:
+		return csr_write_hci(varid, value, length);
+	case CSR_TRANSPORT_USB:
+		return csr_write_usb(varid, value, length);
+	case CSR_TRANSPORT_BCSP:
+		return csr_write_bcsp(varid, value, length);
+	case CSR_TRANSPORT_H4:
+		return csr_write_h4(varid, value, length);
+	case CSR_TRANSPORT_3WIRE:
+		return csr_write_3wire(varid, value, length);
+	default:
+		errno = EOPNOTSUPP;
+		return -1;
+	}
+}
+
+static inline void transport_close(int transport)
+{
+	switch (transport) {
+	case CSR_TRANSPORT_HCI:
+		csr_close_hci();
+		break;
+	case CSR_TRANSPORT_USB:
+		csr_close_usb();
+		break;
+	case CSR_TRANSPORT_BCSP:
+		csr_close_bcsp();
+		break;
+	case CSR_TRANSPORT_H4:
+		csr_close_h4();
+		break;
+	case CSR_TRANSPORT_3WIRE:
+		csr_close_3wire();
+		break;
+	}
+}
+
+static struct {
+	uint16_t pskey;
+	int type;
+	int size;
+	char *str;
+} storage[] = {
+	{ CSR_PSKEY_BDADDR,                   CSR_TYPE_BDADDR,  8,  "bdaddr"   },
+	{ CSR_PSKEY_COUNTRYCODE,              CSR_TYPE_UINT16,  0,  "country"  },
+	{ CSR_PSKEY_CLASSOFDEVICE,            CSR_TYPE_UINT32,  0,  "devclass" },
+	{ CSR_PSKEY_ENC_KEY_LMIN,             CSR_TYPE_UINT16,  0,  "keymin"   },
+	{ CSR_PSKEY_ENC_KEY_LMAX,             CSR_TYPE_UINT16,  0,  "keymax"   },
+	{ CSR_PSKEY_LOCAL_SUPPORTED_FEATURES, CSR_TYPE_ARRAY,   8,  "features" },
+	{ CSR_PSKEY_LOCAL_SUPPORTED_COMMANDS, CSR_TYPE_ARRAY,   18, "commands" },
+	{ CSR_PSKEY_HCI_LMP_LOCAL_VERSION,    CSR_TYPE_UINT16,  0,  "version"  },
+	{ CSR_PSKEY_LMP_REMOTE_VERSION,       CSR_TYPE_UINT8,   0,  "remver"   },
+	{ CSR_PSKEY_HOSTIO_USE_HCI_EXTN,      CSR_TYPE_UINT16,  0,  "hciextn"  },
+	{ CSR_PSKEY_HOSTIO_MAP_SCO_PCM,       CSR_TYPE_UINT16,  0,  "mapsco"   },
+	{ CSR_PSKEY_UART_BAUDRATE,            CSR_TYPE_UINT16,  0,  "baudrate" },
+	{ CSR_PSKEY_HOST_INTERFACE,           CSR_TYPE_UINT16,  0,  "hostintf" },
+	{ CSR_PSKEY_ANA_FREQ,                 CSR_TYPE_UINT16,  0,  "anafreq"  },
+	{ CSR_PSKEY_ANA_FTRIM,                CSR_TYPE_UINT16,  0,  "anaftrim" },
+	{ CSR_PSKEY_USB_VENDOR_ID,            CSR_TYPE_UINT16,  0,  "usbvid"   },
+	{ CSR_PSKEY_USB_PRODUCT_ID,           CSR_TYPE_UINT16,  0,  "usbpid"   },
+	{ CSR_PSKEY_USB_DFU_PRODUCT_ID,       CSR_TYPE_UINT16,  0,  "dfupid"   },
+	{ CSR_PSKEY_INITIAL_BOOTMODE,         CSR_TYPE_UINT16,  0,  "bootmode" },
+	{ 0x0000 },
+};
+
+static char *storestostr(uint16_t stores)
+{
+	switch (stores) {
+	case 0x0000:
+		return "Default";
+	case 0x0001:
+		return "psi";
+	case 0x0002:
+		return "psf";
+	case 0x0004:
+		return "psrom";
+	case 0x0008:
+		return "psram";
+	default:
+		return "Unknown";
+	}
+}
+
+static char *memorytostr(uint16_t type)
+{
+	switch (type) {
+	case 0x0000:
+		return "Flash memory";
+	case 0x0001:
+		return "EEPROM";
+	case 0x0002:
+		return "RAM (transient)";
+	case 0x0003:
+		return "ROM (or \"read-only\" flash memory)";
+	default:
+		return "Unknown";
+	}
+}
+
+#define OPT_RANGE(min, max) \
+		if (argc < (min)) { errno = EINVAL; return -1; } \
+		if (argc > (max)) { errno = E2BIG; return -1; }
+
+static struct option help_options[] = {
+	{ "help",	0, 0, 'h' },
+	{ 0, 0, 0, 0 }
+};
+
+static int opt_help(int argc, char *argv[], int *help)
+{
+	int opt;
+
+	while ((opt=getopt_long(argc, argv, "+h", help_options, NULL)) != EOF) {
+		switch (opt) {
+		case 'h':
+			if (help)
+				*help = 1;
+			break;
+		}
+	}
+
+	return optind;
+}
+
+#define OPT_HELP(range, help) \
+		opt_help(argc, argv, (help)); \
+		argc -= optind; argv += optind; optind = 0; \
+		OPT_RANGE((range), (range))
+
+static int cmd_builddef(int transport, int argc, char *argv[])
+{
+	uint8_t array[8];
+	uint16_t def = 0x0000, nextdef = 0x0000;
+	int err = 0;
+
+	OPT_HELP(0, NULL);
+
+	printf("Build definitions:\n");
+
+	while (1) {
+		memset(array, 0, sizeof(array));
+		array[0] = def & 0xff;
+		array[1] = def >> 8;
+
+		err = transport_read(transport, CSR_VARID_GET_NEXT_BUILDDEF, array, 8);
+		if (err < 0)
+			break;
+
+		nextdef = array[2] | (array[3] << 8);
+
+		if (nextdef == 0x0000)
+			break;
+
+		def = nextdef;
+
+		printf("0x%04x - %s\n", def, csr_builddeftostr(def));
+	}
+
+	return err;
+}
+
+static int cmd_keylen(int transport, int argc, char *argv[])
+{
+	uint8_t array[8];
+	uint16_t handle, keylen;
+	int err;
+
+	OPT_HELP(1, NULL);
+
+	handle = atoi(argv[0]);
+
+	memset(array, 0, sizeof(array));
+	array[0] = handle & 0xff;
+	array[1] = handle >> 8;
+
+	err = transport_read(transport, CSR_VARID_CRYPT_KEY_LENGTH, array, 8);
+	if (err < 0)
+		return -1;
+
+	keylen = array[2] | (array[3] << 8);
+
+	printf("Crypt key length: %d bit\n", keylen * 8);
+
+	return 0;
+}
+
+static int cmd_clock(int transport, int argc, char *argv[])
+{
+	uint8_t array[8];
+	uint32_t clock;
+	int err;
+
+	OPT_HELP(0, NULL);
+
+	memset(array, 0, sizeof(array));
+
+	err = transport_read(transport, CSR_VARID_BT_CLOCK, array, 8);
+	if (err < 0)
+		return -1;
+
+	clock = array[2] | (array[3] << 8) | (array[0] << 16) | (array[1] << 24);
+
+	printf("Bluetooth clock: 0x%04x (%d)\n", clock, clock);
+
+	return 0;
+}
+
+static int cmd_rand(int transport, int argc, char *argv[])
+{
+	uint8_t array[8];
+	uint16_t rand;
+	int err;
+
+	OPT_HELP(0, NULL);
+
+	memset(array, 0, sizeof(array));
+
+	err = transport_read(transport, CSR_VARID_RAND, array, 8);
+	if (err < 0)
+		return -1;
+
+	rand = array[0] | (array[1] << 8);
+
+	printf("Random number: 0x%02x (%d)\n", rand, rand);
+
+	return 0;
+}
+
+static int cmd_chiprev(int transport, int argc, char *argv[])
+{
+	uint8_t array[8];
+	uint16_t rev;
+	char *str;
+	int err;
+
+	OPT_HELP(0, NULL);
+
+	memset(array, 0, sizeof(array));
+
+	err = transport_read(transport, CSR_VARID_CHIPREV, array, 8);
+	if (err < 0)
+		return -1;
+
+	rev = array[0] | (array[1] << 8);
+
+	switch (rev) {
+	case 0x64:
+		str = "BC1 ES";
+		break;
+	case 0x65:
+		str = "BC1";
+		break;
+	case 0x89:
+		str = "BC2-External A";
+		break;
+	case 0x8a:
+		str = "BC2-External B";
+		break;
+	case 0x28:
+		str = "BC2-ROM";
+		break;
+	case 0x43:
+		str = "BC3-Multimedia";
+		break;
+	case 0x15:
+		str = "BC3-ROM";
+		break;
+	case 0xe2:
+		str = "BC3-Flash";
+		break;
+	case 0x26:
+		str = "BC4-External";
+		break;
+	case 0x30:
+		str = "BC4-ROM";
+		break;
+	default:
+		str = "NA";
+		break;
+	}
+
+	printf("Chip revision: 0x%04x (%s)\n", rev, str);
+
+	return 0;
+}
+
+static int cmd_buildname(int transport, int argc, char *argv[])
+{
+	uint8_t array[131];
+	char name[64];
+	unsigned int i;
+	int err;
+
+	OPT_HELP(0, NULL);
+
+	memset(array, 0, sizeof(array));
+
+	err = transport_read(transport, CSR_VARID_READ_BUILD_NAME, array, 128);
+	if (err < 0)
+		return -1;
+
+	for (i = 0; i < sizeof(name); i++)
+		name[i] = array[(i * 2) + 4];
+
+	printf("Build name: %s\n", name);
+
+	return 0;
+}
+
+static int cmd_panicarg(int transport, int argc, char *argv[])
+{
+	uint8_t array[8];
+	uint16_t error;
+	int err;
+
+	OPT_HELP(0, NULL);
+
+	memset(array, 0, sizeof(array));
+
+	err = transport_read(transport, CSR_VARID_PANIC_ARG, array, 8);
+	if (err < 0)
+		return -1;
+
+	error = array[0] | (array[1] << 8);
+
+	printf("Panic code: 0x%02x (%s)\n", error,
+					error < 0x100 ? "valid" : "invalid");
+
+	return 0;
+}
+
+static int cmd_faultarg(int transport, int argc, char *argv[])
+{
+	uint8_t array[8];
+	uint16_t error;
+	int err;
+
+	OPT_HELP(0, NULL);
+
+	memset(array, 0, sizeof(array));
+
+	err = transport_read(transport, CSR_VARID_FAULT_ARG, array, 8);
+	if (err < 0)
+		return -1;
+
+	error = array[0] | (array[1] << 8);
+
+	printf("Fault code: 0x%02x (%s)\n", error,
+					error < 0x100 ? "valid" : "invalid");
+
+	return 0;
+}
+
+static int cmd_coldreset(int transport, int argc, char *argv[])
+{
+	return transport_write(transport, CSR_VARID_COLD_RESET, NULL, 0);
+}
+
+static int cmd_warmreset(int transport, int argc, char *argv[])
+{
+	return transport_write(transport, CSR_VARID_WARM_RESET, NULL, 0);
+}
+
+static int cmd_disabletx(int transport, int argc, char *argv[])
+{
+	return transport_write(transport, CSR_VARID_DISABLE_TX, NULL, 0);
+}
+
+static int cmd_enabletx(int transport, int argc, char *argv[])
+{
+	return transport_write(transport, CSR_VARID_ENABLE_TX, NULL, 0);
+}
+
+static int cmd_singlechan(int transport, int argc, char *argv[])
+{
+	uint8_t array[8];
+	uint16_t channel;
+
+	OPT_HELP(1, NULL);
+
+	channel = atoi(argv[0]);
+
+	if (channel > 2401 && channel < 2481)
+		channel -= 2402;
+
+	if (channel > 78) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	memset(array, 0, sizeof(array));
+	array[0] = channel & 0xff;
+	array[1] = channel >> 8;
+
+	return transport_write(transport, CSR_VARID_SINGLE_CHAN, array, 8);
+}
+
+static int cmd_hoppingon(int transport, int argc, char *argv[])
+{
+	return transport_write(transport, CSR_VARID_HOPPING_ON, NULL, 0);
+}
+
+static int cmd_rttxdata1(int transport, int argc, char *argv[])
+{
+	uint8_t array[8];
+	uint16_t freq, level;
+
+	OPT_HELP(2, NULL);
+
+	freq = atoi(argv[0]);
+
+	if (!strncasecmp(argv[1], "0x", 2))
+		level = strtol(argv[1], NULL, 16);
+	else
+		level = atoi(argv[1]);
+
+	memset(array, 0, sizeof(array));
+	array[0] = 0x04;
+	array[1] = 0x00;
+	array[2] = freq & 0xff;
+	array[3] = freq >> 8;
+	array[4] = level & 0xff;
+	array[5] = level >> 8;
+
+	return transport_write(transport, CSR_VARID_RADIOTEST, array, 8);
+}
+
+static int cmd_radiotest(int transport, int argc, char *argv[])
+{
+	uint8_t array[8];
+	uint16_t freq, level, test;
+
+	OPT_HELP(3, NULL);
+
+	freq = atoi(argv[0]);
+
+	if (!strncasecmp(argv[1], "0x", 2))
+		level = strtol(argv[1], NULL, 16);
+	else
+		level = atoi(argv[1]);
+
+	test = atoi(argv[2]);
+
+	memset(array, 0, sizeof(array));
+	array[0] = test & 0xff;
+	array[1] = test >> 8;
+	array[2] = freq & 0xff;
+	array[3] = freq >> 8;
+	array[4] = level & 0xff;
+	array[5] = level >> 8;
+
+	return transport_write(transport, CSR_VARID_RADIOTEST, array, 8);
+}
+
+static int cmd_memtypes(int transport, int argc, char *argv[])
+{
+	uint8_t array[8];
+	uint16_t type, stores[4] = { 0x0001, 0x0002, 0x0004, 0x0008 };
+	int i, err;
+
+	OPT_HELP(0, NULL);
+
+	for (i = 0; i < 4; i++) {
+		memset(array, 0, sizeof(array));
+		array[0] = stores[i] & 0xff;
+		array[1] = stores[i] >> 8;
+
+		err = transport_read(transport, CSR_VARID_PS_MEMORY_TYPE, array, 8);
+		if (err < 0)
+			continue;
+
+		type = array[2] + (array[3] << 8);
+
+		printf("%s (0x%04x) = %s (%d)\n", storestostr(stores[i]),
+					stores[i], memorytostr(type), type);
+	}
+
+	return 0;
+}
+
+static struct option pskey_options[] = {
+	{ "stores",	1, 0, 's' },
+	{ "reset",	0, 0, 'r' },
+	{ "help",	0, 0, 'h' },
+	{ 0, 0, 0, 0 }
+};
+
+static int opt_pskey(int argc, char *argv[], uint16_t *stores, int *reset, int *help)
+{
+	int opt;
+
+	while ((opt=getopt_long(argc, argv, "+s:rh", pskey_options, NULL)) != EOF) {
+		switch (opt) {
+		case 's':
+			if (!stores)
+				break;
+			if (!strcasecmp(optarg, "default"))
+				*stores = 0x0000;
+			else if (!strcasecmp(optarg, "implementation"))
+				*stores = 0x0001;
+			else if (!strcasecmp(optarg, "factory"))
+				*stores = 0x0002;
+			else if (!strcasecmp(optarg, "rom"))
+				*stores = 0x0004;
+			else if (!strcasecmp(optarg, "ram"))
+				*stores = 0x0008;
+			else if (!strcasecmp(optarg, "psi"))
+				*stores = 0x0001;
+			else if (!strcasecmp(optarg, "psf"))
+				*stores = 0x0002;
+			else if (!strcasecmp(optarg, "psrom"))
+				*stores = 0x0004;
+			else if (!strcasecmp(optarg, "psram"))
+				*stores = 0x0008;
+			else if (!strncasecmp(optarg, "0x", 2))
+				*stores = strtol(optarg, NULL, 16);
+			else
+				*stores = atoi(optarg);
+			break;
+
+		case 'r':
+			if (reset)
+				*reset = 1;
+			break;
+
+		case 'h':
+			if (help)
+				*help = 1;
+			break;
+		}
+	}
+
+	return optind;
+}
+
+#define OPT_PSKEY(min, max, stores, reset, help) \
+		opt_pskey(argc, argv, (stores), (reset), (help)); \
+		argc -= optind; argv += optind; optind = 0; \
+		OPT_RANGE((min), (max))
+
+static int cmd_psget(int transport, int argc, char *argv[])
+{
+	uint8_t array[128];
+	uint16_t pskey, length, value, stores = CSR_STORES_DEFAULT;
+	uint32_t val32;
+	int i, err, reset = 0;
+
+	memset(array, 0, sizeof(array));
+
+	OPT_PSKEY(1, 1, &stores, &reset, NULL);
+
+	if (strncasecmp(argv[0], "0x", 2)) {
+		pskey = atoi(argv[0]);
+
+		for (i = 0; storage[i].pskey; i++) {
+			if (strcasecmp(storage[i].str, argv[0]))
+				continue;
+
+			pskey = storage[i].pskey;
+			break;
+		}
+	} else
+		pskey = strtol(argv[0] + 2, NULL, 16);
+
+	memset(array, 0, sizeof(array));
+	array[0] = pskey & 0xff;
+	array[1] = pskey >> 8;
+	array[2] = stores & 0xff;
+	array[3] = stores >> 8;
+
+	err = transport_read(transport, CSR_VARID_PS_SIZE, array, 8);
+	if (err < 0)
+		return err;
+
+	length = array[2] + (array[3] << 8);
+	if (length + 6 > (int) sizeof(array) / 2)
+		return -EIO;
+
+	memset(array, 0, sizeof(array));
+	array[0] = pskey & 0xff;
+	array[1] = pskey >> 8;
+	array[2] = length & 0xff;
+	array[3] = length >> 8;
+	array[4] = stores & 0xff;
+	array[5] = stores >> 8;
+
+	err = transport_read(transport, CSR_VARID_PS, array, (length + 3) * 2);
+	if (err < 0)
+		return err;
+
+	switch (length) {
+	case 1:
+		value = array[6] | (array[7] << 8);
+		printf("%s: 0x%04x (%d)\n", csr_pskeytostr(pskey), value, value);
+		break;
+
+	case 2:
+		val32 = array[8] | (array[9] << 8) | (array[6] << 16) | (array[7] << 24);
+		printf("%s: 0x%08x (%d)\n", csr_pskeytostr(pskey), val32, val32);
+		break;
+
+	default:
+		printf("%s:", csr_pskeytostr(pskey));
+		for (i = 0; i < length; i++)
+			printf(" 0x%02x%02x", array[(i * 2) + 6], array[(i * 2) + 7]);
+		printf("\n");
+		break;
+	}
+
+	if (reset)
+		transport_write(transport, CSR_VARID_WARM_RESET, NULL, 0);
+
+	return err;
+}
+
+static int cmd_psset(int transport, int argc, char *argv[])
+{
+	uint8_t array[128];
+	uint16_t pskey, length, value, stores = CSR_STORES_PSRAM;
+	uint32_t val32;
+	int i, err, reset = 0;
+
+	memset(array, 0, sizeof(array));
+
+	OPT_PSKEY(2, 81, &stores, &reset, NULL);
+
+	if (strncasecmp(argv[0], "0x", 2)) {
+		pskey = atoi(argv[0]);
+
+		for (i = 0; storage[i].pskey; i++) {
+			if (strcasecmp(storage[i].str, argv[0]))
+				continue;
+
+			pskey = storage[i].pskey;
+			break;
+		}
+	} else
+		pskey = strtol(argv[0] + 2, NULL, 16);
+
+	memset(array, 0, sizeof(array));
+	array[0] = pskey & 0xff;
+	array[1] = pskey >> 8;
+	array[2] = stores & 0xff;
+	array[3] = stores >> 8;
+
+	err = transport_read(transport, CSR_VARID_PS_SIZE, array, 8);
+	if (err < 0)
+		return err;
+
+	length = array[2] + (array[3] << 8);
+	if (length + 6 > (int) sizeof(array) / 2)
+		return -EIO;
+
+	memset(array, 0, sizeof(array));
+	array[0] = pskey & 0xff;
+	array[1] = pskey >> 8;
+	array[2] = length & 0xff;
+	array[3] = length >> 8;
+	array[4] = stores & 0xff;
+	array[5] = stores >> 8;
+
+	argc--;
+	argv++;
+
+	switch (length) {
+	case 1:
+		if (argc != 1) {
+			errno = E2BIG;
+			return -1;
+		}
+
+		if (!strncasecmp(argv[0], "0x", 2))
+			value = strtol(argv[0] + 2, NULL, 16);
+		else
+			value = atoi(argv[0]);
+
+		array[6] = value & 0xff;
+		array[7] = value >> 8;
+		break;
+
+	case 2:
+		if (argc != 1) {
+			errno = E2BIG;
+			return -1;
+		}
+
+		if (!strncasecmp(argv[0], "0x", 2))
+			val32 = strtol(argv[0] + 2, NULL, 16);
+		else
+			val32 = atoi(argv[0]);
+
+		array[6] = (val32 & 0xff0000) >> 16;
+		array[7] = val32 >> 24;
+		array[8] = val32 & 0xff;
+		array[9] = (val32 & 0xff00) >> 8;
+		break;
+
+	default:
+		if (argc != length * 2) {
+			errno = EINVAL;
+			return -1;
+		}
+
+		for (i = 0; i < length * 2; i++)
+			if (!strncasecmp(argv[0], "0x", 2))
+				array[i + 6] = strtol(argv[i] + 2, NULL, 16);
+			else
+				array[i + 6] = atoi(argv[i]);
+		break;
+	}
+
+	err = transport_write(transport, CSR_VARID_PS, array, (length + 3) * 2);
+	if (err < 0)
+		return err;
+
+	if (reset)
+		transport_write(transport, CSR_VARID_WARM_RESET, NULL, 0);
+
+	return err;
+}
+
+static int cmd_psclr(int transport, int argc, char *argv[])
+{
+	uint8_t array[8];
+	uint16_t pskey, stores = CSR_STORES_PSRAM;
+	int i, err, reset = 0;
+
+	OPT_PSKEY(1, 1, &stores, &reset, NULL);
+
+	if (strncasecmp(argv[0], "0x", 2)) {
+		pskey = atoi(argv[0]);
+
+		for (i = 0; storage[i].pskey; i++) {
+			if (strcasecmp(storage[i].str, argv[0]))
+				continue;
+
+			pskey = storage[i].pskey;
+			break;
+		}
+	} else
+		pskey = strtol(argv[0] + 2, NULL, 16);
+
+	memset(array, 0, sizeof(array));
+	array[0] = pskey & 0xff;
+	array[1] = pskey >> 8;
+	array[2] = stores & 0xff;
+	array[3] = stores >> 8;
+
+	err = transport_write(transport, CSR_VARID_PS_CLR_STORES, array, 8);
+	if (err < 0)
+		return err;
+
+	if (reset)
+		transport_write(transport, CSR_VARID_WARM_RESET, NULL, 0);
+
+	return err;
+}
+
+static int cmd_pslist(int transport, int argc, char *argv[])
+{
+	uint8_t array[8];
+	uint16_t pskey = 0x0000, length, stores = CSR_STORES_DEFAULT;
+	int err, reset = 0;
+
+	OPT_PSKEY(0, 0, &stores, &reset, NULL);
+
+	while (1) {
+		memset(array, 0, sizeof(array));
+		array[0] = pskey & 0xff;
+		array[1] = pskey >> 8;
+		array[2] = stores & 0xff;
+		array[3] = stores >> 8;
+
+		err = transport_read(transport, CSR_VARID_PS_NEXT, array, 8);
+		if (err < 0)
+			break;
+
+		pskey = array[4] + (array[5] << 8);
+		if (pskey == 0x0000)
+			break;
+
+		memset(array, 0, sizeof(array));
+		array[0] = pskey & 0xff;
+		array[1] = pskey >> 8;
+		array[2] = stores & 0xff;
+		array[3] = stores >> 8;
+
+		err = transport_read(transport, CSR_VARID_PS_SIZE, array, 8);
+		if (err < 0)
+			continue;
+
+		length = array[2] + (array[3] << 8);
+
+		printf("0x%04x - %s (%d bytes)\n", pskey,
+					csr_pskeytostr(pskey), length * 2);
+	}
+
+	if (reset)
+		transport_write(transport, CSR_VARID_WARM_RESET, NULL, 0);
+
+	return 0;
+}
+
+static int cmd_psread(int transport, int argc, char *argv[])
+{
+	uint8_t array[256];
+	uint16_t pskey = 0x0000, length, stores = CSR_STORES_DEFAULT;
+	char *str, val[7];
+	int i, err, reset = 0;
+
+	OPT_PSKEY(0, 0, &stores, &reset, NULL);
+
+	while (1) {
+		memset(array, 0, sizeof(array));
+		array[0] = pskey & 0xff;
+		array[1] = pskey >> 8;
+		array[2] = stores & 0xff;
+		array[3] = stores >> 8;
+
+		err = transport_read(transport, CSR_VARID_PS_NEXT, array, 8);
+		if (err < 0)
+			break;
+
+		pskey = array[4] + (array[5] << 8);
+		if (pskey == 0x0000)
+			break;
+
+		memset(array, 0, sizeof(array));
+		array[0] = pskey & 0xff;
+		array[1] = pskey >> 8;
+		array[2] = stores & 0xff;
+		array[3] = stores >> 8;
+
+		err = transport_read(transport, CSR_VARID_PS_SIZE, array, 8);
+		if (err < 0)
+			continue;
+
+		length = array[2] + (array[3] << 8);
+		if (length + 6 > (int) sizeof(array) / 2)
+			continue;
+
+		memset(array, 0, sizeof(array));
+		array[0] = pskey & 0xff;
+		array[1] = pskey >> 8;
+		array[2] = length & 0xff;
+		array[3] = length >> 8;
+		array[4] = stores & 0xff;
+		array[5] = stores >> 8;
+
+		err = transport_read(transport, CSR_VARID_PS, array, (length + 3) * 2);
+		if (err < 0)
+			continue;
+
+		str = csr_pskeytoval(pskey);
+		if (!strcasecmp(str, "UNKNOWN")) {
+			sprintf(val, "0x%04x", pskey);
+			str = NULL;
+		}
+
+		printf("// %s%s\n&%04x =", str ? "PSKEY_" : "",
+						str ? str : val, pskey);
+		for (i = 0; i < length; i++)
+			printf(" %02x%02x", array[(i * 2) + 7], array[(i * 2) + 6]);
+		printf("\n");
+	}
+
+	if (reset)
+		transport_write(transport, CSR_VARID_WARM_RESET, NULL, 0);
+
+	return 0;
+}
+
+static int cmd_psload(int transport, int argc, char *argv[])
+{
+	uint8_t array[256];
+	uint16_t pskey, length, size, stores = CSR_STORES_PSRAM;
+	char *str, val[7];
+	int err, reset = 0;
+
+	OPT_PSKEY(1, 1, &stores, &reset, NULL);
+
+	psr_read(argv[0]);
+
+	memset(array, 0, sizeof(array));
+	size = sizeof(array) - 6;
+
+	while (psr_get(&pskey, array + 6, &size) == 0) {
+		str = csr_pskeytoval(pskey);
+		if (!strcasecmp(str, "UNKNOWN")) {
+			sprintf(val, "0x%04x", pskey);
+			str = NULL;
+		}
+
+		printf("Loading %s%s ... ", str ? "PSKEY_" : "",
+							str ? str : val);
+		fflush(stdout);
+
+		length = size / 2;
+
+		array[0] = pskey & 0xff;
+		array[1] = pskey >> 8;
+		array[2] = length & 0xff;
+		array[3] = length >> 8;
+		array[4] = stores & 0xff;
+		array[5] = stores >> 8;
+
+		err = transport_write(transport, CSR_VARID_PS, array, size + 6);
+
+		printf("%s\n", err < 0 ? "failed" : "done");
+
+		memset(array, 0, sizeof(array));
+		size = sizeof(array) - 6;
+	}
+
+	if (reset)
+		transport_write(transport, CSR_VARID_WARM_RESET, NULL, 0);
+
+	return 0;
+}
+
+static int cmd_pscheck(int transport, int argc, char *argv[])
+{
+	uint8_t array[256];
+	uint16_t pskey, size;
+	int i;
+
+	OPT_HELP(1, NULL);
+
+	psr_read(argv[0]);
+
+	while (psr_get(&pskey, array, &size) == 0) {
+		printf("0x%04x =", pskey);
+		for (i = 0; i < size; i++)
+			printf(" 0x%02x", array[i]);
+		printf("\n");
+	}
+
+	return 0;
+}
+
+static int cmd_adc(int transport, int argc, char *argv[])
+{
+	uint8_t array[8];
+	uint16_t mux, value;
+	int err;
+
+	OPT_HELP(1, NULL);
+
+	if (!strncasecmp(argv[0], "0x", 2))
+		mux = strtol(argv[0], NULL, 16);
+	else
+		mux = atoi(argv[0]);
+
+	/* Request an ADC read from a particular mux'ed input */
+	memset(array, 0, sizeof(array));
+	array[0] = mux & 0xff;
+	array[1] = mux >> 8;
+
+	err = transport_write(transport, CSR_VARID_ADC, array, 2);
+	if (err < 0) {
+		errno = -err;
+		return -1;
+	}
+
+	/* have to wait a short while, then read result */
+	usleep(50000);
+	err = transport_read(transport, CSR_VARID_ADC_RES, array, 8);
+	if (err < 0) {
+		errno = -err;
+		return -1;
+	}
+
+	mux = array[0] | (array[1] << 8);
+	value = array[4] | (array[5] << 8);
+
+	printf("ADC value from Mux 0x%02x : 0x%04x (%s)\n", mux, value,
+					array[2] == 1 ? "valid" : "invalid");
+
+	return 0;
+}
+
+static struct {
+	char *str;
+	int (*func)(int transport, int argc, char *argv[]);
+	char *arg;
+	char *doc;
+} commands[] = {
+	{ "builddef",  cmd_builddef,  "",                    "Get build definitions"          },
+	{ "keylen",    cmd_keylen,    "<handle>",            "Get current crypt key length"   },
+	{ "clock",     cmd_clock,     "",                    "Get local Bluetooth clock"      },
+	{ "rand",      cmd_rand,      "",                    "Get random number"              },
+	{ "chiprev",   cmd_chiprev,   "",                    "Get chip revision"              },
+	{ "buildname", cmd_buildname, "",                    "Get the full build name"        },
+	{ "panicarg",  cmd_panicarg,  "",                    "Get panic code argument"        },
+	{ "faultarg",  cmd_faultarg,  "",                    "Get fault code argument"        },
+	{ "coldreset", cmd_coldreset, "",                    "Perform cold reset"             },
+	{ "warmreset", cmd_warmreset, "",                    "Perform warm reset"             },
+	{ "disabletx", cmd_disabletx, "",                    "Disable TX on the device"       },
+	{ "enabletx",  cmd_enabletx,  "",                    "Enable TX on the device"        },
+	{ "singlechan",cmd_singlechan,"<channel>",           "Lock radio on specific channel" },
+	{ "hoppingon", cmd_hoppingon, "",                    "Revert to channel hopping"      },
+	{ "rttxdata1", cmd_rttxdata1, "<freq> <level>",      "TXData1 radio test"             },
+	{ "radiotest", cmd_radiotest, "<freq> <level> <id>", "Run radio tests"                },
+	{ "memtypes",  cmd_memtypes,  NULL,                  "Get memory types"               },
+	{ "psget",     cmd_psget,     "<key>",               "Get value for PS key"           },
+	{ "psset",     cmd_psset,     "<key> <value>",       "Set value for PS key"           },
+	{ "psclr",     cmd_psclr,     "<key>",               "Clear value for PS key"         },
+	{ "pslist",    cmd_pslist,    NULL,                  "List all PS keys"               },
+	{ "psread",    cmd_psread,    NULL,                  "Read all PS keys"               },
+	{ "psload",    cmd_psload,    "<file>",              "Load all PS keys from PSR file" },
+	{ "pscheck",   cmd_pscheck,   "<file>",              "Check PSR file"                 },
+	{ "adc",       cmd_adc,       "<mux>",               "Read ADC value of <mux> input"  },
+	{ NULL }
+};
+
+static void usage(void)
+{
+	int i, pos = 0;
+
+	printf("bccmd - Utility for the CSR BCCMD interface\n\n");
+	printf("Usage:\n"
+		"\tbccmd [options] <command>\n\n");
+
+	printf("Options:\n"
+		"\t-t <transport>     Select the transport\n"
+		"\t-d <device>        Select the device\n"
+		"\t-b <bcsp rate>     Select the bcsp transfer rate\n"
+		"\t-h, --help         Display help\n"
+		"\n");
+
+	printf("Transports:\n"
+		"\tHCI USB BCSP H4 3WIRE\n\n");
+
+	printf("Commands:\n");
+	for (i = 0; commands[i].str; i++)
+		printf("\t%-10s %-20s\t%s\n", commands[i].str,
+		commands[i].arg ? commands[i].arg : " ",
+		commands[i].doc);
+	printf("\n");
+
+	printf("Keys:\n\t");
+	for (i = 0; storage[i].pskey; i++) {
+		printf("%s ", storage[i].str);
+		pos += strlen(storage[i].str) + 1;
+		if (pos > 60) {
+			printf("\n\t");
+			pos = 0;
+		}
+	}
+	printf("\n");
+}
+
+static struct option main_options[] = {
+	{ "transport",	1, 0, 't' },
+	{ "device",	1, 0, 'd' },
+	{ "bcsprate", 1, 0, 'b'},
+	{ "help",	0, 0, 'h' },
+	{ 0, 0, 0, 0 }
+};
+
+int main(int argc, char *argv[])
+{
+	char *device = NULL;
+	int i, err, opt, transport = CSR_TRANSPORT_HCI;
+	speed_t bcsp_rate = B38400;
+
+	while ((opt=getopt_long(argc, argv, "+t:d:i:b:h", main_options, NULL)) != EOF) {
+		switch (opt) {
+		case 't':
+			if (!strcasecmp(optarg, "hci"))
+				transport = CSR_TRANSPORT_HCI;
+			else if (!strcasecmp(optarg, "usb"))
+				transport = CSR_TRANSPORT_USB;
+			else if (!strcasecmp(optarg, "bcsp"))
+				transport = CSR_TRANSPORT_BCSP;
+			else if (!strcasecmp(optarg, "h4"))
+				transport = CSR_TRANSPORT_H4;
+			else if (!strcasecmp(optarg, "h5"))
+				transport = CSR_TRANSPORT_3WIRE;
+			else if (!strcasecmp(optarg, "3wire"))
+				transport = CSR_TRANSPORT_3WIRE;
+			else if (!strcasecmp(optarg, "twutl"))
+				transport = CSR_TRANSPORT_3WIRE;
+			else
+				transport = CSR_TRANSPORT_UNKNOWN;
+			break;
+
+		case 'd':
+		case 'i':
+			device = strdup(optarg);
+			break;
+		case 'b':
+			bcsp_rate = tty_get_speed(atoi(optarg));
+			if (!bcsp_rate) {
+				printf("Unknown BCSP baud rate specified, defaulting to 38400bps\n");
+				bcsp_rate = B38400;
+			}
+			break;
+		case 'h':
+		default:
+			usage();
+			exit(0);
+		}
+	}
+
+	argc -= optind;
+	argv += optind;
+	optind = 0;
+
+	if (argc < 1) {
+		usage();
+		exit(1);
+	}
+
+	if (transport_open(transport, device, bcsp_rate) < 0)
+		exit(1);
+
+	free(device);
+
+	for (i = 0; commands[i].str; i++) {
+		if (strcasecmp(commands[i].str, argv[0]))
+			continue;
+
+		err = commands[i].func(transport, argc, argv);
+
+		transport_close(transport);
+
+		if (err < 0) {
+			fprintf(stderr, "Can't execute command: %s (%d)\n",
+							strerror(errno), errno);
+			exit(1);
+		}
+
+		exit(0);
+	}
+
+	fprintf(stderr, "Unsupported command\n");
+
+	transport_close(transport);
+
+	exit(1);
+}
diff --git a/tools/csr.c b/tools/csr.c
new file mode 100644
index 000000000..61bdaa0cf
--- /dev/null
+++ b/tools/csr.c
@@ -0,0 +1,2856 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2003-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <sys/socket.h>
+
+#include "lib/bluetooth.h"
+#include "lib/hci.h"
+#include "lib/hci_lib.h"
+
+#include "csr.h"
+
+struct psr_data {
+	uint16_t pskey;
+	uint8_t *value;
+	uint8_t size;
+	struct psr_data *next;
+};
+
+static struct psr_data *head = NULL, *tail = NULL;
+
+static struct {
+	uint16_t id;
+	char *str;
+} csr_map[] = {
+	{   66, "HCI 9.8"	},
+	{   97, "HCI 10.3"	},
+	{  101, "HCI 10.5"	},
+	{  111,	"HCI 11.0"	},
+	{  112,	"HCI 11.1"	},
+	{  114,	"HCI 11.2"	},
+	{  115,	"HCI 11.3"	},
+	{  117,	"HCI 12.0"	},
+	{  119,	"HCI 12.1"	},
+	{  133,	"HCI 12.2"	},
+	{  134,	"HCI 12.3"	},
+	{  162,	"HCI 12.4"	},
+	{  165,	"HCI 12.5"	},
+	{  169,	"HCI 12.6"	},
+	{  188,	"HCI 12.7"	},
+	{  218,	"HCI 12.8"	},
+	{  283,	"HCI 12.9"	},
+	{  203,	"HCI 13.2"	},
+	{  204,	"HCI 13.2"	},
+	{  210,	"HCI 13.3"	},
+	{  211,	"HCI 13.3"	},
+	{  213,	"HCI 13.4"	},
+	{  214,	"HCI 13.4"	},
+	{  225,	"HCI 13.5"	},
+	{  226,	"HCI 13.5"	},
+	{  237,	"HCI 13.6"	},
+	{  238,	"HCI 13.6"	},
+	{  242,	"HCI 14.0"	},
+	{  243,	"HCI 14.0"	},
+	{  244,	"HCI 14.0"	},
+	{  245,	"HCI 14.0"	},
+	{  254,	"HCI 13.7"	},
+	{  255,	"HCI 13.7"	},
+	{  264,	"HCI 14.1"	},
+	{  265,	"HCI 14.1"	},
+	{  267,	"HCI 14.2"	},
+	{  268,	"HCI 14.2"	},
+	{  272,	"HCI 14.3"	},
+	{  273,	"HCI 14.3"	},
+	{  274,	"HCI 13.8"	},
+	{  275,	"HCI 13.8"	},
+	{  286,	"HCI 13.9"	},
+	{  287,	"HCI 13.9"	},
+	{  309,	"HCI 13.10"	},
+	{  310,	"HCI 13.10"	},
+	{  313,	"HCI 14.4"	},
+	{  314,	"HCI 14.4"	},
+	{  323,	"HCI 14.5"	},
+	{  324,	"HCI 14.5"	},
+	{  336,	"HCI 14.6"	},
+	{  337,	"HCI 14.6"	},
+	{  351,	"HCI 13.11"	},
+	{  352,	"HCI 13.11"	},
+	{  362,	"HCI 15.0"	},
+	{  363,	"HCI 15.0"	},
+	{  364,	"HCI 15.0"	},
+	{  365,	"HCI 15.0"	},
+	{  373,	"HCI 14.7"	},
+	{  374,	"HCI 14.7"	},
+	{  379,	"HCI 15.1"	},
+	{  380,	"HCI 15.1"	},
+	{  381,	"HCI 15.1"	},
+	{  382,	"HCI 15.1"	},
+	{  392,	"HCI 15.2"	},
+	{  393,	"HCI 15.2"	},
+	{  394,	"HCI 15.2"	},
+	{  395,	"HCI 15.2"	},
+	{  436,	"HCI 16.0"	},
+	{  437,	"HCI 16.0"	},
+	{  438,	"HCI 16.0"	},
+	{  439,	"HCI 16.0"	},
+	{  443,	"HCI 15.3"	},
+	{  444,	"HCI 15.3"	},
+	{  465,	"HCI 16.1"	},
+	{  466,	"HCI 16.1"	},
+	{  467,	"HCI 16.1"	},
+	{  468,	"HCI 16.1"	},
+	{  487,	"HCI 14.8"	},
+	{  488,	"HCI 14.8"	},
+	{  492,	"HCI 16.2"	},
+	{  493,	"HCI 16.2"	},
+	{  495,	"HCI 16.2"	},
+	{  496,	"HCI 16.2"	},
+	{  502,	"HCI 16.1.1"	},
+	{  503,	"HCI 16.1.1"	},
+	{  504,	"HCI 16.1.1"	},
+	{  505,	"HCI 16.1.1"	},
+	{  506,	"HCI 16.1.2"	},
+	{  507,	"HCI 16.1.2"	},
+	{  508,	"HCI 16.1.2"	},
+	{  509,	"HCI 16.1.2"	},
+	{  516,	"HCI 16.3"	},
+	{  517,	"HCI 16.3"	},
+	{  518,	"HCI 16.3"	},
+	{  519,	"HCI 16.3"	},
+	{  523,	"HCI 16.4"	},
+	{  524,	"HCI 16.4"	},
+	{  525,	"HCI 16.4"	},
+	{  526,	"HCI 16.4"	},
+	{  553,	"HCI 15.3"	},
+	{  554,	"HCI 15.3"	},
+	{  562,	"HCI 16.5"	},
+	{  563,	"HCI 16.5"	},
+	{  564,	"HCI 16.5"	},
+	{  565,	"HCI 16.5"	},
+	{  593,	"HCI 17.0"	},
+	{  594,	"HCI 17.0"	},
+	{  595,	"HCI 17.0"	},
+	{  599,	"HCI 17.0"	},
+	{  600,	"HCI 17.0"	},
+	{  608,	"HCI 13.10.1"	},
+	{  609,	"HCI 13.10.1"	},
+	{  613,	"HCI 17.1"	},
+	{  614,	"HCI 17.1"	},
+	{  615,	"HCI 17.1"	},
+	{  616,	"HCI 17.1"	},
+	{  618,	"HCI 17.1"	},
+	{  624,	"HCI 17.2"	},
+	{  625,	"HCI 17.2"	},
+	{  626,	"HCI 17.2"	},
+	{  627,	"HCI 17.2"	},
+	{  637,	"HCI 16.6"	},
+	{  638,	"HCI 16.6"	},
+	{  639,	"HCI 16.6"	},
+	{  640,	"HCI 16.6"	},
+	{  642,	"HCI 13.10.2"	},
+	{  643,	"HCI 13.10.2"	},
+	{  644,	"HCI 13.10.3"	},
+	{  645,	"HCI 13.10.3"	},
+	{  668,	"HCI 13.10.4"	},
+	{  669,	"HCI 13.10.4"	},
+	{  681,	"HCI 16.7"	},
+	{  682,	"HCI 16.7"	},
+	{  683,	"HCI 16.7"	},
+	{  684,	"HCI 16.7"	},
+	{  704,	"HCI 16.8"	},
+	{  718,	"HCI 16.4.1"	},
+	{  719,	"HCI 16.4.1"	},
+	{  720,	"HCI 16.4.1"	},
+	{  721,	"HCI 16.4.1"	},
+	{  722,	"HCI 16.7.1"	},
+	{  723,	"HCI 16.7.1"	},
+	{  724,	"HCI 16.7.1"	},
+	{  725,	"HCI 16.7.1"	},
+	{  731,	"HCI 16.7.2"	},
+	{  732,	"HCI 16.7.2"	},
+	{  733,	"HCI 16.7.2"	},
+	{  734,	"HCI 16.7.2"	},
+	{  735,	"HCI 16.4.2"	},
+	{  736,	"HCI 16.4.2"	},
+	{  737,	"HCI 16.4.2"	},
+	{  738,	"HCI 16.4.2"	},
+	{  750,	"HCI 16.7.3"	},
+	{  751,	"HCI 16.7.3"	},
+	{  752,	"HCI 16.7.3"	},
+	{  753,	"HCI 16.7.3"	},
+	{  760,	"HCI 16.7.4"	},
+	{  761,	"HCI 16.7.4"	},
+	{  762,	"HCI 16.7.4"	},
+	{  763,	"HCI 16.7.4"	},
+	{  770,	"HCI 16.9"	},
+	{  771,	"HCI 16.9"	},
+	{  772,	"HCI 16.9"	},
+	{  773,	"HCI 16.9"	},
+	{  774,	"HCI 17.3"	},
+	{  775,	"HCI 17.3"	},
+	{  776,	"HCI 17.3"	},
+	{  777,	"HCI 17.3"	},
+	{  781,	"HCI 16.7.5"	},
+	{  786,	"HCI 16.10"	},
+	{  787,	"HCI 16.10"	},
+	{  788,	"HCI 16.10"	},
+	{  789,	"HCI 16.10"	},
+	{  791,	"HCI 16.4.3"	},
+	{  792,	"HCI 16.4.3"	},
+	{  793,	"HCI 16.4.3"	},
+	{  794,	"HCI 16.4.3"	},
+	{  798,	"HCI 16.11"	},
+	{  799,	"HCI 16.11"	},
+	{  800,	"HCI 16.11"	},
+	{  801,	"HCI 16.11"	},
+	{  806,	"HCI 16.7.5"	},
+	{  807,	"HCI 16.12"	},
+	{  808,	"HCI 16.12"	},
+	{  809,	"HCI 16.12"	},
+	{  810,	"HCI 16.12"	},
+	{  817,	"HCI 16.13"	},
+	{  818,	"HCI 16.13"	},
+	{  819,	"HCI 16.13"	},
+	{  820,	"HCI 16.13"	},
+	{  823,	"HCI 13.10.5"	},
+	{  824,	"HCI 13.10.5"	},
+	{  826,	"HCI 16.14"	},
+	{  827,	"HCI 16.14"	},
+	{  828,	"HCI 16.14"	},
+	{  829,	"HCI 16.14"	},
+	{  843,	"HCI 17.3.1"	},
+	{  856,	"HCI 17.3.2"	},
+	{  857,	"HCI 17.3.2"	},
+	{  858,	"HCI 17.3.2"	},
+	{ 1120, "HCI 17.11"	},
+	{ 1168, "HCI 18.1"	},
+	{ 1169, "HCI 18.1"	},
+	{ 1241, "HCI 18.x"	},
+	{ 1298, "HCI 18.2"	},
+	{ 1354, "HCI 18.2"	},
+	{ 1392, "HCI 18.2"	},
+	{ 1393, "HCI 18.2"	},
+	{ 1501, "HCI 18.2"	},
+	{ 1503, "HCI 18.2"	},
+	{ 1504, "HCI 18.2"	},
+	{ 1505, "HCI 18.2"	},
+	{ 1506, "HCI 18.2"	},
+	{ 1520, "HCI 18.2"	},
+	{ 1586, "HCI 18.2"	},
+	{ 1591, "HCI 18.2"	},
+	{ 1592, "HCI 18.2"	},
+	{ 1593, "HCI 18.2.1"	},
+	{ 1733, "HCI 18.3"	},
+	{ 1734, "HCI 18.3"	},
+	{ 1735, "HCI 18.3"	},
+	{ 1737, "HCI 18.3"	},
+	{ 1915, "HCI 19.2"	},
+	{ 1916, "HCI 19.2"	},
+	{ 1958, "HCI 19.2"	},
+	{ 1981, "Unified 20a"	},
+	{ 1982, "Unified 20a"	},
+	{ 1989, "HCI 18.4"	},
+	{ 2062, "Unified 20a1"	},
+	{ 2063, "Unified 20a1"	},
+	{ 2067, "Unified 18f"	},
+	{ 2068, "Unified 18f"	},
+	{ 2243, "Unified 18e"	},
+	{ 2244, "Unified 18e"	},
+	{ 2258, "Unified 20d"	},
+	{ 2259, "Unified 20d"	},
+	{ 2361, "Unified 20e"	},
+	{ 2362, "Unified 20e"	},
+	{ 2386, "Unified 21a"	},
+	{ 2387, "Unified 21a"	},
+	{ 2423, "Unified 21a"	},
+	{ 2424, "Unified 21a"	},
+	{ 2623, "Unified 21c"	},
+	{ 2624, "Unified 21c"	},
+	{ 2625, "Unified 21c"	},
+	{ 2626, "Unified 21c"	},
+	{ 2627, "Unified 21c"	},
+	{ 2628, "Unified 21c"	},
+	{ 2629, "Unified 21c"	},
+	{ 2630, "Unified 21c"	},
+	{ 2631, "Unified 21c"	},
+	{ 2632, "Unified 21c"	},
+	{ 2633, "Unified 21c"	},
+	{ 2634, "Unified 21c"	},
+	{ 2635, "Unified 21c"	},
+	{ 2636, "Unified 21c"	},
+	{ 2649, "Unified 21c"	},
+	{ 2650, "Unified 21c"	},
+	{ 2651, "Unified 21c"	},
+	{ 2652, "Unified 21c"	},
+	{ 2653, "Unified 21c"	},
+	{ 2654, "Unified 21c"	},
+	{ 2655, "Unified 21c"	},
+	{ 2656, "Unified 21c"	},
+	{ 2658, "Unified 21c"	},
+	{ 3057, "Unified 21d"	},
+	{ 3058, "Unified 21d"	},
+	{ 3059, "Unified 21d"	},
+	{ 3060, "Unified 21d"	},
+	{ 3062, "Unified 21d"	},
+	{ 3063, "Unified 21d"	},
+	{ 3064, "Unified 21d"	},
+	{ 3164, "Unified 21e"	},
+	{ 3413, "Unified 21f"	},
+	{ 3414, "Unified 21f"	},
+	{ 3415, "Unified 21f"	},
+	{ 3424, "Unified 21f"	},
+	{ 3454, "Unified 21f"	},
+	{ 3684, "Unified 21f"	},
+	{ 3764, "Unified 21f"	},
+	{ 4276, "Unified 22b"	},
+	{ 4277, "Unified 22b"	},
+	{ 4279, "Unified 22b"	},
+	{ 4281, "Unified 22b"	},
+	{ 4282, "Unified 22b"	},
+	{ 4283, "Unified 22b"	},
+	{ 4284, "Unified 22b"	},
+	{ 4285, "Unified 22b"	},
+	{ 4289, "Unified 22b"	},
+	{ 4290, "Unified 22b"	},
+	{ 4291, "Unified 22b"	},
+	{ 4292, "Unified 22b"	},
+	{ 4293, "Unified 22b"	},
+	{ 4294, "Unified 22b"	},
+	{ 4295, "Unified 22b"	},
+	{ 4363, "Unified 22c"	},
+	{ 4373, "Unified 22c"	},
+	{ 4374, "Unified 22c"	},
+	{ 4532, "Unified 22d"	},
+	{ 4533, "Unified 22d"	},
+	{ 4698, "Unified 23c"	},
+	{ 4839, "Unified 23c"	},
+	{ 4841, "Unified 23c"	},
+	{ 4866, "Unified 23c"	},
+	{ 4867, "Unified 23c"	},
+	{ 4868, "Unified 23c"	},
+	{ 4869, "Unified 23c"	},
+	{ 4870, "Unified 23c"	},
+	{ 4871, "Unified 23c"	},
+	{ 4872, "Unified 23c"	},
+	{ 4874, "Unified 23c"	},
+	{ 4875, "Unified 23c"	},
+	{ 4876, "Unified 23c"	},
+	{ 4877, "Unified 23c"	},
+	{ 2526, "Marcel 1 (2005-09-26)"	},
+	{ 2543, "Marcel 2 (2005-09-28)"	},
+	{ 2622, "Marcel 3 (2005-10-27)"	},
+	{ 3326, "Marcel 4 (2006-06-16)"	},
+	{ 3612, "Marcel 5 (2006-10-24)"	},
+	{ 4509, "Marcel 6 (2007-06-11)"	},
+	{ 5417, "Marcel 7 (2008-08-26)" },
+	{  195, "Sniff 1 (2001-11-27)"	},
+	{  220, "Sniff 2 (2002-01-03)"	},
+	{  269, "Sniff 3 (2002-02-22)"	},
+	{  270, "Sniff 4 (2002-02-26)"	},
+	{  284, "Sniff 5 (2002-03-12)"	},
+	{  292, "Sniff 6 (2002-03-20)"	},
+	{  305, "Sniff 7 (2002-04-12)"	},
+	{  306, "Sniff 8 (2002-04-12)"	},
+	{  343, "Sniff 9 (2002-05-02)"	},
+	{  346, "Sniff 10 (2002-05-03)"	},
+	{  355, "Sniff 11 (2002-05-16)"	},
+	{  256, "Sniff 11 (2002-05-16)"	},
+	{  390, "Sniff 12 (2002-06-26)"	},
+	{  450, "Sniff 13 (2002-08-16)"	},
+	{  451, "Sniff 13 (2002-08-16)"	},
+	{  533, "Sniff 14 (2002-10-11)"	},
+	{  580, "Sniff 15 (2002-11-14)"	},
+	{  623, "Sniff 16 (2002-12-12)"	},
+	{  678, "Sniff 17 (2003-01-29)"	},
+	{  847, "Sniff 18 (2003-04-17)"	},
+	{  876, "Sniff 19 (2003-06-10)"	},
+	{  997, "Sniff 22 (2003-09-05)"	},
+	{ 1027, "Sniff 23 (2003-10-03)"	},
+	{ 1029, "Sniff 24 (2003-10-03)"	},
+	{ 1112, "Sniff 25 (2003-12-03)"	},
+	{ 1113, "Sniff 25 (2003-12-03)"	},
+	{ 1133, "Sniff 26 (2003-12-18)"	},
+	{ 1134, "Sniff 26 (2003-12-18)"	},
+	{ 1223, "Sniff 27 (2004-03-08)"	},
+	{ 1224, "Sniff 27 (2004-03-08)"	},
+	{ 1319, "Sniff 31 (2004-04-22)"	},
+	{ 1320, "Sniff 31 (2004-04-22)"	},
+	{ 1427, "Sniff 34 (2004-06-16)"	},
+	{ 1508, "Sniff 35 (2004-07-19)"	},
+	{ 1509, "Sniff 35 (2004-07-19)"	},
+	{ 1587, "Sniff 36 (2004-08-18)"	},
+	{ 1588, "Sniff 36 (2004-08-18)"	},
+	{ 1641, "Sniff 37 (2004-09-16)"	},
+	{ 1642, "Sniff 37 (2004-09-16)"	},
+	{ 1699, "Sniff 38 (2004-10-07)"	},
+	{ 1700, "Sniff 38 (2004-10-07)"	},
+	{ 1752, "Sniff 39 (2004-11-02)"	},
+	{ 1753, "Sniff 39 (2004-11-02)"	},
+	{ 1759, "Sniff 40 (2004-11-03)"	},
+	{ 1760, "Sniff 40 (2004-11-03)"	},
+	{ 1761, "Sniff 40 (2004-11-03)"	},
+	{ 2009, "Sniff 41 (2005-04-06)"	},
+	{ 2010, "Sniff 41 (2005-04-06)"	},
+	{ 2011, "Sniff 41 (2005-04-06)"	},
+	{ 2016, "Sniff 42 (2005-04-11)"	},
+	{ 2017, "Sniff 42 (2005-04-11)"	},
+	{ 2018, "Sniff 42 (2005-04-11)"	},
+	{ 2023, "Sniff 43 (2005-04-14)"	},
+	{ 2024, "Sniff 43 (2005-04-14)"	},
+	{ 2025, "Sniff 43 (2005-04-14)"	},
+	{ 2032, "Sniff 44 (2005-04-18)"	},
+	{ 2033, "Sniff 44 (2005-04-18)"	},
+	{ 2034, "Sniff 44 (2005-04-18)"	},
+	{ 2288, "Sniff 45 (2005-07-08)"	},
+	{ 2289, "Sniff 45 (2005-07-08)"	},
+	{ 2290, "Sniff 45 (2005-07-08)"	},
+	{ 2388, "Sniff 46 (2005-08-17)"	},
+	{ 2389, "Sniff 46 (2005-08-17)"	},
+	{ 2390, "Sniff 46 (2005-08-17)"	},
+	{ 2869, "Sniff 47 (2006-02-15)"	},
+	{ 2870, "Sniff 47 (2006-02-15)"	},
+	{ 2871, "Sniff 47 (2006-02-15)"	},
+	{ 3214, "Sniff 48 (2006-05-16)"	},
+	{ 3215, "Sniff 48 (2006-05-16)"	},
+	{ 3216, "Sniff 48 (2006-05-16)"	},
+	{ 3356, "Sniff 49 (2006-07-17)"	},
+	{ 3529, "Sniff 50 (2006-09-21)"	},
+	{ 3546, "Sniff 51 (2006-09-29)"	},
+	{ 3683, "Sniff 52 (2006-11-03)"	},
+	{    0, }
+};
+
+char *csr_builddeftostr(uint16_t def)
+{
+	switch (def) {
+	case 0x0000:
+		return "NONE";
+	case 0x0001:
+		return "CHIP_BASE_BC01";
+	case 0x0002:
+		return "CHIP_BASE_BC02";
+	case 0x0003:
+		return "CHIP_BC01B";
+	case 0x0004:
+		return "CHIP_BC02_EXTERNAL";
+	case 0x0005:
+		return "BUILD_HCI";
+	case 0x0006:
+		return "BUILD_RFCOMM";
+	case 0x0007:
+		return "BT_VER_1_1";
+	case 0x0008:
+		return "TRANSPORT_ALL";
+	case 0x0009:
+		return "TRANSPORT_BCSP";
+	case 0x000a:
+		return "TRANSPORT_H4";
+	case 0x000b:
+		return "TRANSPORT_USB";
+	case 0x000c:
+		return "MAX_CRYPT_KEY_LEN_56";
+	case 0x000d:
+		return "MAX_CRYPT_KEY_LEN_128";
+	case 0x000e:
+		return "TRANSPORT_USER";
+	case 0x000f:
+		return "CHIP_BC02_KATO";
+	case 0x0010:
+		return "TRANSPORT_NONE";
+	case 0x0012:
+		return "REQUIRE_8MBIT";
+	case 0x0013:
+		return "RADIOTEST";
+	case 0x0014:
+		return "RADIOTEST_LITE";
+	case 0x0015:
+		return "INSTALL_FLASH";
+	case 0x0016:
+		return "INSTALL_EEPROM";
+	case 0x0017:
+		return "INSTALL_COMBO_DOT11";
+	case 0x0018:
+		return "LOWPOWER_TX";
+	case 0x0019:
+		return "TRANSPORT_TWUTL";
+	case 0x001a:
+		return "COMPILER_GCC";
+	case 0x001b:
+		return "CHIP_BC02_CLOUSEAU";
+	case 0x001c:
+		return "CHIP_BC02_TOULOUSE";
+	case 0x001d:
+		return "CHIP_BASE_BC3";
+	case 0x001e:
+		return "CHIP_BC3_NICKNACK";
+	case 0x001f:
+		return "CHIP_BC3_KALIMBA";
+	case 0x0020:
+		return "INSTALL_HCI_MODULE";
+	case 0x0021:
+		return "INSTALL_L2CAP_MODULE";
+	case 0x0022:
+		return "INSTALL_DM_MODULE";
+	case 0x0023:
+		return "INSTALL_SDP_MODULE";
+	case 0x0024:
+		return "INSTALL_RFCOMM_MODULE";
+	case 0x0025:
+		return "INSTALL_HIDIO_MODULE";
+	case 0x0026:
+		return "INSTALL_PAN_MODULE";
+	case 0x0027:
+		return "INSTALL_IPV4_MODULE";
+	case 0x0028:
+		return "INSTALL_IPV6_MODULE";
+	case 0x0029:
+		return "INSTALL_TCP_MODULE";
+	case 0x002a:
+		return "BT_VER_1_2";
+	case 0x002b:
+		return "INSTALL_UDP_MODULE";
+	case 0x002c:
+		return "REQUIRE_0_WAIT_STATES";
+	case 0x002d:
+		return "CHIP_BC3_PADDYWACK";
+	case 0x002e:
+		return "CHIP_BC4_COYOTE";
+	case 0x002f:
+		return "CHIP_BC4_ODDJOB";
+	case 0x0030:
+		return "TRANSPORT_H4DS";
+	case 0x0031:
+		return "CHIP_BASE_BC4";
+	default:
+		return "UNKNOWN";
+	}
+}
+
+char *csr_buildidtostr(uint16_t id)
+{
+	static char str[12];
+	int i;
+
+	for (i = 0; csr_map[i].id; i++)
+		if (csr_map[i].id == id)
+			return csr_map[i].str;
+
+	snprintf(str, sizeof(str), "Build %d", id);
+	return str;
+}
+
+char *csr_chipvertostr(uint16_t ver, uint16_t rev)
+{
+	switch (ver) {
+	case 0x00:
+		return "BlueCore01a";
+	case 0x01:
+		switch (rev) {
+		case 0x64:
+			return "BlueCore01b (ES)";
+		case 0x65:
+		default:
+			return "BlueCore01b";
+		}
+	case 0x02:
+		switch (rev) {
+		case 0x89:
+			return "BlueCore02-External (ES2)";
+		case 0x8a:
+			return "BlueCore02-External";
+		case 0x28:
+			return "BlueCore02-ROM/Audio/Flash";
+		default:
+			return "BlueCore02";
+		}
+	case 0x03:
+		switch (rev) {
+		case 0x43:
+			return "BlueCore3-MM";
+		case 0x15:
+			return "BlueCore3-ROM";
+		case 0xe2:
+			return "BlueCore3-Flash";
+		case 0x26:
+			return "BlueCore4-External";
+		case 0x30:
+			return "BlueCore4-ROM";
+		default:
+			return "BlueCore3 or BlueCore4";
+		}
+	default:
+		return "Unknown";
+	}
+}
+
+char *csr_pskeytostr(uint16_t pskey)
+{
+	switch (pskey) {
+	case CSR_PSKEY_BDADDR:
+		return "Bluetooth address";
+	case CSR_PSKEY_COUNTRYCODE:
+		return "Country code";
+	case CSR_PSKEY_CLASSOFDEVICE:
+		return "Class of device";
+	case CSR_PSKEY_DEVICE_DRIFT:
+		return "Device drift";
+	case CSR_PSKEY_DEVICE_JITTER:
+		return "Device jitter";
+	case CSR_PSKEY_MAX_ACLS:
+		return "Maximum ACL links";
+	case CSR_PSKEY_MAX_SCOS:
+		return "Maximum SCO links";
+	case CSR_PSKEY_MAX_REMOTE_MASTERS:
+		return "Maximum remote masters";
+	case CSR_PSKEY_ENABLE_MASTERY_WITH_SLAVERY:
+		return "Support master and slave roles simultaneously";
+	case CSR_PSKEY_H_HC_FC_MAX_ACL_PKT_LEN:
+		return "Maximum HCI ACL packet length";
+	case CSR_PSKEY_H_HC_FC_MAX_SCO_PKT_LEN:
+		return "Maximum HCI SCO packet length";
+	case CSR_PSKEY_H_HC_FC_MAX_ACL_PKTS:
+		return "Maximum number of HCI ACL packets";
+	case CSR_PSKEY_H_HC_FC_MAX_SCO_PKTS:
+		return "Maximum number of HCI SCO packets";
+	case CSR_PSKEY_LC_FC_BUFFER_LOW_WATER_MARK:
+		return "Flow control low water mark";
+	case CSR_PSKEY_LC_MAX_TX_POWER:
+		return "Maximum transmit power";
+	case CSR_PSKEY_TX_GAIN_RAMP:
+		return "Transmit gain ramp rate";
+	case CSR_PSKEY_LC_POWER_TABLE:
+		return "Radio power table";
+	case CSR_PSKEY_LC_PEER_POWER_PERIOD:
+		return "Peer transmit power control interval";
+	case CSR_PSKEY_LC_FC_POOLS_LOW_WATER_MARK:
+		return "Flow control pool low water mark";
+	case CSR_PSKEY_LC_DEFAULT_TX_POWER:
+		return "Default transmit power";
+	case CSR_PSKEY_LC_RSSI_GOLDEN_RANGE:
+		return "RSSI at bottom of golden receive range";
+	case CSR_PSKEY_LC_COMBO_DISABLE_PIO_MASK:
+		return "Combo: PIO lines and logic to disable transmit";
+	case CSR_PSKEY_LC_COMBO_PRIORITY_PIO_MASK:
+		return "Combo: priority activity PIO lines and logic";
+	case CSR_PSKEY_LC_COMBO_DOT11_CHANNEL_PIO_BASE:
+		return "Combo: 802.11b channel number base PIO line";
+	case CSR_PSKEY_LC_COMBO_DOT11_BLOCK_CHANNELS:
+		return "Combo: channels to block either side of 802.11b";
+	case CSR_PSKEY_LC_MAX_TX_POWER_NO_RSSI:
+		return "Maximum transmit power when peer has no RSSI";
+	case CSR_PSKEY_LC_CONNECTION_RX_WINDOW:
+		return "Receive window size during connections";
+	case CSR_PSKEY_LC_COMBO_DOT11_TX_PROTECTION_MODE:
+		return "Combo: which TX packets shall we protect";
+	case CSR_PSKEY_LC_ENHANCED_POWER_TABLE:
+		return "Radio power table";
+	case CSR_PSKEY_LC_WIDEBAND_RSSI_CONFIG:
+		return "RSSI configuration for use with wideband RSSI";
+	case CSR_PSKEY_LC_COMBO_DOT11_PRIORITY_LEAD:
+		return "Combo: How much notice will we give the Combo Card";
+	case CSR_PSKEY_BT_CLOCK_INIT:
+		return "Initial value of Bluetooth clock";
+	case CSR_PSKEY_TX_MR_MOD_DELAY:
+		return "TX Mod delay";
+	case CSR_PSKEY_RX_MR_SYNC_TIMING:
+		return "RX MR Sync Timing";
+	case CSR_PSKEY_RX_MR_SYNC_CONFIG:
+		return "RX MR Sync Configuration";
+	case CSR_PSKEY_LC_LOST_SYNC_SLOTS:
+		return "Time in ms for lost sync in low power modes";
+	case CSR_PSKEY_RX_MR_SAMP_CONFIG:
+		return "RX MR Sync Configuration";
+	case CSR_PSKEY_AGC_HYST_LEVELS:
+		return "AGC hysteresis levels";
+	case CSR_PSKEY_RX_LEVEL_LOW_SIGNAL:
+		return "ANA_RX_LVL at low signal strengths";
+	case CSR_PSKEY_AGC_IQ_LVL_VALUES:
+		return "ANA_IQ_LVL values for AGC algorithmn";
+	case CSR_PSKEY_MR_FTRIM_OFFSET_12DB:
+		return "ANA_RX_FTRIM offset when using 12 dB IF atten ";
+	case CSR_PSKEY_MR_FTRIM_OFFSET_6DB:
+		return "ANA_RX_FTRIM offset when using 6 dB IF atten ";
+	case CSR_PSKEY_NO_CAL_ON_BOOT:
+		return "Do not calibrate radio on boot";
+	case CSR_PSKEY_RSSI_HI_TARGET:
+		return "RSSI high target";
+	case CSR_PSKEY_PREFERRED_MIN_ATTENUATION:
+		return "Preferred minimum attenuator setting";
+	case CSR_PSKEY_LC_COMBO_DOT11_PRIORITY_OVERRIDE:
+		return "Combo: Treat all packets as high priority";
+	case CSR_PSKEY_LC_MULTISLOT_HOLDOFF:
+		return "Time till single slot packets are used for resync";
+	case CSR_PSKEY_FREE_KEY_PIGEON_HOLE:
+		return "Link key store bitfield";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR0:
+		return "Bluetooth address + link key 0";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR1:
+		return "Bluetooth address + link key 1";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR2:
+		return "Bluetooth address + link key 2";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR3:
+		return "Bluetooth address + link key 3";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR4:
+		return "Bluetooth address + link key 4";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR5:
+		return "Bluetooth address + link key 5";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR6:
+		return "Bluetooth address + link key 6";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR7:
+		return "Bluetooth address + link key 7";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR8:
+		return "Bluetooth address + link key 8";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR9:
+		return "Bluetooth address + link key 9";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR10:
+		return "Bluetooth address + link key 10";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR11:
+		return "Bluetooth address + link key 11";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR12:
+		return "Bluetooth address + link key 12";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR13:
+		return "Bluetooth address + link key 13";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR14:
+		return "Bluetooth address + link key 14";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR15:
+		return "Bluetooth address + link key 15";
+	case CSR_PSKEY_ENC_KEY_LMIN:
+		return "Minimum encryption key length";
+	case CSR_PSKEY_ENC_KEY_LMAX:
+		return "Maximum encryption key length";
+	case CSR_PSKEY_LOCAL_SUPPORTED_FEATURES:
+		return "Local supported features block";
+	case CSR_PSKEY_LM_USE_UNIT_KEY:
+		return "Allow use of unit key for authentication?";
+	case CSR_PSKEY_HCI_NOP_DISABLE:
+		return "Disable the HCI Command_Status event on boot";
+	case CSR_PSKEY_LM_MAX_EVENT_FILTERS:
+		return "Maximum number of event filters";
+	case CSR_PSKEY_LM_USE_ENC_MODE_BROADCAST:
+		return "Allow LM to use enc_mode=2";
+	case CSR_PSKEY_LM_TEST_SEND_ACCEPTED_TWICE:
+		return "LM sends two LMP_accepted messages in test mode";
+	case CSR_PSKEY_LM_MAX_PAGE_HOLD_TIME:
+		return "Maximum time we hold a device around page";
+	case CSR_PSKEY_AFH_ADAPTATION_RESPONSE_TIME:
+		return "LM period for AFH adaption";
+	case CSR_PSKEY_AFH_OPTIONS:
+		return "Options to configure AFH";
+	case CSR_PSKEY_AFH_RSSI_RUN_PERIOD:
+		return "AFH RSSI reading period";
+	case CSR_PSKEY_AFH_REENABLE_CHANNEL_TIME:
+		return "AFH good channel adding time";
+	case CSR_PSKEY_NO_DROP_ON_ACR_MS_FAIL:
+		return "Complete link if acr barge-in role switch refused";
+	case CSR_PSKEY_MAX_PRIVATE_KEYS:
+		return "Max private link keys stored";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR0:
+		return "Bluetooth address + link key 0";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR1:
+		return "Bluetooth address + link key 1";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR2:
+		return "Bluetooth address + link key 2";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR3:
+		return "Bluetooth address + link key 3";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR4:
+		return "Bluetooth address + link key 4";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR5:
+		return "Bluetooth address + link key 5";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR6:
+		return "Bluetooth address + link key 6";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR7:
+		return "Bluetooth address + link key 7";
+	case CSR_PSKEY_LOCAL_SUPPORTED_COMMANDS:
+		return "Local supported commands";
+	case CSR_PSKEY_LM_MAX_ABSENCE_INDEX:
+		return "Maximum absence index allowed";
+	case CSR_PSKEY_DEVICE_NAME:
+		return "Local device's \"user friendly\" name";
+	case CSR_PSKEY_AFH_RSSI_THRESHOLD:
+		return "AFH RSSI threshold";
+	case CSR_PSKEY_LM_CASUAL_SCAN_INTERVAL:
+		return "Scan interval in slots for casual scanning";
+	case CSR_PSKEY_AFH_MIN_MAP_CHANGE:
+		return "The minimum amount to change an AFH map by";
+	case CSR_PSKEY_AFH_RSSI_LP_RUN_PERIOD:
+		return "AFH RSSI reading period when in low power mode";
+	case CSR_PSKEY_HCI_LMP_LOCAL_VERSION:
+		return "The HCI and LMP version reported locally";
+	case CSR_PSKEY_LMP_REMOTE_VERSION:
+		return "The LMP version reported remotely";
+	case CSR_PSKEY_HOLD_ERROR_MESSAGE_NUMBER:
+		return "Maximum number of queued HCI Hardware Error Events";
+	case CSR_PSKEY_DFU_ATTRIBUTES:
+		return "DFU attributes";
+	case CSR_PSKEY_DFU_DETACH_TO:
+		return "DFU detach timeout";
+	case CSR_PSKEY_DFU_TRANSFER_SIZE:
+		return "DFU transfer size";
+	case CSR_PSKEY_DFU_ENABLE:
+		return "DFU enable";
+	case CSR_PSKEY_DFU_LIN_REG_ENABLE:
+		return "Linear Regulator enabled at boot in DFU mode";
+	case CSR_PSKEY_DFUENC_VMAPP_PK_MODULUS_MSB:
+		return "DFU encryption VM application public key MSB";
+	case CSR_PSKEY_DFUENC_VMAPP_PK_MODULUS_LSB:
+		return "DFU encryption VM application public key LSB";
+	case CSR_PSKEY_DFUENC_VMAPP_PK_M_DASH:
+		return "DFU encryption VM application M dash";
+	case CSR_PSKEY_DFUENC_VMAPP_PK_R2N_MSB:
+		return "DFU encryption VM application public key R2N MSB";
+	case CSR_PSKEY_DFUENC_VMAPP_PK_R2N_LSB:
+		return "DFU encryption VM application public key R2N LSB";
+	case CSR_PSKEY_BCSP_LM_PS_BLOCK:
+		return "BCSP link establishment block";
+	case CSR_PSKEY_HOSTIO_FC_PS_BLOCK:
+		return "HCI flow control block";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO0:
+		return "Host transport channel 0 settings (BCSP ACK)";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO1:
+		return "Host transport channel 1 settings (BCSP-LE)";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO2:
+		return "Host transport channel 2 settings (BCCMD)";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO3:
+		return "Host transport channel 3 settings (HQ)";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO4:
+		return "Host transport channel 4 settings (DM)";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO5:
+		return "Host transport channel 5 settings (HCI CMD/EVT)";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO6:
+		return "Host transport channel 6 settings (HCI ACL)";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO7:
+		return "Host transport channel 7 settings (HCI SCO)";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO8:
+		return "Host transport channel 8 settings (L2CAP)";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO9:
+		return "Host transport channel 9 settings (RFCOMM)";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO10:
+		return "Host transport channel 10 settings (SDP)";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO11:
+		return "Host transport channel 11 settings (TEST)";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO12:
+		return "Host transport channel 12 settings (DFU)";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO13:
+		return "Host transport channel 13 settings (VM)";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO14:
+		return "Host transport channel 14 settings";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO15:
+		return "Host transport channel 15 settings";
+	case CSR_PSKEY_HOSTIO_UART_RESET_TIMEOUT:
+		return "UART reset counter timeout";
+	case CSR_PSKEY_HOSTIO_USE_HCI_EXTN:
+		return "Use hci_extn to route non-hci channels";
+	case CSR_PSKEY_HOSTIO_USE_HCI_EXTN_CCFC:
+		return "Use command-complete flow control for hci_extn";
+	case CSR_PSKEY_HOSTIO_HCI_EXTN_PAYLOAD_SIZE:
+		return "Maximum hci_extn payload size";
+	case CSR_PSKEY_BCSP_LM_CNF_CNT_LIMIT:
+		return "BCSP link establishment conf message count";
+	case CSR_PSKEY_HOSTIO_MAP_SCO_PCM:
+		return "Map SCO over PCM";
+	case CSR_PSKEY_HOSTIO_AWKWARD_PCM_SYNC:
+		return "PCM interface synchronisation is difficult";
+	case CSR_PSKEY_HOSTIO_BREAK_POLL_PERIOD:
+		return "Break poll period (microseconds)";
+	case CSR_PSKEY_HOSTIO_MIN_UART_HCI_SCO_SIZE:
+		return "Minimum SCO packet size sent to host over UART HCI";
+	case CSR_PSKEY_HOSTIO_MAP_SCO_CODEC:
+		return "Map SCO over the built-in codec";
+	case CSR_PSKEY_PCM_CVSD_TX_HI_FREQ_BOOST:
+		return "High frequency boost for PCM when transmitting CVSD";
+	case CSR_PSKEY_PCM_CVSD_RX_HI_FREQ_BOOST:
+		return "High frequency boost for PCM when receiving CVSD";
+	case CSR_PSKEY_PCM_CONFIG32:
+		return "PCM interface settings bitfields";
+	case CSR_PSKEY_USE_OLD_BCSP_LE:
+		return "Use the old version of BCSP link establishment";
+	case CSR_PSKEY_PCM_CVSD_USE_NEW_FILTER:
+		return "CVSD uses the new filter if available";
+	case CSR_PSKEY_PCM_FORMAT:
+		return "PCM data format";
+	case CSR_PSKEY_CODEC_OUT_GAIN:
+		return "Audio output gain when using built-in codec";
+	case CSR_PSKEY_CODEC_IN_GAIN:
+		return "Audio input gain when using built-in codec";
+	case CSR_PSKEY_CODEC_PIO:
+		return "PIO to enable when built-in codec is enabled";
+	case CSR_PSKEY_PCM_LOW_JITTER_CONFIG:
+		return "PCM interface settings for low jitter master mode";
+	case CSR_PSKEY_HOSTIO_SCO_PCM_THRESHOLDS:
+		return "Thresholds for SCO PCM buffers";
+	case CSR_PSKEY_HOSTIO_SCO_HCI_THRESHOLDS:
+		return "Thresholds for SCO HCI buffers";
+	case CSR_PSKEY_HOSTIO_MAP_SCO_PCM_SLOT:
+		return "Route SCO data to specified slot in pcm frame";
+	case CSR_PSKEY_UART_BAUDRATE:
+		return "UART Baud rate";
+	case CSR_PSKEY_UART_CONFIG_BCSP:
+		return "UART configuration when using BCSP";
+	case CSR_PSKEY_UART_CONFIG_H4:
+		return "UART configuration when using H4";
+	case CSR_PSKEY_UART_CONFIG_H5:
+		return "UART configuration when using H5";
+	case CSR_PSKEY_UART_CONFIG_USR:
+		return "UART configuration when under VM control";
+	case CSR_PSKEY_UART_TX_CRCS:
+		return "Use CRCs for BCSP or H5";
+	case CSR_PSKEY_UART_ACK_TIMEOUT:
+		return "Acknowledgement timeout for BCSP and H5";
+	case CSR_PSKEY_UART_TX_MAX_ATTEMPTS:
+		return "Max times to send reliable BCSP or H5 message";
+	case CSR_PSKEY_UART_TX_WINDOW_SIZE:
+		return "Transmit window size for BCSP and H5";
+	case CSR_PSKEY_UART_HOST_WAKE:
+		return "UART host wakeup";
+	case CSR_PSKEY_HOSTIO_THROTTLE_TIMEOUT:
+		return "Host interface performance control.";
+	case CSR_PSKEY_PCM_ALWAYS_ENABLE:
+		return "PCM port is always enable when chip is running";
+	case CSR_PSKEY_UART_HOST_WAKE_SIGNAL:
+		return "Signal to use for uart host wakeup protocol";
+	case CSR_PSKEY_UART_CONFIG_H4DS:
+		return "UART configuration when using H4DS";
+	case CSR_PSKEY_H4DS_WAKE_DURATION:
+		return "How long to spend waking the host when using H4DS";
+	case CSR_PSKEY_H4DS_MAXWU:
+		return "Maximum number of H4DS Wake-Up messages to send";
+	case CSR_PSKEY_H4DS_LE_TIMER_PERIOD:
+		return "H4DS Link Establishment Tsync and Tconf period";
+	case CSR_PSKEY_H4DS_TWU_TIMER_PERIOD:
+		return "H4DS Twu timer period";
+	case CSR_PSKEY_H4DS_UART_IDLE_TIMER_PERIOD:
+		return "H4DS Tuart_idle timer period";
+	case CSR_PSKEY_ANA_FTRIM:
+		return "Crystal frequency trim";
+	case CSR_PSKEY_WD_TIMEOUT:
+		return "Watchdog timeout (microseconds)";
+	case CSR_PSKEY_WD_PERIOD:
+		return "Watchdog period (microseconds)";
+	case CSR_PSKEY_HOST_INTERFACE:
+		return "Host interface";
+	case CSR_PSKEY_HQ_HOST_TIMEOUT:
+		return "HQ host command timeout";
+	case CSR_PSKEY_HQ_ACTIVE:
+		return "Enable host query task?";
+	case CSR_PSKEY_BCCMD_SECURITY_ACTIVE:
+		return "Enable configuration security";
+	case CSR_PSKEY_ANA_FREQ:
+		return "Crystal frequency";
+	case CSR_PSKEY_PIO_PROTECT_MASK:
+		return "Access to PIO pins";
+	case CSR_PSKEY_PMALLOC_SIZES:
+		return "pmalloc sizes array";
+	case CSR_PSKEY_UART_BAUD_RATE:
+		return "UART Baud rate (pre 18)";
+	case CSR_PSKEY_UART_CONFIG:
+		return "UART configuration bitfield";
+	case CSR_PSKEY_STUB:
+		return "Stub";
+	case CSR_PSKEY_TXRX_PIO_CONTROL:
+		return "TX and RX PIO control";
+	case CSR_PSKEY_ANA_RX_LEVEL:
+		return "ANA_RX_LVL register initial value";
+	case CSR_PSKEY_ANA_RX_FTRIM:
+		return "ANA_RX_FTRIM register initial value";
+	case CSR_PSKEY_PSBC_DATA_VERSION:
+		return "Persistent store version";
+	case CSR_PSKEY_PCM0_ATTENUATION:
+		return "Volume control on PCM channel 0";
+	case CSR_PSKEY_LO_LVL_MAX:
+		return "Maximum value of LO level control register";
+	case CSR_PSKEY_LO_ADC_AMPL_MIN:
+		return "Minimum value of the LO amplitude measured on the ADC";
+	case CSR_PSKEY_LO_ADC_AMPL_MAX:
+		return "Maximum value of the LO amplitude measured on the ADC";
+	case CSR_PSKEY_IQ_TRIM_CHANNEL:
+		return "IQ calibration channel";
+	case CSR_PSKEY_IQ_TRIM_GAIN:
+		return "IQ calibration gain";
+	case CSR_PSKEY_IQ_TRIM_ENABLE:
+		return "IQ calibration enable";
+	case CSR_PSKEY_TX_OFFSET_HALF_MHZ:
+		return "Transmit offset";
+	case CSR_PSKEY_GBL_MISC_ENABLES:
+		return "Global miscellaneous hardware enables";
+	case CSR_PSKEY_UART_SLEEP_TIMEOUT:
+		return "Time in ms to deep sleep if nothing received";
+	case CSR_PSKEY_DEEP_SLEEP_STATE:
+		return "Deep sleep state usage";
+	case CSR_PSKEY_IQ_ENABLE_PHASE_TRIM:
+		return "IQ phase enable";
+	case CSR_PSKEY_HCI_HANDLE_FREEZE_PERIOD:
+		return "Time for which HCI handle is frozen after link removal";
+	case CSR_PSKEY_MAX_FROZEN_HCI_HANDLES:
+		return "Maximum number of frozen HCI handles";
+	case CSR_PSKEY_PAGETABLE_DESTRUCTION_DELAY:
+		return "Delay from freezing buf handle to deleting page table";
+	case CSR_PSKEY_IQ_TRIM_PIO_SETTINGS:
+		return "IQ PIO settings";
+	case CSR_PSKEY_USE_EXTERNAL_CLOCK:
+		return "Device uses an external clock";
+	case CSR_PSKEY_DEEP_SLEEP_WAKE_CTS:
+		return "Exit deep sleep on CTS line activity";
+	case CSR_PSKEY_FC_HC2H_FLUSH_DELAY:
+		return "Delay from disconnect to flushing HC->H FC tokens";
+	case CSR_PSKEY_RX_HIGHSIDE:
+		return "Disable the HIGHSIDE bit in ANA_CONFIG";
+	case CSR_PSKEY_TX_PRE_LVL:
+		return "TX pre-amplifier level";
+	case CSR_PSKEY_RX_SINGLE_ENDED:
+		return "RX single ended";
+	case CSR_PSKEY_TX_FILTER_CONFIG:
+		return "TX filter configuration";
+	case CSR_PSKEY_CLOCK_REQUEST_ENABLE:
+		return "External clock request enable";
+	case CSR_PSKEY_RX_MIN_ATTEN:
+		return "Minimum attenuation allowed for receiver";
+	case CSR_PSKEY_XTAL_TARGET_AMPLITUDE:
+		return "Crystal target amplitude";
+	case CSR_PSKEY_PCM_MIN_CPU_CLOCK:
+		return "Minimum CPU clock speed with PCM port running";
+	case CSR_PSKEY_HOST_INTERFACE_PIO_USB:
+		return "USB host interface selection PIO line";
+	case CSR_PSKEY_CPU_IDLE_MODE:
+		return "CPU idle mode when radio is active";
+	case CSR_PSKEY_DEEP_SLEEP_CLEAR_RTS:
+		return "Deep sleep clears the UART RTS line";
+	case CSR_PSKEY_RF_RESONANCE_TRIM:
+		return "Frequency trim for IQ and LNA resonant circuits";
+	case CSR_PSKEY_DEEP_SLEEP_PIO_WAKE:
+		return "PIO line to wake the chip from deep sleep";
+	case CSR_PSKEY_DRAIN_BORE_TIMERS:
+		return "Energy consumption measurement settings";
+	case CSR_PSKEY_DRAIN_TX_POWER_BASE:
+		return "Energy consumption measurement settings";
+	case CSR_PSKEY_MODULE_ID:
+		return "Module serial number";
+	case CSR_PSKEY_MODULE_DESIGN:
+		return "Module design ID";
+	case CSR_PSKEY_MODULE_SECURITY_CODE:
+		return "Module security code";
+	case CSR_PSKEY_VM_DISABLE:
+		return "VM disable";
+	case CSR_PSKEY_MOD_MANUF0:
+		return "Module manufactuer data 0";
+	case CSR_PSKEY_MOD_MANUF1:
+		return "Module manufactuer data 1";
+	case CSR_PSKEY_MOD_MANUF2:
+		return "Module manufactuer data 2";
+	case CSR_PSKEY_MOD_MANUF3:
+		return "Module manufactuer data 3";
+	case CSR_PSKEY_MOD_MANUF4:
+		return "Module manufactuer data 4";
+	case CSR_PSKEY_MOD_MANUF5:
+		return "Module manufactuer data 5";
+	case CSR_PSKEY_MOD_MANUF6:
+		return "Module manufactuer data 6";
+	case CSR_PSKEY_MOD_MANUF7:
+		return "Module manufactuer data 7";
+	case CSR_PSKEY_MOD_MANUF8:
+		return "Module manufactuer data 8";
+	case CSR_PSKEY_MOD_MANUF9:
+		return "Module manufactuer data 9";
+	case CSR_PSKEY_DUT_VM_DISABLE:
+		return "VM disable when entering radiotest modes";
+	case CSR_PSKEY_USR0:
+		return "User configuration data 0";
+	case CSR_PSKEY_USR1:
+		return "User configuration data 1";
+	case CSR_PSKEY_USR2:
+		return "User configuration data 2";
+	case CSR_PSKEY_USR3:
+		return "User configuration data 3";
+	case CSR_PSKEY_USR4:
+		return "User configuration data 4";
+	case CSR_PSKEY_USR5:
+		return "User configuration data 5";
+	case CSR_PSKEY_USR6:
+		return "User configuration data 6";
+	case CSR_PSKEY_USR7:
+		return "User configuration data 7";
+	case CSR_PSKEY_USR8:
+		return "User configuration data 8";
+	case CSR_PSKEY_USR9:
+		return "User configuration data 9";
+	case CSR_PSKEY_USR10:
+		return "User configuration data 10";
+	case CSR_PSKEY_USR11:
+		return "User configuration data 11";
+	case CSR_PSKEY_USR12:
+		return "User configuration data 12";
+	case CSR_PSKEY_USR13:
+		return "User configuration data 13";
+	case CSR_PSKEY_USR14:
+		return "User configuration data 14";
+	case CSR_PSKEY_USR15:
+		return "User configuration data 15";
+	case CSR_PSKEY_USR16:
+		return "User configuration data 16";
+	case CSR_PSKEY_USR17:
+		return "User configuration data 17";
+	case CSR_PSKEY_USR18:
+		return "User configuration data 18";
+	case CSR_PSKEY_USR19:
+		return "User configuration data 19";
+	case CSR_PSKEY_USR20:
+		return "User configuration data 20";
+	case CSR_PSKEY_USR21:
+		return "User configuration data 21";
+	case CSR_PSKEY_USR22:
+		return "User configuration data 22";
+	case CSR_PSKEY_USR23:
+		return "User configuration data 23";
+	case CSR_PSKEY_USR24:
+		return "User configuration data 24";
+	case CSR_PSKEY_USR25:
+		return "User configuration data 25";
+	case CSR_PSKEY_USR26:
+		return "User configuration data 26";
+	case CSR_PSKEY_USR27:
+		return "User configuration data 27";
+	case CSR_PSKEY_USR28:
+		return "User configuration data 28";
+	case CSR_PSKEY_USR29:
+		return "User configuration data 29";
+	case CSR_PSKEY_USR30:
+		return "User configuration data 30";
+	case CSR_PSKEY_USR31:
+		return "User configuration data 31";
+	case CSR_PSKEY_USR32:
+		return "User configuration data 32";
+	case CSR_PSKEY_USR33:
+		return "User configuration data 33";
+	case CSR_PSKEY_USR34:
+		return "User configuration data 34";
+	case CSR_PSKEY_USR35:
+		return "User configuration data 35";
+	case CSR_PSKEY_USR36:
+		return "User configuration data 36";
+	case CSR_PSKEY_USR37:
+		return "User configuration data 37";
+	case CSR_PSKEY_USR38:
+		return "User configuration data 38";
+	case CSR_PSKEY_USR39:
+		return "User configuration data 39";
+	case CSR_PSKEY_USR40:
+		return "User configuration data 40";
+	case CSR_PSKEY_USR41:
+		return "User configuration data 41";
+	case CSR_PSKEY_USR42:
+		return "User configuration data 42";
+	case CSR_PSKEY_USR43:
+		return "User configuration data 43";
+	case CSR_PSKEY_USR44:
+		return "User configuration data 44";
+	case CSR_PSKEY_USR45:
+		return "User configuration data 45";
+	case CSR_PSKEY_USR46:
+		return "User configuration data 46";
+	case CSR_PSKEY_USR47:
+		return "User configuration data 47";
+	case CSR_PSKEY_USR48:
+		return "User configuration data 48";
+	case CSR_PSKEY_USR49:
+		return "User configuration data 49";
+	case CSR_PSKEY_USB_VERSION:
+		return "USB specification version number";
+	case CSR_PSKEY_USB_DEVICE_CLASS_CODES:
+		return "USB device class codes";
+	case CSR_PSKEY_USB_VENDOR_ID:
+		return "USB vendor identifier";
+	case CSR_PSKEY_USB_PRODUCT_ID:
+		return "USB product identifier";
+	case CSR_PSKEY_USB_MANUF_STRING:
+		return "USB manufacturer string";
+	case CSR_PSKEY_USB_PRODUCT_STRING:
+		return "USB product string";
+	case CSR_PSKEY_USB_SERIAL_NUMBER_STRING:
+		return "USB serial number string";
+	case CSR_PSKEY_USB_CONFIG_STRING:
+		return "USB configuration string";
+	case CSR_PSKEY_USB_ATTRIBUTES:
+		return "USB attributes bitmap";
+	case CSR_PSKEY_USB_MAX_POWER:
+		return "USB device maximum power consumption";
+	case CSR_PSKEY_USB_BT_IF_CLASS_CODES:
+		return "USB Bluetooth interface class codes";
+	case CSR_PSKEY_USB_LANGID:
+		return "USB language strings supported";
+	case CSR_PSKEY_USB_DFU_CLASS_CODES:
+		return "USB DFU class codes block";
+	case CSR_PSKEY_USB_DFU_PRODUCT_ID:
+		return "USB DFU product ID";
+	case CSR_PSKEY_USB_PIO_DETACH:
+		return "USB detach/attach PIO line";
+	case CSR_PSKEY_USB_PIO_WAKEUP:
+		return "USB wakeup PIO line";
+	case CSR_PSKEY_USB_PIO_PULLUP:
+		return "USB D+ pullup PIO line";
+	case CSR_PSKEY_USB_PIO_VBUS:
+		return "USB VBus detection PIO Line";
+	case CSR_PSKEY_USB_PIO_WAKE_TIMEOUT:
+		return "Timeout for assertion of USB PIO wake signal";
+	case CSR_PSKEY_USB_PIO_RESUME:
+		return "PIO signal used in place of bus resume";
+	case CSR_PSKEY_USB_BT_SCO_IF_CLASS_CODES:
+		return "USB Bluetooth SCO interface class codes";
+	case CSR_PSKEY_USB_SUSPEND_PIO_LEVEL:
+		return "USB PIO levels to set when suspended";
+	case CSR_PSKEY_USB_SUSPEND_PIO_DIR:
+		return "USB PIO I/O directions to set when suspended";
+	case CSR_PSKEY_USB_SUSPEND_PIO_MASK:
+		return "USB PIO lines to be set forcibly in suspend";
+	case CSR_PSKEY_USB_ENDPOINT_0_MAX_PACKET_SIZE:
+		return "The maxmimum packet size for USB endpoint 0";
+	case CSR_PSKEY_USB_CONFIG:
+		return "USB config params for new chips (>bc2)";
+	case CSR_PSKEY_RADIOTEST_ATTEN_INIT:
+		return "Radio test initial attenuator";
+	case CSR_PSKEY_RADIOTEST_FIRST_TRIM_TIME:
+		return "IQ first calibration period in test";
+	case CSR_PSKEY_RADIOTEST_SUBSEQUENT_TRIM_TIME:
+		return "IQ subsequent calibration period in test";
+	case CSR_PSKEY_RADIOTEST_LO_LVL_TRIM_ENABLE:
+		return "LO_LVL calibration enable";
+	case CSR_PSKEY_RADIOTEST_DISABLE_MODULATION:
+		return "Disable modulation during radiotest transmissions";
+	case CSR_PSKEY_RFCOMM_FCON_THRESHOLD:
+		return "RFCOMM aggregate flow control on threshold";
+	case CSR_PSKEY_RFCOMM_FCOFF_THRESHOLD:
+		return "RFCOMM aggregate flow control off threshold";
+	case CSR_PSKEY_IPV6_STATIC_ADDR:
+		return "Static IPv6 address";
+	case CSR_PSKEY_IPV4_STATIC_ADDR:
+		return "Static IPv4 address";
+	case CSR_PSKEY_IPV6_STATIC_PREFIX_LEN:
+		return "Static IPv6 prefix length";
+	case CSR_PSKEY_IPV6_STATIC_ROUTER_ADDR:
+		return "Static IPv6 router address";
+	case CSR_PSKEY_IPV4_STATIC_SUBNET_MASK:
+		return "Static IPv4 subnet mask";
+	case CSR_PSKEY_IPV4_STATIC_ROUTER_ADDR:
+		return "Static IPv4 router address";
+	case CSR_PSKEY_MDNS_NAME:
+		return "Multicast DNS name";
+	case CSR_PSKEY_FIXED_PIN:
+		return "Fixed PIN";
+	case CSR_PSKEY_MDNS_PORT:
+		return "Multicast DNS port";
+	case CSR_PSKEY_MDNS_TTL:
+		return "Multicast DNS TTL";
+	case CSR_PSKEY_MDNS_IPV4_ADDR:
+		return "Multicast DNS IPv4 address";
+	case CSR_PSKEY_ARP_CACHE_TIMEOUT:
+		return "ARP cache timeout";
+	case CSR_PSKEY_HFP_POWER_TABLE:
+		return "HFP power table";
+	case CSR_PSKEY_DRAIN_BORE_TIMER_COUNTERS:
+		return "Energy consumption estimation timer counters";
+	case CSR_PSKEY_DRAIN_BORE_COUNTERS:
+		return "Energy consumption estimation counters";
+	case CSR_PSKEY_LOOP_FILTER_TRIM:
+		return "Trim value to optimise loop filter";
+	case CSR_PSKEY_DRAIN_BORE_CURRENT_PEAK:
+		return "Energy consumption estimation current peak";
+	case CSR_PSKEY_VM_E2_CACHE_LIMIT:
+		return "Maximum RAM for caching EEPROM VM application";
+	case CSR_PSKEY_FORCE_16MHZ_REF_PIO:
+		return "PIO line to force 16 MHz reference to be assumed";
+	case CSR_PSKEY_CDMA_LO_REF_LIMITS:
+		return "Local oscillator frequency reference limits for CDMA";
+	case CSR_PSKEY_CDMA_LO_ERROR_LIMITS:
+		return "Local oscillator frequency error limits for CDMA";
+	case CSR_PSKEY_CLOCK_STARTUP_DELAY:
+		return "Clock startup delay in milliseconds";
+	case CSR_PSKEY_DEEP_SLEEP_CORRECTION_FACTOR:
+		return "Deep sleep clock correction factor";
+	case CSR_PSKEY_TEMPERATURE_CALIBRATION:
+		return "Temperature in deg C for a given internal setting";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_INTERNAL_PA:
+		return "Temperature for given internal PA adjustment";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_PRE_LVL:
+		return "Temperature for a given TX_PRE_LVL adjustment";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB:
+		return "Temperature for a given TX_BB adjustment";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_ANA_FTRIM:
+		return "Temperature for given crystal trim adjustment";
+	case CSR_PSKEY_TEST_DELTA_OFFSET:
+		return "Frequency offset applied to synthesiser in test mode";
+	case CSR_PSKEY_RX_DYNAMIC_LVL_OFFSET:
+		return "Receiver dynamic level offset depending on channel";
+	case CSR_PSKEY_TEST_FORCE_OFFSET:
+		return "Force use of exact value in PSKEY_TEST_DELTA_OFFSET";
+	case CSR_PSKEY_RF_TRAP_BAD_DIVISION_RATIOS:
+		return "Trap bad division ratios in radio frequency tables";
+	case CSR_PSKEY_RADIOTEST_CDMA_LO_REF_LIMITS:
+		return "LO frequency reference limits for CDMA in radiotest";
+	case CSR_PSKEY_INITIAL_BOOTMODE:
+		return "Initial device bootmode";
+	case CSR_PSKEY_ONCHIP_HCI_CLIENT:
+		return "HCI traffic routed internally";
+	case CSR_PSKEY_RX_ATTEN_BACKOFF:
+		return "Receiver attenuation back-off";
+	case CSR_PSKEY_RX_ATTEN_UPDATE_RATE:
+		return "Receiver attenuation update rate";
+	case CSR_PSKEY_SYNTH_TXRX_THRESHOLDS:
+		return "Local oscillator tuning voltage limits for tx and rx";
+	case CSR_PSKEY_MIN_WAIT_STATES:
+		return "Flash wait state indicator";
+	case CSR_PSKEY_RSSI_CORRECTION:
+		return "RSSI correction factor.";
+	case CSR_PSKEY_SCHED_THROTTLE_TIMEOUT:
+		return "Scheduler performance control.";
+	case CSR_PSKEY_DEEP_SLEEP_USE_EXTERNAL_CLOCK:
+		return "Deep sleep uses external 32 kHz clock source";
+	case CSR_PSKEY_TRIM_RADIO_FILTERS:
+		return "Trim rx and tx radio filters if true.";
+	case CSR_PSKEY_TRANSMIT_OFFSET:
+		return "Transmit offset in units of 62.5 kHz";
+	case CSR_PSKEY_USB_VM_CONTROL:
+		return "VM application will supply USB descriptors";
+	case CSR_PSKEY_MR_ANA_RX_FTRIM:
+		return "Medium rate value for the ANA_RX_FTRIM register";
+	case CSR_PSKEY_I2C_CONFIG:
+		return "I2C configuration";
+	case CSR_PSKEY_IQ_LVL_RX:
+		return "IQ demand level for reception";
+	case CSR_PSKEY_MR_TX_FILTER_CONFIG:
+		return "TX filter configuration used for enhanced data rate";
+	case CSR_PSKEY_MR_TX_CONFIG2:
+		return "TX filter configuration used for enhanced data rate";
+	case CSR_PSKEY_USB_DONT_RESET_BOOTMODE_ON_HOST_RESET:
+		return "Don't reset bootmode if USB host resets";
+	case CSR_PSKEY_LC_USE_THROTTLING:
+		return "Adjust packet selection on packet error rate";
+	case CSR_PSKEY_CHARGER_TRIM:
+		return "Trim value for the current charger";
+	case CSR_PSKEY_CLOCK_REQUEST_FEATURES:
+		return "Clock request is tristated if enabled";
+	case CSR_PSKEY_TRANSMIT_OFFSET_CLASS1:
+		return "Transmit offset / 62.5 kHz for class 1 radios";
+	case CSR_PSKEY_TX_AVOID_PA_CLASS1_PIO:
+		return "PIO line asserted in class1 operation to avoid PA";
+	case CSR_PSKEY_MR_PIO_CONFIG:
+		return "PIO line asserted in class1 operation to avoid PA";
+	case CSR_PSKEY_UART_CONFIG2:
+		return "The UART Sampling point";
+	case CSR_PSKEY_CLASS1_IQ_LVL:
+		return "IQ demand level for class 1 power level";
+	case CSR_PSKEY_CLASS1_TX_CONFIG2:
+		return "TX filter configuration used for class 1 tx power";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_INTERNAL_PA_CLASS1:
+		return "Temperature for given internal PA adjustment";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_EXTERNAL_PA_CLASS1:
+		return "Temperature for given internal PA adjustment";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_PRE_LVL_MR:
+		return "Temperature adjustment for TX_PRE_LVL in EDR";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB_MR_HEADER:
+		return "Temperature for a given TX_BB in EDR header";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB_MR_PAYLOAD:
+		return "Temperature for a given TX_BB in EDR payload";
+	case CSR_PSKEY_RX_MR_EQ_TAPS:
+		return "Adjust receiver configuration for EDR";
+	case CSR_PSKEY_TX_PRE_LVL_CLASS1:
+		return "TX pre-amplifier level in class 1 operation";
+	case CSR_PSKEY_ANALOGUE_ATTENUATOR:
+		return "TX analogue attenuator setting";
+	case CSR_PSKEY_MR_RX_FILTER_TRIM:
+		return "Trim for receiver used in EDR.";
+	case CSR_PSKEY_MR_RX_FILTER_RESPONSE:
+		return "Filter response for receiver used in EDR.";
+	case CSR_PSKEY_PIO_WAKEUP_STATE:
+		return "PIO deep sleep wake up state ";
+	case CSR_PSKEY_MR_TX_IF_ATTEN_OFF_TEMP:
+		return "TX IF atten off temperature when using EDR.";
+	case CSR_PSKEY_LO_DIV_LATCH_BYPASS:
+		return "Bypass latch for LO dividers";
+	case CSR_PSKEY_LO_VCO_STANDBY:
+		return "Use standby mode for the LO VCO";
+	case CSR_PSKEY_SLOW_CLOCK_FILTER_SHIFT:
+		return "Slow clock sampling filter constant";
+	case CSR_PSKEY_SLOW_CLOCK_FILTER_DIVIDER:
+		return "Slow clock filter fractional threshold";
+	case CSR_PSKEY_USB_ATTRIBUTES_POWER:
+		return "USB self powered";
+	case CSR_PSKEY_USB_ATTRIBUTES_WAKEUP:
+		return "USB responds to wake-up";
+	case CSR_PSKEY_DFU_ATTRIBUTES_MANIFESTATION_TOLERANT:
+		return "DFU manifestation tolerant";
+	case CSR_PSKEY_DFU_ATTRIBUTES_CAN_UPLOAD:
+		return "DFU can upload";
+	case CSR_PSKEY_DFU_ATTRIBUTES_CAN_DOWNLOAD:
+		return "DFU can download";
+	case CSR_PSKEY_UART_CONFIG_STOP_BITS:
+		return "UART: stop bits";
+	case CSR_PSKEY_UART_CONFIG_PARITY_BIT:
+		return "UART: parity bit";
+	case CSR_PSKEY_UART_CONFIG_FLOW_CTRL_EN:
+		return "UART: hardware flow control";
+	case CSR_PSKEY_UART_CONFIG_RTS_AUTO_EN:
+		return "UART: RTS auto-enabled";
+	case CSR_PSKEY_UART_CONFIG_RTS:
+		return "UART: RTS asserted";
+	case CSR_PSKEY_UART_CONFIG_TX_ZERO_EN:
+		return "UART: TX zero enable";
+	case CSR_PSKEY_UART_CONFIG_NON_BCSP_EN:
+		return "UART: enable BCSP-specific hardware";
+	case CSR_PSKEY_UART_CONFIG_RX_RATE_DELAY:
+		return "UART: RX rate delay";
+	case CSR_PSKEY_UART_SEQ_TIMEOUT:
+		return "UART: BCSP ack timeout";
+	case CSR_PSKEY_UART_SEQ_RETRIES:
+		return "UART: retry limit in sequencing layer";
+	case CSR_PSKEY_UART_SEQ_WINSIZE:
+		return "UART: BCSP transmit window size";
+	case CSR_PSKEY_UART_USE_CRC_ON_TX:
+		return "UART: use BCSP CRCs";
+	case CSR_PSKEY_UART_HOST_INITIAL_STATE:
+		return "UART: initial host state";
+	case CSR_PSKEY_UART_HOST_ATTENTION_SPAN:
+		return "UART: host attention span";
+	case CSR_PSKEY_UART_HOST_WAKEUP_TIME:
+		return "UART: host wakeup time";
+	case CSR_PSKEY_UART_HOST_WAKEUP_WAIT:
+		return "UART: host wakeup wait";
+	case CSR_PSKEY_BCSP_LM_MODE:
+		return "BCSP link establishment mode";
+	case CSR_PSKEY_BCSP_LM_SYNC_RETRIES:
+		return "BCSP link establishment sync retries";
+	case CSR_PSKEY_BCSP_LM_TSHY:
+		return "BCSP link establishment Tshy";
+	case CSR_PSKEY_UART_DFU_CONFIG_STOP_BITS:
+		return "DFU mode UART: stop bits";
+	case CSR_PSKEY_UART_DFU_CONFIG_PARITY_BIT:
+		return "DFU mode UART: parity bit";
+	case CSR_PSKEY_UART_DFU_CONFIG_FLOW_CTRL_EN:
+		return "DFU mode UART: hardware flow control";
+	case CSR_PSKEY_UART_DFU_CONFIG_RTS_AUTO_EN:
+		return "DFU mode UART: RTS auto-enabled";
+	case CSR_PSKEY_UART_DFU_CONFIG_RTS:
+		return "DFU mode UART: RTS asserted";
+	case CSR_PSKEY_UART_DFU_CONFIG_TX_ZERO_EN:
+		return "DFU mode UART: TX zero enable";
+	case CSR_PSKEY_UART_DFU_CONFIG_NON_BCSP_EN:
+		return "DFU mode UART: enable BCSP-specific hardware";
+	case CSR_PSKEY_UART_DFU_CONFIG_RX_RATE_DELAY:
+		return "DFU mode UART: RX rate delay";
+	case CSR_PSKEY_AMUX_AIO0:
+		return "Multiplexer for AIO 0";
+	case CSR_PSKEY_AMUX_AIO1:
+		return "Multiplexer for AIO 1";
+	case CSR_PSKEY_AMUX_AIO2:
+		return "Multiplexer for AIO 2";
+	case CSR_PSKEY_AMUX_AIO3:
+		return "Multiplexer for AIO 3";
+	case CSR_PSKEY_LOCAL_NAME_SIMPLIFIED:
+		return "Local Name (simplified)";
+	case CSR_PSKEY_EXTENDED_STUB:
+		return "Extended stub";
+	default:
+		return "Unknown";
+	}
+}
+
+char *csr_pskeytoval(uint16_t pskey)
+{
+	switch (pskey) {
+	case CSR_PSKEY_BDADDR:
+		return "BDADDR";
+	case CSR_PSKEY_COUNTRYCODE:
+		return "COUNTRYCODE";
+	case CSR_PSKEY_CLASSOFDEVICE:
+		return "CLASSOFDEVICE";
+	case CSR_PSKEY_DEVICE_DRIFT:
+		return "DEVICE_DRIFT";
+	case CSR_PSKEY_DEVICE_JITTER:
+		return "DEVICE_JITTER";
+	case CSR_PSKEY_MAX_ACLS:
+		return "MAX_ACLS";
+	case CSR_PSKEY_MAX_SCOS:
+		return "MAX_SCOS";
+	case CSR_PSKEY_MAX_REMOTE_MASTERS:
+		return "MAX_REMOTE_MASTERS";
+	case CSR_PSKEY_ENABLE_MASTERY_WITH_SLAVERY:
+		return "ENABLE_MASTERY_WITH_SLAVERY";
+	case CSR_PSKEY_H_HC_FC_MAX_ACL_PKT_LEN:
+		return "H_HC_FC_MAX_ACL_PKT_LEN";
+	case CSR_PSKEY_H_HC_FC_MAX_SCO_PKT_LEN:
+		return "H_HC_FC_MAX_SCO_PKT_LEN";
+	case CSR_PSKEY_H_HC_FC_MAX_ACL_PKTS:
+		return "H_HC_FC_MAX_ACL_PKTS";
+	case CSR_PSKEY_H_HC_FC_MAX_SCO_PKTS:
+		return "H_HC_FC_MAX_SCO_PKTS";
+	case CSR_PSKEY_LC_FC_BUFFER_LOW_WATER_MARK:
+		return "LC_FC_BUFFER_LOW_WATER_MARK";
+	case CSR_PSKEY_LC_MAX_TX_POWER:
+		return "LC_MAX_TX_POWER";
+	case CSR_PSKEY_TX_GAIN_RAMP:
+		return "TX_GAIN_RAMP";
+	case CSR_PSKEY_LC_POWER_TABLE:
+		return "LC_POWER_TABLE";
+	case CSR_PSKEY_LC_PEER_POWER_PERIOD:
+		return "LC_PEER_POWER_PERIOD";
+	case CSR_PSKEY_LC_FC_POOLS_LOW_WATER_MARK:
+		return "LC_FC_POOLS_LOW_WATER_MARK";
+	case CSR_PSKEY_LC_DEFAULT_TX_POWER:
+		return "LC_DEFAULT_TX_POWER";
+	case CSR_PSKEY_LC_RSSI_GOLDEN_RANGE:
+		return "LC_RSSI_GOLDEN_RANGE";
+	case CSR_PSKEY_LC_COMBO_DISABLE_PIO_MASK:
+		return "LC_COMBO_DISABLE_PIO_MASK";
+	case CSR_PSKEY_LC_COMBO_PRIORITY_PIO_MASK:
+		return "LC_COMBO_PRIORITY_PIO_MASK";
+	case CSR_PSKEY_LC_COMBO_DOT11_CHANNEL_PIO_BASE:
+		return "LC_COMBO_DOT11_CHANNEL_PIO_BASE";
+	case CSR_PSKEY_LC_COMBO_DOT11_BLOCK_CHANNELS:
+		return "LC_COMBO_DOT11_BLOCK_CHANNELS";
+	case CSR_PSKEY_LC_MAX_TX_POWER_NO_RSSI:
+		return "LC_MAX_TX_POWER_NO_RSSI";
+	case CSR_PSKEY_LC_CONNECTION_RX_WINDOW:
+		return "LC_CONNECTION_RX_WINDOW";
+	case CSR_PSKEY_LC_COMBO_DOT11_TX_PROTECTION_MODE:
+		return "LC_COMBO_DOT11_TX_PROTECTION_MODE";
+	case CSR_PSKEY_LC_ENHANCED_POWER_TABLE:
+		return "LC_ENHANCED_POWER_TABLE";
+	case CSR_PSKEY_LC_WIDEBAND_RSSI_CONFIG:
+		return "LC_WIDEBAND_RSSI_CONFIG";
+	case CSR_PSKEY_LC_COMBO_DOT11_PRIORITY_LEAD:
+		return "LC_COMBO_DOT11_PRIORITY_LEAD";
+	case CSR_PSKEY_BT_CLOCK_INIT:
+		return "BT_CLOCK_INIT";
+	case CSR_PSKEY_TX_MR_MOD_DELAY:
+		return "TX_MR_MOD_DELAY";
+	case CSR_PSKEY_RX_MR_SYNC_TIMING:
+		return "RX_MR_SYNC_TIMING";
+	case CSR_PSKEY_RX_MR_SYNC_CONFIG:
+		return "RX_MR_SYNC_CONFIG";
+	case CSR_PSKEY_LC_LOST_SYNC_SLOTS:
+		return "LC_LOST_SYNC_SLOTS";
+	case CSR_PSKEY_RX_MR_SAMP_CONFIG:
+		return "RX_MR_SAMP_CONFIG";
+	case CSR_PSKEY_AGC_HYST_LEVELS:
+		return "AGC_HYST_LEVELS";
+	case CSR_PSKEY_RX_LEVEL_LOW_SIGNAL:
+		return "RX_LEVEL_LOW_SIGNAL";
+	case CSR_PSKEY_AGC_IQ_LVL_VALUES:
+		return "AGC_IQ_LVL_VALUES";
+	case CSR_PSKEY_MR_FTRIM_OFFSET_12DB:
+		return "MR_FTRIM_OFFSET_12DB";
+	case CSR_PSKEY_MR_FTRIM_OFFSET_6DB:
+		return "MR_FTRIM_OFFSET_6DB";
+	case CSR_PSKEY_NO_CAL_ON_BOOT:
+		return "NO_CAL_ON_BOOT";
+	case CSR_PSKEY_RSSI_HI_TARGET:
+		return "RSSI_HI_TARGET";
+	case CSR_PSKEY_PREFERRED_MIN_ATTENUATION:
+		return "PREFERRED_MIN_ATTENUATION";
+	case CSR_PSKEY_LC_COMBO_DOT11_PRIORITY_OVERRIDE:
+		return "LC_COMBO_DOT11_PRIORITY_OVERRIDE";
+	case CSR_PSKEY_LC_MULTISLOT_HOLDOFF:
+		return "LC_MULTISLOT_HOLDOFF";
+	case CSR_PSKEY_FREE_KEY_PIGEON_HOLE:
+		return "FREE_KEY_PIGEON_HOLE";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR0:
+		return "LINK_KEY_BD_ADDR0";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR1:
+		return "LINK_KEY_BD_ADDR1";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR2:
+		return "LINK_KEY_BD_ADDR2";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR3:
+		return "LINK_KEY_BD_ADDR3";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR4:
+		return "LINK_KEY_BD_ADDR4";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR5:
+		return "LINK_KEY_BD_ADDR5";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR6:
+		return "LINK_KEY_BD_ADDR6";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR7:
+		return "LINK_KEY_BD_ADDR7";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR8:
+		return "LINK_KEY_BD_ADDR8";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR9:
+		return "LINK_KEY_BD_ADDR9";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR10:
+		return "LINK_KEY_BD_ADDR10";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR11:
+		return "LINK_KEY_BD_ADDR11";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR12:
+		return "LINK_KEY_BD_ADDR12";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR13:
+		return "LINK_KEY_BD_ADDR13";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR14:
+		return "LINK_KEY_BD_ADDR14";
+	case CSR_PSKEY_LINK_KEY_BD_ADDR15:
+		return "LINK_KEY_BD_ADDR15";
+	case CSR_PSKEY_ENC_KEY_LMIN:
+		return "ENC_KEY_LMIN";
+	case CSR_PSKEY_ENC_KEY_LMAX:
+		return "ENC_KEY_LMAX";
+	case CSR_PSKEY_LOCAL_SUPPORTED_FEATURES:
+		return "LOCAL_SUPPORTED_FEATURES";
+	case CSR_PSKEY_LM_USE_UNIT_KEY:
+		return "LM_USE_UNIT_KEY";
+	case CSR_PSKEY_HCI_NOP_DISABLE:
+		return "HCI_NOP_DISABLE";
+	case CSR_PSKEY_LM_MAX_EVENT_FILTERS:
+		return "LM_MAX_EVENT_FILTERS";
+	case CSR_PSKEY_LM_USE_ENC_MODE_BROADCAST:
+		return "LM_USE_ENC_MODE_BROADCAST";
+	case CSR_PSKEY_LM_TEST_SEND_ACCEPTED_TWICE:
+		return "LM_TEST_SEND_ACCEPTED_TWICE";
+	case CSR_PSKEY_LM_MAX_PAGE_HOLD_TIME:
+		return "LM_MAX_PAGE_HOLD_TIME";
+	case CSR_PSKEY_AFH_ADAPTATION_RESPONSE_TIME:
+		return "AFH_ADAPTATION_RESPONSE_TIME";
+	case CSR_PSKEY_AFH_OPTIONS:
+		return "AFH_OPTIONS";
+	case CSR_PSKEY_AFH_RSSI_RUN_PERIOD:
+		return "AFH_RSSI_RUN_PERIOD";
+	case CSR_PSKEY_AFH_REENABLE_CHANNEL_TIME:
+		return "AFH_REENABLE_CHANNEL_TIME";
+	case CSR_PSKEY_NO_DROP_ON_ACR_MS_FAIL:
+		return "NO_DROP_ON_ACR_MS_FAIL";
+	case CSR_PSKEY_MAX_PRIVATE_KEYS:
+		return "MAX_PRIVATE_KEYS";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR0:
+		return "PRIVATE_LINK_KEY_BD_ADDR0";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR1:
+		return "PRIVATE_LINK_KEY_BD_ADDR1";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR2:
+		return "PRIVATE_LINK_KEY_BD_ADDR2";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR3:
+		return "PRIVATE_LINK_KEY_BD_ADDR3";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR4:
+		return "PRIVATE_LINK_KEY_BD_ADDR4";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR5:
+		return "PRIVATE_LINK_KEY_BD_ADDR5";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR6:
+		return "PRIVATE_LINK_KEY_BD_ADDR6";
+	case CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR7:
+		return "PRIVATE_LINK_KEY_BD_ADDR7";
+	case CSR_PSKEY_LOCAL_SUPPORTED_COMMANDS:
+		return "LOCAL_SUPPORTED_COMMANDS";
+	case CSR_PSKEY_LM_MAX_ABSENCE_INDEX:
+		return "LM_MAX_ABSENCE_INDEX";
+	case CSR_PSKEY_DEVICE_NAME:
+		return "DEVICE_NAME";
+	case CSR_PSKEY_AFH_RSSI_THRESHOLD:
+		return "AFH_RSSI_THRESHOLD";
+	case CSR_PSKEY_LM_CASUAL_SCAN_INTERVAL:
+		return "LM_CASUAL_SCAN_INTERVAL";
+	case CSR_PSKEY_AFH_MIN_MAP_CHANGE:
+		return "AFH_MIN_MAP_CHANGE";
+	case CSR_PSKEY_AFH_RSSI_LP_RUN_PERIOD:
+		return "AFH_RSSI_LP_RUN_PERIOD";
+	case CSR_PSKEY_HCI_LMP_LOCAL_VERSION:
+		return "HCI_LMP_LOCAL_VERSION";
+	case CSR_PSKEY_LMP_REMOTE_VERSION:
+		return "LMP_REMOTE_VERSION";
+	case CSR_PSKEY_HOLD_ERROR_MESSAGE_NUMBER:
+		return "HOLD_ERROR_MESSAGE_NUMBER";
+	case CSR_PSKEY_DFU_ATTRIBUTES:
+		return "DFU_ATTRIBUTES";
+	case CSR_PSKEY_DFU_DETACH_TO:
+		return "DFU_DETACH_TO";
+	case CSR_PSKEY_DFU_TRANSFER_SIZE:
+		return "DFU_TRANSFER_SIZE";
+	case CSR_PSKEY_DFU_ENABLE:
+		return "DFU_ENABLE";
+	case CSR_PSKEY_DFU_LIN_REG_ENABLE:
+		return "DFU_LIN_REG_ENABLE";
+	case CSR_PSKEY_DFUENC_VMAPP_PK_MODULUS_MSB:
+		return "DFUENC_VMAPP_PK_MODULUS_MSB";
+	case CSR_PSKEY_DFUENC_VMAPP_PK_MODULUS_LSB:
+		return "DFUENC_VMAPP_PK_MODULUS_LSB";
+	case CSR_PSKEY_DFUENC_VMAPP_PK_M_DASH:
+		return "DFUENC_VMAPP_PK_M_DASH";
+	case CSR_PSKEY_DFUENC_VMAPP_PK_R2N_MSB:
+		return "DFUENC_VMAPP_PK_R2N_MSB";
+	case CSR_PSKEY_DFUENC_VMAPP_PK_R2N_LSB:
+		return "DFUENC_VMAPP_PK_R2N_LSB";
+	case CSR_PSKEY_BCSP_LM_PS_BLOCK:
+		return "BCSP_LM_PS_BLOCK";
+	case CSR_PSKEY_HOSTIO_FC_PS_BLOCK:
+		return "HOSTIO_FC_PS_BLOCK";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO0:
+		return "HOSTIO_PROTOCOL_INFO0";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO1:
+		return "HOSTIO_PROTOCOL_INFO1";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO2:
+		return "HOSTIO_PROTOCOL_INFO2";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO3:
+		return "HOSTIO_PROTOCOL_INFO3";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO4:
+		return "HOSTIO_PROTOCOL_INFO4";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO5:
+		return "HOSTIO_PROTOCOL_INFO5";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO6:
+		return "HOSTIO_PROTOCOL_INFO6";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO7:
+		return "HOSTIO_PROTOCOL_INFO7";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO8:
+		return "HOSTIO_PROTOCOL_INFO8";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO9:
+		return "HOSTIO_PROTOCOL_INFO9";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO10:
+		return "HOSTIO_PROTOCOL_INFO10";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO11:
+		return "HOSTIO_PROTOCOL_INFO11";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO12:
+		return "HOSTIO_PROTOCOL_INFO12";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO13:
+		return "HOSTIO_PROTOCOL_INFO13";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO14:
+		return "HOSTIO_PROTOCOL_INFO14";
+	case CSR_PSKEY_HOSTIO_PROTOCOL_INFO15:
+		return "HOSTIO_PROTOCOL_INFO15";
+	case CSR_PSKEY_HOSTIO_UART_RESET_TIMEOUT:
+		return "HOSTIO_UART_RESET_TIMEOUT";
+	case CSR_PSKEY_HOSTIO_USE_HCI_EXTN:
+		return "HOSTIO_USE_HCI_EXTN";
+	case CSR_PSKEY_HOSTIO_USE_HCI_EXTN_CCFC:
+		return "HOSTIO_USE_HCI_EXTN_CCFC";
+	case CSR_PSKEY_HOSTIO_HCI_EXTN_PAYLOAD_SIZE:
+		return "HOSTIO_HCI_EXTN_PAYLOAD_SIZE";
+	case CSR_PSKEY_BCSP_LM_CNF_CNT_LIMIT:
+		return "BCSP_LM_CNF_CNT_LIMIT";
+	case CSR_PSKEY_HOSTIO_MAP_SCO_PCM:
+		return "HOSTIO_MAP_SCO_PCM";
+	case CSR_PSKEY_HOSTIO_AWKWARD_PCM_SYNC:
+		return "HOSTIO_AWKWARD_PCM_SYNC";
+	case CSR_PSKEY_HOSTIO_BREAK_POLL_PERIOD:
+		return "HOSTIO_BREAK_POLL_PERIOD";
+	case CSR_PSKEY_HOSTIO_MIN_UART_HCI_SCO_SIZE:
+		return "HOSTIO_MIN_UART_HCI_SCO_SIZE";
+	case CSR_PSKEY_HOSTIO_MAP_SCO_CODEC:
+		return "HOSTIO_MAP_SCO_CODEC";
+	case CSR_PSKEY_PCM_CVSD_TX_HI_FREQ_BOOST:
+		return "PCM_CVSD_TX_HI_FREQ_BOOST";
+	case CSR_PSKEY_PCM_CVSD_RX_HI_FREQ_BOOST:
+		return "PCM_CVSD_RX_HI_FREQ_BOOST";
+	case CSR_PSKEY_PCM_CONFIG32:
+		return "PCM_CONFIG32";
+	case CSR_PSKEY_USE_OLD_BCSP_LE:
+		return "USE_OLD_BCSP_LE";
+	case CSR_PSKEY_PCM_CVSD_USE_NEW_FILTER:
+		return "PCM_CVSD_USE_NEW_FILTER";
+	case CSR_PSKEY_PCM_FORMAT:
+		return "PCM_FORMAT";
+	case CSR_PSKEY_CODEC_OUT_GAIN:
+		return "CODEC_OUT_GAIN";
+	case CSR_PSKEY_CODEC_IN_GAIN:
+		return "CODEC_IN_GAIN";
+	case CSR_PSKEY_CODEC_PIO:
+		return "CODEC_PIO";
+	case CSR_PSKEY_PCM_LOW_JITTER_CONFIG:
+		return "PCM_LOW_JITTER_CONFIG";
+	case CSR_PSKEY_HOSTIO_SCO_PCM_THRESHOLDS:
+		return "HOSTIO_SCO_PCM_THRESHOLDS";
+	case CSR_PSKEY_HOSTIO_SCO_HCI_THRESHOLDS:
+		return "HOSTIO_SCO_HCI_THRESHOLDS";
+	case CSR_PSKEY_HOSTIO_MAP_SCO_PCM_SLOT:
+		return "HOSTIO_MAP_SCO_PCM_SLOT";
+	case CSR_PSKEY_UART_BAUDRATE:
+		return "UART_BAUDRATE";
+	case CSR_PSKEY_UART_CONFIG_BCSP:
+		return "UART_CONFIG_BCSP";
+	case CSR_PSKEY_UART_CONFIG_H4:
+		return "UART_CONFIG_H4";
+	case CSR_PSKEY_UART_CONFIG_H5:
+		return "UART_CONFIG_H5";
+	case CSR_PSKEY_UART_CONFIG_USR:
+		return "UART_CONFIG_USR";
+	case CSR_PSKEY_UART_TX_CRCS:
+		return "UART_TX_CRCS";
+	case CSR_PSKEY_UART_ACK_TIMEOUT:
+		return "UART_ACK_TIMEOUT";
+	case CSR_PSKEY_UART_TX_MAX_ATTEMPTS:
+		return "UART_TX_MAX_ATTEMPTS";
+	case CSR_PSKEY_UART_TX_WINDOW_SIZE:
+		return "UART_TX_WINDOW_SIZE";
+	case CSR_PSKEY_UART_HOST_WAKE:
+		return "UART_HOST_WAKE";
+	case CSR_PSKEY_HOSTIO_THROTTLE_TIMEOUT:
+		return "HOSTIO_THROTTLE_TIMEOUT";
+	case CSR_PSKEY_PCM_ALWAYS_ENABLE:
+		return "PCM_ALWAYS_ENABLE";
+	case CSR_PSKEY_UART_HOST_WAKE_SIGNAL:
+		return "UART_HOST_WAKE_SIGNAL";
+	case CSR_PSKEY_UART_CONFIG_H4DS:
+		return "UART_CONFIG_H4DS";
+	case CSR_PSKEY_H4DS_WAKE_DURATION:
+		return "H4DS_WAKE_DURATION";
+	case CSR_PSKEY_H4DS_MAXWU:
+		return "H4DS_MAXWU";
+	case CSR_PSKEY_H4DS_LE_TIMER_PERIOD:
+		return "H4DS_LE_TIMER_PERIOD";
+	case CSR_PSKEY_H4DS_TWU_TIMER_PERIOD:
+		return "H4DS_TWU_TIMER_PERIOD";
+	case CSR_PSKEY_H4DS_UART_IDLE_TIMER_PERIOD:
+		return "H4DS_UART_IDLE_TIMER_PERIOD";
+	case CSR_PSKEY_ANA_FTRIM:
+		return "ANA_FTRIM";
+	case CSR_PSKEY_WD_TIMEOUT:
+		return "WD_TIMEOUT";
+	case CSR_PSKEY_WD_PERIOD:
+		return "WD_PERIOD";
+	case CSR_PSKEY_HOST_INTERFACE:
+		return "HOST_INTERFACE";
+	case CSR_PSKEY_HQ_HOST_TIMEOUT:
+		return "HQ_HOST_TIMEOUT";
+	case CSR_PSKEY_HQ_ACTIVE:
+		return "HQ_ACTIVE";
+	case CSR_PSKEY_BCCMD_SECURITY_ACTIVE:
+		return "BCCMD_SECURITY_ACTIVE";
+	case CSR_PSKEY_ANA_FREQ:
+		return "ANA_FREQ";
+	case CSR_PSKEY_PIO_PROTECT_MASK:
+		return "PIO_PROTECT_MASK";
+	case CSR_PSKEY_PMALLOC_SIZES:
+		return "PMALLOC_SIZES";
+	case CSR_PSKEY_UART_BAUD_RATE:
+		return "UART_BAUD_RATE";
+	case CSR_PSKEY_UART_CONFIG:
+		return "UART_CONFIG";
+	case CSR_PSKEY_STUB:
+		return "STUB";
+	case CSR_PSKEY_TXRX_PIO_CONTROL:
+		return "TXRX_PIO_CONTROL";
+	case CSR_PSKEY_ANA_RX_LEVEL:
+		return "ANA_RX_LEVEL";
+	case CSR_PSKEY_ANA_RX_FTRIM:
+		return "ANA_RX_FTRIM";
+	case CSR_PSKEY_PSBC_DATA_VERSION:
+		return "PSBC_DATA_VERSION";
+	case CSR_PSKEY_PCM0_ATTENUATION:
+		return "PCM0_ATTENUATION";
+	case CSR_PSKEY_LO_LVL_MAX:
+		return "LO_LVL_MAX";
+	case CSR_PSKEY_LO_ADC_AMPL_MIN:
+		return "LO_ADC_AMPL_MIN";
+	case CSR_PSKEY_LO_ADC_AMPL_MAX:
+		return "LO_ADC_AMPL_MAX";
+	case CSR_PSKEY_IQ_TRIM_CHANNEL:
+		return "IQ_TRIM_CHANNEL";
+	case CSR_PSKEY_IQ_TRIM_GAIN:
+		return "IQ_TRIM_GAIN";
+	case CSR_PSKEY_IQ_TRIM_ENABLE:
+		return "IQ_TRIM_ENABLE";
+	case CSR_PSKEY_TX_OFFSET_HALF_MHZ:
+		return "TX_OFFSET_HALF_MHZ";
+	case CSR_PSKEY_GBL_MISC_ENABLES:
+		return "GBL_MISC_ENABLES";
+	case CSR_PSKEY_UART_SLEEP_TIMEOUT:
+		return "UART_SLEEP_TIMEOUT";
+	case CSR_PSKEY_DEEP_SLEEP_STATE:
+		return "DEEP_SLEEP_STATE";
+	case CSR_PSKEY_IQ_ENABLE_PHASE_TRIM:
+		return "IQ_ENABLE_PHASE_TRIM";
+	case CSR_PSKEY_HCI_HANDLE_FREEZE_PERIOD:
+		return "HCI_HANDLE_FREEZE_PERIOD";
+	case CSR_PSKEY_MAX_FROZEN_HCI_HANDLES:
+		return "MAX_FROZEN_HCI_HANDLES";
+	case CSR_PSKEY_PAGETABLE_DESTRUCTION_DELAY:
+		return "PAGETABLE_DESTRUCTION_DELAY";
+	case CSR_PSKEY_IQ_TRIM_PIO_SETTINGS:
+		return "IQ_TRIM_PIO_SETTINGS";
+	case CSR_PSKEY_USE_EXTERNAL_CLOCK:
+		return "USE_EXTERNAL_CLOCK";
+	case CSR_PSKEY_DEEP_SLEEP_WAKE_CTS:
+		return "DEEP_SLEEP_WAKE_CTS";
+	case CSR_PSKEY_FC_HC2H_FLUSH_DELAY:
+		return "FC_HC2H_FLUSH_DELAY";
+	case CSR_PSKEY_RX_HIGHSIDE:
+		return "RX_HIGHSIDE";
+	case CSR_PSKEY_TX_PRE_LVL:
+		return "TX_PRE_LVL";
+	case CSR_PSKEY_RX_SINGLE_ENDED:
+		return "RX_SINGLE_ENDED";
+	case CSR_PSKEY_TX_FILTER_CONFIG:
+		return "TX_FILTER_CONFIG";
+	case CSR_PSKEY_CLOCK_REQUEST_ENABLE:
+		return "CLOCK_REQUEST_ENABLE";
+	case CSR_PSKEY_RX_MIN_ATTEN:
+		return "RX_MIN_ATTEN";
+	case CSR_PSKEY_XTAL_TARGET_AMPLITUDE:
+		return "XTAL_TARGET_AMPLITUDE";
+	case CSR_PSKEY_PCM_MIN_CPU_CLOCK:
+		return "PCM_MIN_CPU_CLOCK";
+	case CSR_PSKEY_HOST_INTERFACE_PIO_USB:
+		return "HOST_INTERFACE_PIO_USB";
+	case CSR_PSKEY_CPU_IDLE_MODE:
+		return "CPU_IDLE_MODE";
+	case CSR_PSKEY_DEEP_SLEEP_CLEAR_RTS:
+		return "DEEP_SLEEP_CLEAR_RTS";
+	case CSR_PSKEY_RF_RESONANCE_TRIM:
+		return "RF_RESONANCE_TRIM";
+	case CSR_PSKEY_DEEP_SLEEP_PIO_WAKE:
+		return "DEEP_SLEEP_PIO_WAKE";
+	case CSR_PSKEY_DRAIN_BORE_TIMERS:
+		return "DRAIN_BORE_TIMERS";
+	case CSR_PSKEY_DRAIN_TX_POWER_BASE:
+		return "DRAIN_TX_POWER_BASE";
+	case CSR_PSKEY_MODULE_ID:
+		return "MODULE_ID";
+	case CSR_PSKEY_MODULE_DESIGN:
+		return "MODULE_DESIGN";
+	case CSR_PSKEY_MODULE_SECURITY_CODE:
+		return "MODULE_SECURITY_CODE";
+	case CSR_PSKEY_VM_DISABLE:
+		return "VM_DISABLE";
+	case CSR_PSKEY_MOD_MANUF0:
+		return "MOD_MANUF0";
+	case CSR_PSKEY_MOD_MANUF1:
+		return "MOD_MANUF1";
+	case CSR_PSKEY_MOD_MANUF2:
+		return "MOD_MANUF2";
+	case CSR_PSKEY_MOD_MANUF3:
+		return "MOD_MANUF3";
+	case CSR_PSKEY_MOD_MANUF4:
+		return "MOD_MANUF4";
+	case CSR_PSKEY_MOD_MANUF5:
+		return "MOD_MANUF5";
+	case CSR_PSKEY_MOD_MANUF6:
+		return "MOD_MANUF6";
+	case CSR_PSKEY_MOD_MANUF7:
+		return "MOD_MANUF7";
+	case CSR_PSKEY_MOD_MANUF8:
+		return "MOD_MANUF8";
+	case CSR_PSKEY_MOD_MANUF9:
+		return "MOD_MANUF9";
+	case CSR_PSKEY_DUT_VM_DISABLE:
+		return "DUT_VM_DISABLE";
+	case CSR_PSKEY_USR0:
+		return "USR0";
+	case CSR_PSKEY_USR1:
+		return "USR1";
+	case CSR_PSKEY_USR2:
+		return "USR2";
+	case CSR_PSKEY_USR3:
+		return "USR3";
+	case CSR_PSKEY_USR4:
+		return "USR4";
+	case CSR_PSKEY_USR5:
+		return "USR5";
+	case CSR_PSKEY_USR6:
+		return "USR6";
+	case CSR_PSKEY_USR7:
+		return "USR7";
+	case CSR_PSKEY_USR8:
+		return "USR8";
+	case CSR_PSKEY_USR9:
+		return "USR9";
+	case CSR_PSKEY_USR10:
+		return "USR10";
+	case CSR_PSKEY_USR11:
+		return "USR11";
+	case CSR_PSKEY_USR12:
+		return "USR12";
+	case CSR_PSKEY_USR13:
+		return "USR13";
+	case CSR_PSKEY_USR14:
+		return "USR14";
+	case CSR_PSKEY_USR15:
+		return "USR15";
+	case CSR_PSKEY_USR16:
+		return "USR16";
+	case CSR_PSKEY_USR17:
+		return "USR17";
+	case CSR_PSKEY_USR18:
+		return "USR18";
+	case CSR_PSKEY_USR19:
+		return "USR19";
+	case CSR_PSKEY_USR20:
+		return "USR20";
+	case CSR_PSKEY_USR21:
+		return "USR21";
+	case CSR_PSKEY_USR22:
+		return "USR22";
+	case CSR_PSKEY_USR23:
+		return "USR23";
+	case CSR_PSKEY_USR24:
+		return "USR24";
+	case CSR_PSKEY_USR25:
+		return "USR25";
+	case CSR_PSKEY_USR26:
+		return "USR26";
+	case CSR_PSKEY_USR27:
+		return "USR27";
+	case CSR_PSKEY_USR28:
+		return "USR28";
+	case CSR_PSKEY_USR29:
+		return "USR29";
+	case CSR_PSKEY_USR30:
+		return "USR30";
+	case CSR_PSKEY_USR31:
+		return "USR31";
+	case CSR_PSKEY_USR32:
+		return "USR32";
+	case CSR_PSKEY_USR33:
+		return "USR33";
+	case CSR_PSKEY_USR34:
+		return "USR34";
+	case CSR_PSKEY_USR35:
+		return "USR35";
+	case CSR_PSKEY_USR36:
+		return "USR36";
+	case CSR_PSKEY_USR37:
+		return "USR37";
+	case CSR_PSKEY_USR38:
+		return "USR38";
+	case CSR_PSKEY_USR39:
+		return "USR39";
+	case CSR_PSKEY_USR40:
+		return "USR40";
+	case CSR_PSKEY_USR41:
+		return "USR41";
+	case CSR_PSKEY_USR42:
+		return "USR42";
+	case CSR_PSKEY_USR43:
+		return "USR43";
+	case CSR_PSKEY_USR44:
+		return "USR44";
+	case CSR_PSKEY_USR45:
+		return "USR45";
+	case CSR_PSKEY_USR46:
+		return "USR46";
+	case CSR_PSKEY_USR47:
+		return "USR47";
+	case CSR_PSKEY_USR48:
+		return "USR48";
+	case CSR_PSKEY_USR49:
+		return "USR49";
+	case CSR_PSKEY_USB_VERSION:
+		return "USB_VERSION";
+	case CSR_PSKEY_USB_DEVICE_CLASS_CODES:
+		return "USB_DEVICE_CLASS_CODES";
+	case CSR_PSKEY_USB_VENDOR_ID:
+		return "USB_VENDOR_ID";
+	case CSR_PSKEY_USB_PRODUCT_ID:
+		return "USB_PRODUCT_ID";
+	case CSR_PSKEY_USB_MANUF_STRING:
+		return "USB_MANUF_STRING";
+	case CSR_PSKEY_USB_PRODUCT_STRING:
+		return "USB_PRODUCT_STRING";
+	case CSR_PSKEY_USB_SERIAL_NUMBER_STRING:
+		return "USB_SERIAL_NUMBER_STRING";
+	case CSR_PSKEY_USB_CONFIG_STRING:
+		return "USB_CONFIG_STRING";
+	case CSR_PSKEY_USB_ATTRIBUTES:
+		return "USB_ATTRIBUTES";
+	case CSR_PSKEY_USB_MAX_POWER:
+		return "USB_MAX_POWER";
+	case CSR_PSKEY_USB_BT_IF_CLASS_CODES:
+		return "USB_BT_IF_CLASS_CODES";
+	case CSR_PSKEY_USB_LANGID:
+		return "USB_LANGID";
+	case CSR_PSKEY_USB_DFU_CLASS_CODES:
+		return "USB_DFU_CLASS_CODES";
+	case CSR_PSKEY_USB_DFU_PRODUCT_ID:
+		return "USB_DFU_PRODUCT_ID";
+	case CSR_PSKEY_USB_PIO_DETACH:
+		return "USB_PIO_DETACH";
+	case CSR_PSKEY_USB_PIO_WAKEUP:
+		return "USB_PIO_WAKEUP";
+	case CSR_PSKEY_USB_PIO_PULLUP:
+		return "USB_PIO_PULLUP";
+	case CSR_PSKEY_USB_PIO_VBUS:
+		return "USB_PIO_VBUS";
+	case CSR_PSKEY_USB_PIO_WAKE_TIMEOUT:
+		return "USB_PIO_WAKE_TIMEOUT";
+	case CSR_PSKEY_USB_PIO_RESUME:
+		return "USB_PIO_RESUME";
+	case CSR_PSKEY_USB_BT_SCO_IF_CLASS_CODES:
+		return "USB_BT_SCO_IF_CLASS_CODES";
+	case CSR_PSKEY_USB_SUSPEND_PIO_LEVEL:
+		return "USB_SUSPEND_PIO_LEVEL";
+	case CSR_PSKEY_USB_SUSPEND_PIO_DIR:
+		return "USB_SUSPEND_PIO_DIR";
+	case CSR_PSKEY_USB_SUSPEND_PIO_MASK:
+		return "USB_SUSPEND_PIO_MASK";
+	case CSR_PSKEY_USB_ENDPOINT_0_MAX_PACKET_SIZE:
+		return "USB_ENDPOINT_0_MAX_PACKET_SIZE";
+	case CSR_PSKEY_USB_CONFIG:
+		return "USB_CONFIG";
+	case CSR_PSKEY_RADIOTEST_ATTEN_INIT:
+		return "RADIOTEST_ATTEN_INIT";
+	case CSR_PSKEY_RADIOTEST_FIRST_TRIM_TIME:
+		return "RADIOTEST_FIRST_TRIM_TIME";
+	case CSR_PSKEY_RADIOTEST_SUBSEQUENT_TRIM_TIME:
+		return "RADIOTEST_SUBSEQUENT_TRIM_TIME";
+	case CSR_PSKEY_RADIOTEST_LO_LVL_TRIM_ENABLE:
+		return "RADIOTEST_LO_LVL_TRIM_ENABLE";
+	case CSR_PSKEY_RADIOTEST_DISABLE_MODULATION:
+		return "RADIOTEST_DISABLE_MODULATION";
+	case CSR_PSKEY_RFCOMM_FCON_THRESHOLD:
+		return "RFCOMM_FCON_THRESHOLD";
+	case CSR_PSKEY_RFCOMM_FCOFF_THRESHOLD:
+		return "RFCOMM_FCOFF_THRESHOLD";
+	case CSR_PSKEY_IPV6_STATIC_ADDR:
+		return "IPV6_STATIC_ADDR";
+	case CSR_PSKEY_IPV4_STATIC_ADDR:
+		return "IPV4_STATIC_ADDR";
+	case CSR_PSKEY_IPV6_STATIC_PREFIX_LEN:
+		return "IPV6_STATIC_PREFIX_LEN";
+	case CSR_PSKEY_IPV6_STATIC_ROUTER_ADDR:
+		return "IPV6_STATIC_ROUTER_ADDR";
+	case CSR_PSKEY_IPV4_STATIC_SUBNET_MASK:
+		return "IPV4_STATIC_SUBNET_MASK";
+	case CSR_PSKEY_IPV4_STATIC_ROUTER_ADDR:
+		return "IPV4_STATIC_ROUTER_ADDR";
+	case CSR_PSKEY_MDNS_NAME:
+		return "MDNS_NAME";
+	case CSR_PSKEY_FIXED_PIN:
+		return "FIXED_PIN";
+	case CSR_PSKEY_MDNS_PORT:
+		return "MDNS_PORT";
+	case CSR_PSKEY_MDNS_TTL:
+		return "MDNS_TTL";
+	case CSR_PSKEY_MDNS_IPV4_ADDR:
+		return "MDNS_IPV4_ADDR";
+	case CSR_PSKEY_ARP_CACHE_TIMEOUT:
+		return "ARP_CACHE_TIMEOUT";
+	case CSR_PSKEY_HFP_POWER_TABLE:
+		return "HFP_POWER_TABLE";
+	case CSR_PSKEY_DRAIN_BORE_TIMER_COUNTERS:
+		return "DRAIN_BORE_TIMER_COUNTERS";
+	case CSR_PSKEY_DRAIN_BORE_COUNTERS:
+		return "DRAIN_BORE_COUNTERS";
+	case CSR_PSKEY_LOOP_FILTER_TRIM:
+		return "LOOP_FILTER_TRIM";
+	case CSR_PSKEY_DRAIN_BORE_CURRENT_PEAK:
+		return "DRAIN_BORE_CURRENT_PEAK";
+	case CSR_PSKEY_VM_E2_CACHE_LIMIT:
+		return "VM_E2_CACHE_LIMIT";
+	case CSR_PSKEY_FORCE_16MHZ_REF_PIO:
+		return "FORCE_16MHZ_REF_PIO";
+	case CSR_PSKEY_CDMA_LO_REF_LIMITS:
+		return "CDMA_LO_REF_LIMITS";
+	case CSR_PSKEY_CDMA_LO_ERROR_LIMITS:
+		return "CDMA_LO_ERROR_LIMITS";
+	case CSR_PSKEY_CLOCK_STARTUP_DELAY:
+		return "CLOCK_STARTUP_DELAY";
+	case CSR_PSKEY_DEEP_SLEEP_CORRECTION_FACTOR:
+		return "DEEP_SLEEP_CORRECTION_FACTOR";
+	case CSR_PSKEY_TEMPERATURE_CALIBRATION:
+		return "TEMPERATURE_CALIBRATION";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_INTERNAL_PA:
+		return "TEMPERATURE_VS_DELTA_INTERNAL_PA";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_PRE_LVL:
+		return "TEMPERATURE_VS_DELTA_TX_PRE_LVL";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB:
+		return "TEMPERATURE_VS_DELTA_TX_BB";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_ANA_FTRIM:
+		return "TEMPERATURE_VS_DELTA_ANA_FTRIM";
+	case CSR_PSKEY_TEST_DELTA_OFFSET:
+		return "TEST_DELTA_OFFSET";
+	case CSR_PSKEY_RX_DYNAMIC_LVL_OFFSET:
+		return "RX_DYNAMIC_LVL_OFFSET";
+	case CSR_PSKEY_TEST_FORCE_OFFSET:
+		return "TEST_FORCE_OFFSET";
+	case CSR_PSKEY_RF_TRAP_BAD_DIVISION_RATIOS:
+		return "RF_TRAP_BAD_DIVISION_RATIOS";
+	case CSR_PSKEY_RADIOTEST_CDMA_LO_REF_LIMITS:
+		return "RADIOTEST_CDMA_LO_REF_LIMITS";
+	case CSR_PSKEY_INITIAL_BOOTMODE:
+		return "INITIAL_BOOTMODE";
+	case CSR_PSKEY_ONCHIP_HCI_CLIENT:
+		return "ONCHIP_HCI_CLIENT";
+	case CSR_PSKEY_RX_ATTEN_BACKOFF:
+		return "RX_ATTEN_BACKOFF";
+	case CSR_PSKEY_RX_ATTEN_UPDATE_RATE:
+		return "RX_ATTEN_UPDATE_RATE";
+	case CSR_PSKEY_SYNTH_TXRX_THRESHOLDS:
+		return "SYNTH_TXRX_THRESHOLDS";
+	case CSR_PSKEY_MIN_WAIT_STATES:
+		return "MIN_WAIT_STATES";
+	case CSR_PSKEY_RSSI_CORRECTION:
+		return "RSSI_CORRECTION";
+	case CSR_PSKEY_SCHED_THROTTLE_TIMEOUT:
+		return "SCHED_THROTTLE_TIMEOUT";
+	case CSR_PSKEY_DEEP_SLEEP_USE_EXTERNAL_CLOCK:
+		return "DEEP_SLEEP_USE_EXTERNAL_CLOCK";
+	case CSR_PSKEY_TRIM_RADIO_FILTERS:
+		return "TRIM_RADIO_FILTERS";
+	case CSR_PSKEY_TRANSMIT_OFFSET:
+		return "TRANSMIT_OFFSET";
+	case CSR_PSKEY_USB_VM_CONTROL:
+		return "USB_VM_CONTROL";
+	case CSR_PSKEY_MR_ANA_RX_FTRIM:
+		return "MR_ANA_RX_FTRIM";
+	case CSR_PSKEY_I2C_CONFIG:
+		return "I2C_CONFIG";
+	case CSR_PSKEY_IQ_LVL_RX:
+		return "IQ_LVL_RX";
+	case CSR_PSKEY_MR_TX_FILTER_CONFIG:
+		return "MR_TX_FILTER_CONFIG";
+	case CSR_PSKEY_MR_TX_CONFIG2:
+		return "MR_TX_CONFIG2";
+	case CSR_PSKEY_USB_DONT_RESET_BOOTMODE_ON_HOST_RESET:
+		return "USB_DONT_RESET_BOOTMODE_ON_HOST_RESET";
+	case CSR_PSKEY_LC_USE_THROTTLING:
+		return "LC_USE_THROTTLING";
+	case CSR_PSKEY_CHARGER_TRIM:
+		return "CHARGER_TRIM";
+	case CSR_PSKEY_CLOCK_REQUEST_FEATURES:
+		return "CLOCK_REQUEST_FEATURES";
+	case CSR_PSKEY_TRANSMIT_OFFSET_CLASS1:
+		return "TRANSMIT_OFFSET_CLASS1";
+	case CSR_PSKEY_TX_AVOID_PA_CLASS1_PIO:
+		return "TX_AVOID_PA_CLASS1_PIO";
+	case CSR_PSKEY_MR_PIO_CONFIG:
+		return "MR_PIO_CONFIG";
+	case CSR_PSKEY_UART_CONFIG2:
+		return "UART_CONFIG2";
+	case CSR_PSKEY_CLASS1_IQ_LVL:
+		return "CLASS1_IQ_LVL";
+	case CSR_PSKEY_CLASS1_TX_CONFIG2:
+		return "CLASS1_TX_CONFIG2";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_INTERNAL_PA_CLASS1:
+		return "TEMPERATURE_VS_DELTA_INTERNAL_PA_CLASS1";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_EXTERNAL_PA_CLASS1:
+		return "TEMPERATURE_VS_DELTA_EXTERNAL_PA_CLASS1";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_PRE_LVL_MR:
+		return "TEMPERATURE_VS_DELTA_TX_PRE_LVL_MR";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB_MR_HEADER:
+		return "TEMPERATURE_VS_DELTA_TX_BB_MR_HEADER";
+	case CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB_MR_PAYLOAD:
+		return "TEMPERATURE_VS_DELTA_TX_BB_MR_PAYLOAD";
+	case CSR_PSKEY_RX_MR_EQ_TAPS:
+		return "RX_MR_EQ_TAPS";
+	case CSR_PSKEY_TX_PRE_LVL_CLASS1:
+		return "TX_PRE_LVL_CLASS1";
+	case CSR_PSKEY_ANALOGUE_ATTENUATOR:
+		return "ANALOGUE_ATTENUATOR";
+	case CSR_PSKEY_MR_RX_FILTER_TRIM:
+		return "MR_RX_FILTER_TRIM";
+	case CSR_PSKEY_MR_RX_FILTER_RESPONSE:
+		return "MR_RX_FILTER_RESPONSE";
+	case CSR_PSKEY_PIO_WAKEUP_STATE:
+		return "PIO_WAKEUP_STATE";
+	case CSR_PSKEY_MR_TX_IF_ATTEN_OFF_TEMP:
+		return "MR_TX_IF_ATTEN_OFF_TEMP";
+	case CSR_PSKEY_LO_DIV_LATCH_BYPASS:
+		return "LO_DIV_LATCH_BYPASS";
+	case CSR_PSKEY_LO_VCO_STANDBY:
+		return "LO_VCO_STANDBY";
+	case CSR_PSKEY_SLOW_CLOCK_FILTER_SHIFT:
+		return "SLOW_CLOCK_FILTER_SHIFT";
+	case CSR_PSKEY_SLOW_CLOCK_FILTER_DIVIDER:
+		return "SLOW_CLOCK_FILTER_DIVIDER";
+	case CSR_PSKEY_USB_ATTRIBUTES_POWER:
+		return "USB_ATTRIBUTES_POWER";
+	case CSR_PSKEY_USB_ATTRIBUTES_WAKEUP:
+		return "USB_ATTRIBUTES_WAKEUP";
+	case CSR_PSKEY_DFU_ATTRIBUTES_MANIFESTATION_TOLERANT:
+		return "DFU_ATTRIBUTES_MANIFESTATION_TOLERANT";
+	case CSR_PSKEY_DFU_ATTRIBUTES_CAN_UPLOAD:
+		return "DFU_ATTRIBUTES_CAN_UPLOAD";
+	case CSR_PSKEY_DFU_ATTRIBUTES_CAN_DOWNLOAD:
+		return "DFU_ATTRIBUTES_CAN_DOWNLOAD";
+	case CSR_PSKEY_UART_CONFIG_STOP_BITS:
+		return "UART_CONFIG_STOP_BITS";
+	case CSR_PSKEY_UART_CONFIG_PARITY_BIT:
+		return "UART_CONFIG_PARITY_BIT";
+	case CSR_PSKEY_UART_CONFIG_FLOW_CTRL_EN:
+		return "UART_CONFIG_FLOW_CTRL_EN";
+	case CSR_PSKEY_UART_CONFIG_RTS_AUTO_EN:
+		return "UART_CONFIG_RTS_AUTO_EN";
+	case CSR_PSKEY_UART_CONFIG_RTS:
+		return "UART_CONFIG_RTS";
+	case CSR_PSKEY_UART_CONFIG_TX_ZERO_EN:
+		return "UART_CONFIG_TX_ZERO_EN";
+	case CSR_PSKEY_UART_CONFIG_NON_BCSP_EN:
+		return "UART_CONFIG_NON_BCSP_EN";
+	case CSR_PSKEY_UART_CONFIG_RX_RATE_DELAY:
+		return "UART_CONFIG_RX_RATE_DELAY";
+	case CSR_PSKEY_UART_SEQ_TIMEOUT:
+		return "UART_SEQ_TIMEOUT";
+	case CSR_PSKEY_UART_SEQ_RETRIES:
+		return "UART_SEQ_RETRIES";
+	case CSR_PSKEY_UART_SEQ_WINSIZE:
+		return "UART_SEQ_WINSIZE";
+	case CSR_PSKEY_UART_USE_CRC_ON_TX:
+		return "UART_USE_CRC_ON_TX";
+	case CSR_PSKEY_UART_HOST_INITIAL_STATE:
+		return "UART_HOST_INITIAL_STATE";
+	case CSR_PSKEY_UART_HOST_ATTENTION_SPAN:
+		return "UART_HOST_ATTENTION_SPAN";
+	case CSR_PSKEY_UART_HOST_WAKEUP_TIME:
+		return "UART_HOST_WAKEUP_TIME";
+	case CSR_PSKEY_UART_HOST_WAKEUP_WAIT:
+		return "UART_HOST_WAKEUP_WAIT";
+	case CSR_PSKEY_BCSP_LM_MODE:
+		return "BCSP_LM_MODE";
+	case CSR_PSKEY_BCSP_LM_SYNC_RETRIES:
+		return "BCSP_LM_SYNC_RETRIES";
+	case CSR_PSKEY_BCSP_LM_TSHY:
+		return "BCSP_LM_TSHY";
+	case CSR_PSKEY_UART_DFU_CONFIG_STOP_BITS:
+		return "UART_DFU_CONFIG_STOP_BITS";
+	case CSR_PSKEY_UART_DFU_CONFIG_PARITY_BIT:
+		return "UART_DFU_CONFIG_PARITY_BIT";
+	case CSR_PSKEY_UART_DFU_CONFIG_FLOW_CTRL_EN:
+		return "UART_DFU_CONFIG_FLOW_CTRL_EN";
+	case CSR_PSKEY_UART_DFU_CONFIG_RTS_AUTO_EN:
+		return "UART_DFU_CONFIG_RTS_AUTO_EN";
+	case CSR_PSKEY_UART_DFU_CONFIG_RTS:
+		return "UART_DFU_CONFIG_RTS";
+	case CSR_PSKEY_UART_DFU_CONFIG_TX_ZERO_EN:
+		return "UART_DFU_CONFIG_TX_ZERO_EN";
+	case CSR_PSKEY_UART_DFU_CONFIG_NON_BCSP_EN:
+		return "UART_DFU_CONFIG_NON_BCSP_EN";
+	case CSR_PSKEY_UART_DFU_CONFIG_RX_RATE_DELAY:
+		return "UART_DFU_CONFIG_RX_RATE_DELAY";
+	case CSR_PSKEY_AMUX_AIO0:
+		return "AMUX_AIO0";
+	case CSR_PSKEY_AMUX_AIO1:
+		return "AMUX_AIO1";
+	case CSR_PSKEY_AMUX_AIO2:
+		return "AMUX_AIO2";
+	case CSR_PSKEY_AMUX_AIO3:
+		return "AMUX_AIO3";
+	case CSR_PSKEY_LOCAL_NAME_SIMPLIFIED:
+		return "LOCAL_NAME_SIMPLIFIED";
+	case CSR_PSKEY_EXTENDED_STUB:
+		return "EXTENDED_STUB";
+	default:
+		return "UNKNOWN";
+	}
+}
+
+int csr_write_varid_valueless(int dd, uint16_t seqnum, uint16_t varid)
+{
+	unsigned char cmd[] = { 0x02, 0x00, 0x09, 0x00,
+				seqnum & 0xff, seqnum >> 8, varid & 0xff, varid >> 8, 0x00, 0x00,
+				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+	unsigned char cp[254], rp[254];
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp[0] = 0xc2;
+	memcpy(cp + 1, cmd, sizeof(cmd));
+
+	switch (varid) {
+	case CSR_VARID_COLD_RESET:
+	case CSR_VARID_WARM_RESET:
+	case CSR_VARID_COLD_HALT:
+	case CSR_VARID_WARM_HALT:
+		return hci_send_cmd(dd, OGF_VENDOR_CMD, 0x00, sizeof(cmd) + 1, cp);
+	}
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_VENDOR_CMD;
+	rq.ocf    = 0x00;
+	rq.event  = EVT_VENDOR;
+	rq.cparam = cp;
+	rq.clen   = sizeof(cmd) + 1;
+	rq.rparam = rp;
+	rq.rlen   = sizeof(rp);
+
+	if (hci_send_req(dd, &rq, 2000) < 0)
+		return -1;
+
+	if (rp[0] != 0xc2) {
+		errno = EIO;
+		return -1;
+	}
+
+	if ((rp[9] + (rp[10] << 8)) != 0) {
+		errno = ENXIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int csr_write_varid_complex(int dd, uint16_t seqnum, uint16_t varid, uint8_t *value, uint16_t length)
+{
+	unsigned char cmd[] = { 0x02, 0x00, ((length / 2) + 5) & 0xff, ((length / 2) + 5) >> 8,
+				seqnum & 0xff, seqnum >> 8, varid & 0xff, varid >> 8, 0x00, 0x00,
+				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+	unsigned char cp[254], rp[254];
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp[0] = 0xc2;
+	memcpy(cp + 1, cmd, sizeof(cmd));
+	memcpy(cp + 11, value, length);
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_VENDOR_CMD;
+	rq.ocf    = 0x00;
+	rq.event  = EVT_VENDOR;
+	rq.cparam = cp;
+	rq.clen   = sizeof(cmd) + length + 1;
+	rq.rparam = rp;
+	rq.rlen   = sizeof(rp);
+
+	if (hci_send_req(dd, &rq, 2000) < 0)
+		return -1;
+
+	if (rp[0] != 0xc2) {
+		errno = EIO;
+		return -1;
+	}
+
+	if ((rp[9] + (rp[10] << 8)) != 0) {
+		errno = ENXIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int csr_read_varid_complex(int dd, uint16_t seqnum, uint16_t varid, uint8_t *value, uint16_t length)
+{
+	unsigned char cmd[] = { 0x00, 0x00, ((length / 2) + 5) & 0xff, ((length / 2) + 5) >> 8,
+				seqnum & 0xff, seqnum >> 8, varid & 0xff, varid >> 8, 0x00, 0x00,
+				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+	unsigned char cp[254], rp[254];
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp[0] = 0xc2;
+	memcpy(cp + 1, cmd, sizeof(cmd));
+	memcpy(cp + 11, value, length);
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_VENDOR_CMD;
+	rq.ocf    = 0x00;
+	rq.event  = EVT_VENDOR;
+	rq.cparam = cp;
+	rq.clen   = sizeof(cmd) + length + 1;
+	rq.rparam = rp;
+	rq.rlen   = sizeof(rp);
+
+	if (hci_send_req(dd, &rq, 2000) < 0)
+		return -1;
+
+	if (rp[0] != 0xc2) {
+		errno = EIO;
+		return -1;
+	}
+
+	if ((rp[9] + (rp[10] << 8)) != 0) {
+		errno = ENXIO;
+		return -1;
+	}
+
+	memcpy(value, rp + 11, length);
+
+	return 0;
+}
+
+int csr_read_varid_uint16(int dd, uint16_t seqnum, uint16_t varid, uint16_t *value)
+{
+	unsigned char cmd[] = { 0x00, 0x00, 0x09, 0x00,
+				seqnum & 0xff, seqnum >> 8, varid & 0xff, varid >> 8, 0x00, 0x00,
+				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+	unsigned char cp[254], rp[254];
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp[0] = 0xc2;
+	memcpy(cp + 1, cmd, sizeof(cmd));
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_VENDOR_CMD;
+	rq.ocf    = 0x00;
+	rq.event  = EVT_VENDOR;
+	rq.cparam = cp;
+	rq.clen   = sizeof(cmd) + 1;
+	rq.rparam = rp;
+	rq.rlen   = sizeof(rp);
+
+	if (hci_send_req(dd, &rq, 2000) < 0)
+		return -1;
+
+	if (rp[0] != 0xc2) {
+		errno = EIO;
+		return -1;
+	}
+
+	if ((rp[9] + (rp[10] << 8)) != 0) {
+		errno = ENXIO;
+		return -1;
+	}
+
+	*value = rp[11] + (rp[12] << 8);
+
+	return 0;
+}
+
+int csr_read_varid_uint32(int dd, uint16_t seqnum, uint16_t varid, uint32_t *value)
+{
+	unsigned char cmd[] = { 0x00, 0x00, 0x09, 0x00,
+				seqnum & 0xff, seqnum >> 8, varid & 0xff, varid >> 8, 0x00, 0x00,
+				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+	unsigned char cp[254], rp[254];
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp[0] = 0xc2;
+	memcpy(cp + 1, cmd, sizeof(cmd));
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_VENDOR_CMD;
+	rq.ocf    = 0x00;
+	rq.event  = EVT_VENDOR;
+	rq.cparam = cp;
+	rq.clen   = sizeof(cmd) + 1;
+	rq.rparam = rp;
+	rq.rlen   = sizeof(rp);
+
+	if (hci_send_req(dd, &rq, 2000) < 0)
+		return -1;
+
+	if (rp[0] != 0xc2) {
+		errno = EIO;
+		return -1;
+	}
+
+	if ((rp[9] + (rp[10] << 8)) != 0) {
+		errno = ENXIO;
+		return -1;
+	}
+
+	*value = ((rp[11] + (rp[12] << 8)) << 16) + (rp[13] + (rp[14] << 8));
+
+	return 0;
+}
+
+int csr_read_pskey_complex(int dd, uint16_t seqnum, uint16_t pskey, uint16_t stores, uint8_t *value, uint16_t length)
+{
+	unsigned char cmd[] = { 0x00, 0x00, ((length / 2) + 8) & 0xff, ((length / 2) + 8) >> 8,
+				seqnum & 0xff, seqnum >> 8, 0x03, 0x70, 0x00, 0x00,
+				pskey & 0xff, pskey >> 8,
+				(length / 2) & 0xff, (length / 2) >> 8,
+				stores & 0xff, stores >> 8, 0x00, 0x00 };
+
+	unsigned char cp[254], rp[254];
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp[0] = 0xc2;
+	memcpy(cp + 1, cmd, sizeof(cmd));
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_VENDOR_CMD;
+	rq.ocf    = 0x00;
+	rq.event  = EVT_VENDOR;
+	rq.cparam = cp;
+	rq.clen   = sizeof(cmd) + length - 1;
+	rq.rparam = rp;
+	rq.rlen   = sizeof(rp);
+
+	if (hci_send_req(dd, &rq, 2000) < 0)
+		return -1;
+
+	if (rp[0] != 0xc2) {
+		errno = EIO;
+		return -1;
+	}
+
+	if ((rp[9] + (rp[10] << 8)) != 0) {
+		errno = ENXIO;
+		return -1;
+	}
+
+	memcpy(value, rp + 17, length);
+
+	return 0;
+}
+
+int csr_write_pskey_complex(int dd, uint16_t seqnum, uint16_t pskey, uint16_t stores, uint8_t *value, uint16_t length)
+{
+	unsigned char cmd[] = { 0x02, 0x00, ((length / 2) + 8) & 0xff, ((length / 2) + 8) >> 8,
+				seqnum & 0xff, seqnum >> 8, 0x03, 0x70, 0x00, 0x00,
+				pskey & 0xff, pskey >> 8,
+				(length / 2) & 0xff, (length / 2) >> 8,
+				stores & 0xff, stores >> 8, 0x00, 0x00 };
+
+	unsigned char cp[254], rp[254];
+	struct hci_request rq;
+
+	memset(&cp, 0, sizeof(cp));
+	cp[0] = 0xc2;
+	memcpy(cp + 1, cmd, sizeof(cmd));
+
+	memcpy(cp + 17, value, length);
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_VENDOR_CMD;
+	rq.ocf    = 0x00;
+	rq.event  = EVT_VENDOR;
+	rq.cparam = cp;
+	rq.clen   = sizeof(cmd) + length - 1;
+	rq.rparam = rp;
+	rq.rlen   = sizeof(rp);
+
+	if (hci_send_req(dd, &rq, 2000) < 0)
+		return -1;
+
+	if (rp[0] != 0xc2) {
+		errno = EIO;
+		return -1;
+	}
+
+	if ((rp[9] + (rp[10] << 8)) != 0) {
+		errno = ENXIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+int csr_read_pskey_uint16(int dd, uint16_t seqnum, uint16_t pskey, uint16_t stores, uint16_t *value)
+{
+	uint8_t array[2] = { 0x00, 0x00 };
+	int err;
+
+	err = csr_read_pskey_complex(dd, seqnum, pskey, stores, array, 2);
+
+	*value = array[0] + (array[1] << 8);
+
+	return err;
+}
+
+int csr_write_pskey_uint16(int dd, uint16_t seqnum, uint16_t pskey, uint16_t stores, uint16_t value)
+{
+	uint8_t array[2] = { value & 0xff, value >> 8 };
+
+	return csr_write_pskey_complex(dd, seqnum, pskey, stores, array, 2);
+}
+
+int csr_read_pskey_uint32(int dd, uint16_t seqnum, uint16_t pskey, uint16_t stores, uint32_t *value)
+{
+	uint8_t array[4] = { 0x00, 0x00, 0x00, 0x00 };
+	int err;
+
+	err = csr_read_pskey_complex(dd, seqnum, pskey, stores, array, 4);
+
+	*value = ((array[0] + (array[1] << 8)) << 16) +
+						(array[2] + (array[3] << 8));
+
+	return err;
+}
+
+int csr_write_pskey_uint32(int dd, uint16_t seqnum, uint16_t pskey, uint16_t stores, uint32_t value)
+{
+	uint8_t array[4] = { (value & 0xff0000) >> 16, value >> 24,
+					value & 0xff, (value & 0xff00) >> 8 };
+
+	return csr_write_pskey_complex(dd, seqnum, pskey, stores, array, 4);
+}
+
+int psr_put(uint16_t pskey, uint8_t *value, uint16_t size)
+{
+	struct psr_data *item;
+
+	item = malloc(sizeof(*item));
+	if (!item)
+		return -ENOMEM;
+
+	item->pskey = pskey;
+
+	if (size > 0) {
+		item->value = malloc(size);
+		if (!item->value) {
+			free(item);
+			return -ENOMEM;
+		}
+
+		memcpy(item->value, value, size);
+		item->size = size;
+	} else {
+		item->value = NULL;
+		item->size = 0;
+	}
+
+	item->next = NULL;
+
+	if (!head)
+		head = item;
+	else
+		tail->next = item;
+
+	tail = item;
+
+	return 0;
+}
+
+int psr_get(uint16_t *pskey, uint8_t *value, uint16_t *size)
+{
+	struct psr_data *item = head;
+
+	if (!head)
+		return -ENOENT;
+
+	*pskey = item->pskey;
+
+	if (item->value) {
+		if (value && item->size > 0)
+			memcpy(value, item->value, item->size);
+		free(item->value);
+		*size = item->size;
+	} else
+		*size = 0;
+
+	if (head == tail)
+		tail = NULL;
+
+	head = head->next;
+	free(item);
+
+	return 0;
+}
+
+static int parse_line(char *str)
+{
+	uint8_t array[256];
+	uint16_t value, pskey, length = 0;
+	char *off, *end;
+
+	pskey = strtol(str + 1, NULL, 16);
+	off = strstr(str, "=");
+	if (!off)
+		return -EIO;
+
+	off++;
+
+	while (length <= sizeof(array) - 2) {
+		value = strtol(off, &end, 16);
+		if (value == 0 && off == end)
+			break;
+
+		array[length++] = value & 0xff;
+		array[length++] = value >> 8;
+
+		if (*end == '\0')
+			break;
+
+		off = end + 1;
+	}
+
+	return psr_put(pskey, array, length);
+}
+
+int psr_read(const char *filename)
+{
+	struct stat st;
+	char *str, *map, *off, *end;
+	int fd, err = 0;
+
+	fd = open(filename, O_RDONLY);
+	if (fd < 0)
+		return fd;
+
+	if (fstat(fd, &st) < 0) {
+		err = -errno;
+		goto close;
+	}
+
+	map = mmap(0, st.st_size, PROT_READ, MAP_SHARED, fd, 0);
+	if (!map || map == MAP_FAILED) {
+		err = -errno;
+		goto close;
+	}
+
+	off = map;
+
+	while (1) {
+		if (*off == '\r' || *off == '\n') {
+			off++;
+			continue;
+		}
+
+		end = strpbrk(off, "\r\n");
+		if (!end)
+			break;
+
+		str = malloc(end - off + 1);
+		if (!str)
+			break;
+
+		memset(str, 0, end - off + 1);
+		strncpy(str, off, end - off);
+		if (*str == '&')
+			parse_line(str);
+
+		free(str);
+		off = end + 1;
+	}
+
+	munmap(map, st.st_size);
+
+close:
+	close(fd);
+
+	return err;
+}
+
+int psr_print(void)
+{
+	uint8_t array[256];
+	uint16_t pskey, length;
+	char *str, val[7];
+	int i;
+
+	while (1) {
+		if (psr_get(&pskey, array, &length) < 0)
+			break;
+
+		str = csr_pskeytoval(pskey);
+		if (!strcasecmp(str, "UNKNOWN")) {
+			sprintf(val, "0x%04x", pskey);
+			str = NULL;
+		}
+
+		printf("// %s%s\n&%04x =", str ? "PSKEY_" : "",
+						str ? str : val, pskey);
+		for (i = 0; i < length / 2; i++)
+			printf(" %02x%02x", array[i * 2 + 1], array[i * 2]);
+		printf("\n");
+	}
+
+	return 0;
+}
diff --git a/tools/csr.h b/tools/csr.h
new file mode 100644
index 000000000..cc245a550
--- /dev/null
+++ b/tools/csr.h
@@ -0,0 +1,555 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2003-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <stdint.h>
+#include <termios.h>
+
+#define CSR_VARID_PS_CLR_ALL			0x000b	/* valueless */
+#define CSR_VARID_PS_FACTORY_SET		0x000c	/* valueless */
+#define CSR_VARID_PS_CLR_ALL_STORES		0x082d	/* uint16 */
+#define CSR_VARID_BC01_STATUS			0x2801	/* uint16 */
+#define CSR_VARID_BUILDID			0x2819	/* uint16 */
+#define CSR_VARID_CHIPVER			0x281a	/* uint16 */
+#define CSR_VARID_CHIPREV			0x281b	/* uint16 */
+#define CSR_VARID_INTERFACE_VERSION		0x2825	/* uint16 */
+#define CSR_VARID_RAND				0x282a	/* uint16 */
+#define CSR_VARID_MAX_CRYPT_KEY_LENGTH		0x282c	/* uint16 */
+#define CSR_VARID_CHIPANAREV			0x2836	/* uint16 */
+#define CSR_VARID_BUILDID_LOADER		0x2838	/* uint16 */
+#define CSR_VARID_BT_CLOCK			0x2c00	/* uint32 */
+#define CSR_VARID_PS_NEXT			0x3005	/* complex */
+#define CSR_VARID_PS_SIZE			0x3006	/* complex */
+#define CSR_VARID_ADC_RES			0x3007	/* complex */
+#define CSR_VARID_CRYPT_KEY_LENGTH		0x3008	/* complex */
+#define CSR_VARID_PICONET_INSTANCE		0x3009	/* complex */
+#define CSR_VARID_GET_CLR_EVT			0x300a	/* complex */
+#define CSR_VARID_GET_NEXT_BUILDDEF		0x300b	/* complex */
+#define CSR_VARID_PS_MEMORY_TYPE		0x3012	/* complex */
+#define CSR_VARID_READ_BUILD_NAME		0x301c	/* complex */
+#define CSR_VARID_COLD_RESET			0x4001	/* valueless */
+#define CSR_VARID_WARM_RESET			0x4002	/* valueless */
+#define CSR_VARID_COLD_HALT			0x4003	/* valueless */
+#define CSR_VARID_WARM_HALT			0x4004	/* valueless */
+#define CSR_VARID_INIT_BT_STACK			0x4005	/* valueless */
+#define CSR_VARID_ACTIVATE_BT_STACK		0x4006	/* valueless */
+#define CSR_VARID_ENABLE_TX			0x4007	/* valueless */
+#define CSR_VARID_DISABLE_TX			0x4008	/* valueless */
+#define CSR_VARID_RECAL				0x4009	/* valueless */
+#define CSR_VARID_PS_FACTORY_RESTORE		0x400d	/* valueless */
+#define CSR_VARID_PS_FACTORY_RESTORE_ALL	0x400e	/* valueless */
+#define CSR_VARID_PS_DEFRAG_RESET		0x400f	/* valueless */
+#define CSR_VARID_KILL_VM_APPLICATION		0x4010	/* valueless */
+#define CSR_VARID_HOPPING_ON			0x4011	/* valueless */
+#define CSR_VARID_CANCEL_PAGE			0x4012	/* valueless */
+#define CSR_VARID_PS_CLR			0x4818	/* uint16 */
+#define CSR_VARID_MAP_SCO_PCM			0x481c	/* uint16 */
+#define CSR_VARID_ADC				0x4829	/* uint16 */
+#define CSR_VARID_SINGLE_CHAN			0x482e	/* uint16 */
+#define CSR_VARID_RADIOTEST			0x5004	/* complex */
+#define CSR_VARID_PS_CLR_STORES			0x500c	/* complex */
+#define CSR_VARID_NO_VARIABLE			0x6000	/* valueless */
+#define CSR_VARID_CONFIG_UART			0x6802	/* uint16 */
+#define CSR_VARID_PANIC_ARG			0x6805	/* uint16 */
+#define CSR_VARID_FAULT_ARG			0x6806	/* uint16 */
+#define CSR_VARID_MAX_TX_POWER			0x6827	/* int8 */
+#define CSR_VARID_DEFAULT_TX_POWER		0x682b	/* int8 */
+#define CSR_VARID_PS				0x7003	/* complex */
+
+#define CSR_PSKEY_BDADDR					0x0001	/* bdaddr / uint16[] = { 0x00A5A5, 0x5b, 0x0002 } */
+#define CSR_PSKEY_COUNTRYCODE					0x0002	/* uint16 */
+#define CSR_PSKEY_CLASSOFDEVICE					0x0003	/* bdcod */
+#define CSR_PSKEY_DEVICE_DRIFT					0x0004	/* uint16 */
+#define CSR_PSKEY_DEVICE_JITTER					0x0005	/* uint16 */
+#define CSR_PSKEY_MAX_ACLS					0x000d	/* uint16 */
+#define CSR_PSKEY_MAX_SCOS					0x000e	/* uint16 */
+#define CSR_PSKEY_MAX_REMOTE_MASTERS				0x000f	/* uint16 */
+#define CSR_PSKEY_ENABLE_MASTERY_WITH_SLAVERY			0x0010	/* bool */
+#define CSR_PSKEY_H_HC_FC_MAX_ACL_PKT_LEN			0x0011	/* uint16 */
+#define CSR_PSKEY_H_HC_FC_MAX_SCO_PKT_LEN			0x0012	/* uint8 */
+#define CSR_PSKEY_H_HC_FC_MAX_ACL_PKTS				0x0013	/* uint16 */
+#define CSR_PSKEY_H_HC_FC_MAX_SCO_PKTS				0x0014	/* uint16 */
+#define CSR_PSKEY_LC_FC_BUFFER_LOW_WATER_MARK			0x0015	/* lc_fc_lwm */
+#define CSR_PSKEY_LC_MAX_TX_POWER				0x0017	/* int16 */
+#define CSR_PSKEY_TX_GAIN_RAMP					0x001d	/* uint16 */
+#define CSR_PSKEY_LC_POWER_TABLE				0x001e	/* power_setting[] */
+#define CSR_PSKEY_LC_PEER_POWER_PERIOD				0x001f	/* TIME */
+#define CSR_PSKEY_LC_FC_POOLS_LOW_WATER_MARK			0x0020	/* lc_fc_lwm */
+#define CSR_PSKEY_LC_DEFAULT_TX_POWER				0x0021	/* int16 */
+#define CSR_PSKEY_LC_RSSI_GOLDEN_RANGE				0x0022	/* uint8 */
+#define CSR_PSKEY_LC_COMBO_DISABLE_PIO_MASK			0x0028	/* uint16[] */
+#define CSR_PSKEY_LC_COMBO_PRIORITY_PIO_MASK			0x0029	/* uint16[] */
+#define CSR_PSKEY_LC_COMBO_DOT11_CHANNEL_PIO_BASE		0x002a	/* uint16 */
+#define CSR_PSKEY_LC_COMBO_DOT11_BLOCK_CHANNELS			0x002b	/* uint16 */
+#define CSR_PSKEY_LC_MAX_TX_POWER_NO_RSSI			0x002d	/* int8 */
+#define CSR_PSKEY_LC_CONNECTION_RX_WINDOW			0x002e	/* uint16 */
+#define CSR_PSKEY_LC_COMBO_DOT11_TX_PROTECTION_MODE		0x0030	/* uint16 */
+#define CSR_PSKEY_LC_ENHANCED_POWER_TABLE			0x0031	/* enhanced_power_setting[] */
+#define CSR_PSKEY_LC_WIDEBAND_RSSI_CONFIG			0x0032	/* wideband_rssi_config */
+#define CSR_PSKEY_LC_COMBO_DOT11_PRIORITY_LEAD			0x0033	/* uint16 */
+#define CSR_PSKEY_BT_CLOCK_INIT					0x0034	/* uint32 */
+#define CSR_PSKEY_TX_MR_MOD_DELAY				0x0038	/* uint8 */
+#define CSR_PSKEY_RX_MR_SYNC_TIMING				0x0039	/* uint16 */
+#define CSR_PSKEY_RX_MR_SYNC_CONFIG				0x003a	/* uint16 */
+#define CSR_PSKEY_LC_LOST_SYNC_SLOTS				0x003b	/* uint16 */
+#define CSR_PSKEY_RX_MR_SAMP_CONFIG				0x003c	/* uint16 */
+#define CSR_PSKEY_AGC_HYST_LEVELS				0x003d	/* agc_hyst_config */
+#define CSR_PSKEY_RX_LEVEL_LOW_SIGNAL				0x003e	/* uint16 */
+#define CSR_PSKEY_AGC_IQ_LVL_VALUES				0x003f	/* IQ_LVL_VAL[] */
+#define CSR_PSKEY_MR_FTRIM_OFFSET_12DB				0x0040	/* uint16 */
+#define CSR_PSKEY_MR_FTRIM_OFFSET_6DB				0x0041	/* uint16 */
+#define CSR_PSKEY_NO_CAL_ON_BOOT				0x0042	/* bool */
+#define CSR_PSKEY_RSSI_HI_TARGET				0x0043	/* uint8 */
+#define CSR_PSKEY_PREFERRED_MIN_ATTENUATION			0x0044	/* uint8 */
+#define CSR_PSKEY_LC_COMBO_DOT11_PRIORITY_OVERRIDE		0x0045	/* bool */
+#define CSR_PSKEY_LC_MULTISLOT_HOLDOFF				0x0047	/* TIME */
+#define CSR_PSKEY_FREE_KEY_PIGEON_HOLE				0x00c9	/* uint16 */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR0				0x00ca	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR1				0x00cb	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR2				0x00cc	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR3				0x00cd	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR4				0x00ce	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR5				0x00cf	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR6				0x00d0	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR7				0x00d1	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR8				0x00d2	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR9				0x00d3	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR10				0x00d4	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR11				0x00d5	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR12				0x00d6	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR13				0x00d7	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR14				0x00d8	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LINK_KEY_BD_ADDR15				0x00d9	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_ENC_KEY_LMIN					0x00da	/* uint16 */
+#define CSR_PSKEY_ENC_KEY_LMAX					0x00db	/* uint16 */
+#define CSR_PSKEY_LOCAL_SUPPORTED_FEATURES			0x00ef	/* uint16[] = { 0xffff, 0xfe8f, 0xf99b, 0x8000 }*/
+#define CSR_PSKEY_LM_USE_UNIT_KEY				0x00f0	/* bool */
+#define CSR_PSKEY_HCI_NOP_DISABLE				0x00f2	/* bool */
+#define CSR_PSKEY_LM_MAX_EVENT_FILTERS				0x00f4	/* uint8 */
+#define CSR_PSKEY_LM_USE_ENC_MODE_BROADCAST			0x00f5	/* bool */
+#define CSR_PSKEY_LM_TEST_SEND_ACCEPTED_TWICE			0x00f6	/* bool */
+#define CSR_PSKEY_LM_MAX_PAGE_HOLD_TIME				0x00f7	/* uint16 */
+#define CSR_PSKEY_AFH_ADAPTATION_RESPONSE_TIME			0x00f8	/* uint16 */
+#define CSR_PSKEY_AFH_OPTIONS					0x00f9	/* uint16 */
+#define CSR_PSKEY_AFH_RSSI_RUN_PERIOD				0x00fa	/* uint16 */
+#define CSR_PSKEY_AFH_REENABLE_CHANNEL_TIME			0x00fb	/* uint16 */
+#define CSR_PSKEY_NO_DROP_ON_ACR_MS_FAIL			0x00fc	/* bool */
+#define CSR_PSKEY_MAX_PRIVATE_KEYS				0x00fd	/* uint8 */
+#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR0			0x00fe	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR1			0x00ff	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR2			0x0100	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR3			0x0101	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR4			0x0102	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR5			0x0103	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR6			0x0104	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_PRIVATE_LINK_KEY_BD_ADDR7			0x0105	/* LM_LINK_KEY_BD_ADDR_T */
+#define CSR_PSKEY_LOCAL_SUPPORTED_COMMANDS			0x0106	/* uint16[] = { 0xffff, 0x03ff, 0xfffe, 0xffff, 0xffff, 0xffff, 0x0ff3, 0xfff8, 0x003f } */
+#define CSR_PSKEY_LM_MAX_ABSENCE_INDEX				0x0107	/* uint8 */
+#define CSR_PSKEY_DEVICE_NAME					0x0108	/* uint16[] */
+#define CSR_PSKEY_AFH_RSSI_THRESHOLD				0x0109	/* uint16 */
+#define CSR_PSKEY_LM_CASUAL_SCAN_INTERVAL			0x010a	/* uint16 */
+#define CSR_PSKEY_AFH_MIN_MAP_CHANGE				0x010b	/* uint16[] */
+#define CSR_PSKEY_AFH_RSSI_LP_RUN_PERIOD			0x010c	/* uint16 */
+#define CSR_PSKEY_HCI_LMP_LOCAL_VERSION				0x010d	/* uint16 */
+#define CSR_PSKEY_LMP_REMOTE_VERSION				0x010e	/* uint8 */
+#define CSR_PSKEY_HOLD_ERROR_MESSAGE_NUMBER			0x0113	/* uint16 */
+#define CSR_PSKEY_DFU_ATTRIBUTES				0x0136	/* uint8 */
+#define CSR_PSKEY_DFU_DETACH_TO					0x0137	/* uint16 */
+#define CSR_PSKEY_DFU_TRANSFER_SIZE				0x0138	/* uint16 */
+#define CSR_PSKEY_DFU_ENABLE					0x0139	/* bool */
+#define CSR_PSKEY_DFU_LIN_REG_ENABLE				0x013a	/* bool */
+#define CSR_PSKEY_DFUENC_VMAPP_PK_MODULUS_MSB			0x015e	/* uint16[] */
+#define CSR_PSKEY_DFUENC_VMAPP_PK_MODULUS_LSB			0x015f	/* uint16[] */
+#define CSR_PSKEY_DFUENC_VMAPP_PK_M_DASH			0x0160	/* uint16 */
+#define CSR_PSKEY_DFUENC_VMAPP_PK_R2N_MSB			0x0161	/* uint16[] */
+#define CSR_PSKEY_DFUENC_VMAPP_PK_R2N_LSB			0x0162	/* uint16[] */
+#define CSR_PSKEY_BCSP_LM_PS_BLOCK				0x0192	/* BCSP_LM_PS_BLOCK */
+#define CSR_PSKEY_HOSTIO_FC_PS_BLOCK				0x0193	/* HOSTIO_FC_PS_BLOCK */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO0				0x0194	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO1				0x0195	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO2				0x0196	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO3				0x0197	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO4				0x0198	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO5				0x0199	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO6				0x019a	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO7				0x019b	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO8				0x019c	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO9				0x019d	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO10			0x019e	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO11			0x019f	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO12			0x01a0	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO13			0x01a1	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO14			0x01a2	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_PROTOCOL_INFO15			0x01a3	/* PROTOCOL_INFO */
+#define CSR_PSKEY_HOSTIO_UART_RESET_TIMEOUT			0x01a4	/* TIME */
+#define CSR_PSKEY_HOSTIO_USE_HCI_EXTN				0x01a5	/* bool */
+#define CSR_PSKEY_HOSTIO_USE_HCI_EXTN_CCFC			0x01a6	/* bool */
+#define CSR_PSKEY_HOSTIO_HCI_EXTN_PAYLOAD_SIZE			0x01a7	/* uint16 */
+#define CSR_PSKEY_BCSP_LM_CNF_CNT_LIMIT				0x01aa	/* uint16 */
+#define CSR_PSKEY_HOSTIO_MAP_SCO_PCM				0x01ab	/* bool */
+#define CSR_PSKEY_HOSTIO_AWKWARD_PCM_SYNC			0x01ac	/* bool */
+#define CSR_PSKEY_HOSTIO_BREAK_POLL_PERIOD			0x01ad	/* TIME */
+#define CSR_PSKEY_HOSTIO_MIN_UART_HCI_SCO_SIZE			0x01ae	/* uint16 */
+#define CSR_PSKEY_HOSTIO_MAP_SCO_CODEC				0x01b0	/* bool */
+#define CSR_PSKEY_PCM_CVSD_TX_HI_FREQ_BOOST			0x01b1	/* uint16 */
+#define CSR_PSKEY_PCM_CVSD_RX_HI_FREQ_BOOST			0x01b2	/* uint16 */
+#define CSR_PSKEY_PCM_CONFIG32					0x01b3	/* uint32 */
+#define CSR_PSKEY_USE_OLD_BCSP_LE				0x01b4	/* uint16 */
+#define CSR_PSKEY_PCM_CVSD_USE_NEW_FILTER			0x01b5	/* bool */
+#define CSR_PSKEY_PCM_FORMAT					0x01b6	/* uint16 */
+#define CSR_PSKEY_CODEC_OUT_GAIN				0x01b7	/* uint16 */
+#define CSR_PSKEY_CODEC_IN_GAIN					0x01b8	/* uint16 */
+#define CSR_PSKEY_CODEC_PIO					0x01b9	/* uint16 */
+#define CSR_PSKEY_PCM_LOW_JITTER_CONFIG				0x01ba	/* uint32 */
+#define CSR_PSKEY_HOSTIO_SCO_PCM_THRESHOLDS			0x01bb	/* uint16[] */
+#define CSR_PSKEY_HOSTIO_SCO_HCI_THRESHOLDS			0x01bc	/* uint16[] */
+#define CSR_PSKEY_HOSTIO_MAP_SCO_PCM_SLOT			0x01bd	/* uint16 */
+#define CSR_PSKEY_UART_BAUDRATE					0x01be	/* uint16 */
+#define CSR_PSKEY_UART_CONFIG_BCSP				0x01bf	/* uint16 */
+#define CSR_PSKEY_UART_CONFIG_H4				0x01c0	/* uint16 */
+#define CSR_PSKEY_UART_CONFIG_H5				0x01c1	/* uint16 */
+#define CSR_PSKEY_UART_CONFIG_USR				0x01c2	/* uint16 */
+#define CSR_PSKEY_UART_TX_CRCS					0x01c3	/* bool */
+#define CSR_PSKEY_UART_ACK_TIMEOUT				0x01c4	/* uint16 */
+#define CSR_PSKEY_UART_TX_MAX_ATTEMPTS				0x01c5	/* uint16 */
+#define CSR_PSKEY_UART_TX_WINDOW_SIZE				0x01c6	/* uint16 */
+#define CSR_PSKEY_UART_HOST_WAKE				0x01c7	/* uint16[] */
+#define CSR_PSKEY_HOSTIO_THROTTLE_TIMEOUT			0x01c8	/* TIME */
+#define CSR_PSKEY_PCM_ALWAYS_ENABLE				0x01c9	/* bool */
+#define CSR_PSKEY_UART_HOST_WAKE_SIGNAL				0x01ca	/* uint16 */
+#define CSR_PSKEY_UART_CONFIG_H4DS				0x01cb	/* uint16 */
+#define CSR_PSKEY_H4DS_WAKE_DURATION				0x01cc	/* uint16 */
+#define CSR_PSKEY_H4DS_MAXWU					0x01cd	/* uint16 */
+#define CSR_PSKEY_H4DS_LE_TIMER_PERIOD				0x01cf	/* uint16 */
+#define CSR_PSKEY_H4DS_TWU_TIMER_PERIOD				0x01d0	/* uint16 */
+#define CSR_PSKEY_H4DS_UART_IDLE_TIMER_PERIOD			0x01d1	/* uint16 */
+#define CSR_PSKEY_ANA_FTRIM					0x01f6	/* uint16 */
+#define CSR_PSKEY_WD_TIMEOUT					0x01f7	/* TIME */
+#define CSR_PSKEY_WD_PERIOD					0x01f8	/* TIME */
+#define CSR_PSKEY_HOST_INTERFACE				0x01f9	/* phys_bus */
+#define CSR_PSKEY_HQ_HOST_TIMEOUT				0x01fb	/* TIME */
+#define CSR_PSKEY_HQ_ACTIVE					0x01fc	/* bool */
+#define CSR_PSKEY_BCCMD_SECURITY_ACTIVE				0x01fd	/* bool */
+#define CSR_PSKEY_ANA_FREQ					0x01fe	/* uint16 */
+#define CSR_PSKEY_PIO_PROTECT_MASK				0x0202	/* uint16 */
+#define CSR_PSKEY_PMALLOC_SIZES					0x0203	/* uint16[] */
+#define CSR_PSKEY_UART_BAUD_RATE				0x0204	/* uint16 */
+#define CSR_PSKEY_UART_CONFIG					0x0205	/* uint16 */
+#define CSR_PSKEY_STUB						0x0207	/* uint16 */
+#define CSR_PSKEY_TXRX_PIO_CONTROL				0x0209	/* uint16 */
+#define CSR_PSKEY_ANA_RX_LEVEL					0x020b	/* uint16 */
+#define CSR_PSKEY_ANA_RX_FTRIM					0x020c	/* uint16 */
+#define CSR_PSKEY_PSBC_DATA_VERSION				0x020d	/* uint16 */
+#define CSR_PSKEY_PCM0_ATTENUATION				0x020f	/* uint16 */
+#define CSR_PSKEY_LO_LVL_MAX					0x0211	/* uint16 */
+#define CSR_PSKEY_LO_ADC_AMPL_MIN				0x0212	/* uint16 */
+#define CSR_PSKEY_LO_ADC_AMPL_MAX				0x0213	/* uint16 */
+#define CSR_PSKEY_IQ_TRIM_CHANNEL				0x0214	/* uint16 */
+#define CSR_PSKEY_IQ_TRIM_GAIN					0x0215	/* uint16 */
+#define CSR_PSKEY_IQ_TRIM_ENABLE				0x0216	/* iq_trim_enable_flag */
+#define CSR_PSKEY_TX_OFFSET_HALF_MHZ				0x0217	/* int16 */
+#define CSR_PSKEY_GBL_MISC_ENABLES				0x0221	/* uint16 */
+#define CSR_PSKEY_UART_SLEEP_TIMEOUT				0x0222	/* uint16 */
+#define CSR_PSKEY_DEEP_SLEEP_STATE				0x0229	/* deep_sleep_state */
+#define CSR_PSKEY_IQ_ENABLE_PHASE_TRIM				0x022d	/* bool */
+#define CSR_PSKEY_HCI_HANDLE_FREEZE_PERIOD			0x0237	/* TIME */
+#define CSR_PSKEY_MAX_FROZEN_HCI_HANDLES			0x0238	/* uint16 */
+#define CSR_PSKEY_PAGETABLE_DESTRUCTION_DELAY			0x0239	/* TIME */
+#define CSR_PSKEY_IQ_TRIM_PIO_SETTINGS				0x023a	/* uint8 */
+#define CSR_PSKEY_USE_EXTERNAL_CLOCK				0x023b	/* bool */
+#define CSR_PSKEY_DEEP_SLEEP_WAKE_CTS				0x023c	/* uint16 */
+#define CSR_PSKEY_FC_HC2H_FLUSH_DELAY				0x023d	/* TIME */
+#define CSR_PSKEY_RX_HIGHSIDE					0x023e	/* bool */
+#define CSR_PSKEY_TX_PRE_LVL					0x0240	/* uint8 */
+#define CSR_PSKEY_RX_SINGLE_ENDED				0x0242	/* bool */
+#define CSR_PSKEY_TX_FILTER_CONFIG				0x0243	/* uint32 */
+#define CSR_PSKEY_CLOCK_REQUEST_ENABLE				0x0246	/* uint16 */
+#define CSR_PSKEY_RX_MIN_ATTEN					0x0249	/* uint16 */
+#define CSR_PSKEY_XTAL_TARGET_AMPLITUDE				0x024b	/* uint8 */
+#define CSR_PSKEY_PCM_MIN_CPU_CLOCK				0x024d	/* uint16 */
+#define CSR_PSKEY_HOST_INTERFACE_PIO_USB			0x0250	/* uint16 */
+#define CSR_PSKEY_CPU_IDLE_MODE					0x0251	/* cpu_idle_mode */
+#define CSR_PSKEY_DEEP_SLEEP_CLEAR_RTS				0x0252	/* bool */
+#define CSR_PSKEY_RF_RESONANCE_TRIM				0x0254	/* uint16 */
+#define CSR_PSKEY_DEEP_SLEEP_PIO_WAKE				0x0255	/* uint16 */
+#define CSR_PSKEY_DRAIN_BORE_TIMERS				0x0256	/* uint32[] */
+#define CSR_PSKEY_DRAIN_TX_POWER_BASE				0x0257	/* uint16 */
+#define CSR_PSKEY_MODULE_ID					0x0259	/* uint32 */
+#define CSR_PSKEY_MODULE_DESIGN					0x025a	/* uint16 */
+#define CSR_PSKEY_MODULE_SECURITY_CODE				0x025c	/* uint16[] */
+#define CSR_PSKEY_VM_DISABLE					0x025d	/* bool */
+#define CSR_PSKEY_MOD_MANUF0					0x025e	/* uint16[] */
+#define CSR_PSKEY_MOD_MANUF1					0x025f	/* uint16[] */
+#define CSR_PSKEY_MOD_MANUF2					0x0260	/* uint16[] */
+#define CSR_PSKEY_MOD_MANUF3					0x0261	/* uint16[] */
+#define CSR_PSKEY_MOD_MANUF4					0x0262	/* uint16[] */
+#define CSR_PSKEY_MOD_MANUF5					0x0263	/* uint16[] */
+#define CSR_PSKEY_MOD_MANUF6					0x0264	/* uint16[] */
+#define CSR_PSKEY_MOD_MANUF7					0x0265	/* uint16[] */
+#define CSR_PSKEY_MOD_MANUF8					0x0266	/* uint16[] */
+#define CSR_PSKEY_MOD_MANUF9					0x0267	/* uint16[] */
+#define CSR_PSKEY_DUT_VM_DISABLE				0x0268	/* bool */
+#define CSR_PSKEY_USR0						0x028a	/* uint16[] */
+#define CSR_PSKEY_USR1						0x028b	/* uint16[] */
+#define CSR_PSKEY_USR2						0x028c	/* uint16[] */
+#define CSR_PSKEY_USR3						0x028d	/* uint16[] */
+#define CSR_PSKEY_USR4						0x028e	/* uint16[] */
+#define CSR_PSKEY_USR5						0x028f	/* uint16[] */
+#define CSR_PSKEY_USR6						0x0290	/* uint16[] */
+#define CSR_PSKEY_USR7						0x0291	/* uint16[] */
+#define CSR_PSKEY_USR8						0x0292	/* uint16[] */
+#define CSR_PSKEY_USR9						0x0293	/* uint16[] */
+#define CSR_PSKEY_USR10						0x0294	/* uint16[] */
+#define CSR_PSKEY_USR11						0x0295	/* uint16[] */
+#define CSR_PSKEY_USR12						0x0296	/* uint16[] */
+#define CSR_PSKEY_USR13						0x0297	/* uint16[] */
+#define CSR_PSKEY_USR14						0x0298	/* uint16[] */
+#define CSR_PSKEY_USR15						0x0299	/* uint16[] */
+#define CSR_PSKEY_USR16						0x029a	/* uint16[] */
+#define CSR_PSKEY_USR17						0x029b	/* uint16[] */
+#define CSR_PSKEY_USR18						0x029c	/* uint16[] */
+#define CSR_PSKEY_USR19						0x029d	/* uint16[] */
+#define CSR_PSKEY_USR20						0x029e	/* uint16[] */
+#define CSR_PSKEY_USR21						0x029f	/* uint16[] */
+#define CSR_PSKEY_USR22						0x02a0	/* uint16[] */
+#define CSR_PSKEY_USR23						0x02a1	/* uint16[] */
+#define CSR_PSKEY_USR24						0x02a2	/* uint16[] */
+#define CSR_PSKEY_USR25						0x02a3	/* uint16[] */
+#define CSR_PSKEY_USR26						0x02a4	/* uint16[] */
+#define CSR_PSKEY_USR27						0x02a5	/* uint16[] */
+#define CSR_PSKEY_USR28						0x02a6	/* uint16[] */
+#define CSR_PSKEY_USR29						0x02a7	/* uint16[] */
+#define CSR_PSKEY_USR30						0x02a8	/* uint16[] */
+#define CSR_PSKEY_USR31						0x02a9	/* uint16[] */
+#define CSR_PSKEY_USR32						0x02aa	/* uint16[] */
+#define CSR_PSKEY_USR33						0x02ab	/* uint16[] */
+#define CSR_PSKEY_USR34						0x02ac	/* uint16[] */
+#define CSR_PSKEY_USR35						0x02ad	/* uint16[] */
+#define CSR_PSKEY_USR36						0x02ae	/* uint16[] */
+#define CSR_PSKEY_USR37						0x02af	/* uint16[] */
+#define CSR_PSKEY_USR38						0x02b0	/* uint16[] */
+#define CSR_PSKEY_USR39						0x02b1	/* uint16[] */
+#define CSR_PSKEY_USR40						0x02b2	/* uint16[] */
+#define CSR_PSKEY_USR41						0x02b3	/* uint16[] */
+#define CSR_PSKEY_USR42						0x02b4	/* uint16[] */
+#define CSR_PSKEY_USR43						0x02b5	/* uint16[] */
+#define CSR_PSKEY_USR44						0x02b6	/* uint16[] */
+#define CSR_PSKEY_USR45						0x02b7	/* uint16[] */
+#define CSR_PSKEY_USR46						0x02b8	/* uint16[] */
+#define CSR_PSKEY_USR47						0x02b9	/* uint16[] */
+#define CSR_PSKEY_USR48						0x02ba	/* uint16[] */
+#define CSR_PSKEY_USR49						0x02bb	/* uint16[] */
+#define CSR_PSKEY_USB_VERSION					0x02bc	/* uint16 */
+#define CSR_PSKEY_USB_DEVICE_CLASS_CODES			0x02bd	/* usbclass */
+#define CSR_PSKEY_USB_VENDOR_ID					0x02be	/* uint16 */
+#define CSR_PSKEY_USB_PRODUCT_ID				0x02bf	/* uint16 */
+#define CSR_PSKEY_USB_MANUF_STRING				0x02c1	/* unicodestring */
+#define CSR_PSKEY_USB_PRODUCT_STRING				0x02c2	/* unicodestring */
+#define CSR_PSKEY_USB_SERIAL_NUMBER_STRING			0x02c3	/* unicodestring */
+#define CSR_PSKEY_USB_CONFIG_STRING				0x02c4	/* unicodestring */
+#define CSR_PSKEY_USB_ATTRIBUTES				0x02c5	/* uint8 */
+#define CSR_PSKEY_USB_MAX_POWER					0x02c6	/* uint16 */
+#define CSR_PSKEY_USB_BT_IF_CLASS_CODES				0x02c7	/* usbclass */
+#define CSR_PSKEY_USB_LANGID					0x02c9	/* uint16 */
+#define CSR_PSKEY_USB_DFU_CLASS_CODES				0x02ca	/* usbclass */
+#define CSR_PSKEY_USB_DFU_PRODUCT_ID				0x02cb	/* uint16 */
+#define CSR_PSKEY_USB_PIO_DETACH				0x02ce	/* uint16 */
+#define CSR_PSKEY_USB_PIO_WAKEUP				0x02cf	/* uint16 */
+#define CSR_PSKEY_USB_PIO_PULLUP				0x02d0	/* uint16 */
+#define CSR_PSKEY_USB_PIO_VBUS					0x02d1	/* uint16 */
+#define CSR_PSKEY_USB_PIO_WAKE_TIMEOUT				0x02d2	/* uint16 */
+#define CSR_PSKEY_USB_PIO_RESUME				0x02d3	/* uint16 */
+#define CSR_PSKEY_USB_BT_SCO_IF_CLASS_CODES			0x02d4	/* usbclass */
+#define CSR_PSKEY_USB_SUSPEND_PIO_LEVEL				0x02d5	/* uint16 */
+#define CSR_PSKEY_USB_SUSPEND_PIO_DIR				0x02d6	/* uint16 */
+#define CSR_PSKEY_USB_SUSPEND_PIO_MASK				0x02d7	/* uint16 */
+#define CSR_PSKEY_USB_ENDPOINT_0_MAX_PACKET_SIZE		0x02d8	/* uint8 */
+#define CSR_PSKEY_USB_CONFIG					0x02d9	/* uint16 */
+#define CSR_PSKEY_RADIOTEST_ATTEN_INIT				0x0320	/* uint16 */
+#define CSR_PSKEY_RADIOTEST_FIRST_TRIM_TIME			0x0326	/* TIME */
+#define CSR_PSKEY_RADIOTEST_SUBSEQUENT_TRIM_TIME		0x0327	/* TIME */
+#define CSR_PSKEY_RADIOTEST_LO_LVL_TRIM_ENABLE			0x0328	/* bool */
+#define CSR_PSKEY_RADIOTEST_DISABLE_MODULATION			0x032c	/* bool */
+#define CSR_PSKEY_RFCOMM_FCON_THRESHOLD				0x0352	/* uint16 */
+#define CSR_PSKEY_RFCOMM_FCOFF_THRESHOLD			0x0353	/* uint16 */
+#define CSR_PSKEY_IPV6_STATIC_ADDR				0x0354	/* uint16[] */
+#define CSR_PSKEY_IPV4_STATIC_ADDR				0x0355	/* uint32 */
+#define CSR_PSKEY_IPV6_STATIC_PREFIX_LEN			0x0356	/* uint8 */
+#define CSR_PSKEY_IPV6_STATIC_ROUTER_ADDR			0x0357	/* uint16[] */
+#define CSR_PSKEY_IPV4_STATIC_SUBNET_MASK			0x0358	/* uint32 */
+#define CSR_PSKEY_IPV4_STATIC_ROUTER_ADDR			0x0359	/* uint32 */
+#define CSR_PSKEY_MDNS_NAME					0x035a	/* char[] */
+#define CSR_PSKEY_FIXED_PIN					0x035b	/* uint8[] */
+#define CSR_PSKEY_MDNS_PORT					0x035c	/* uint16 */
+#define CSR_PSKEY_MDNS_TTL					0x035d	/* uint8 */
+#define CSR_PSKEY_MDNS_IPV4_ADDR				0x035e	/* uint32 */
+#define CSR_PSKEY_ARP_CACHE_TIMEOUT				0x035f	/* uint16 */
+#define CSR_PSKEY_HFP_POWER_TABLE				0x0360	/* uint16[] */
+#define CSR_PSKEY_DRAIN_BORE_TIMER_COUNTERS			0x03e7	/* uint32[] */
+#define CSR_PSKEY_DRAIN_BORE_COUNTERS				0x03e6	/* uint32[] */
+#define CSR_PSKEY_LOOP_FILTER_TRIM				0x03e4	/* uint16 */
+#define CSR_PSKEY_DRAIN_BORE_CURRENT_PEAK			0x03e3	/* uint32[] */
+#define CSR_PSKEY_VM_E2_CACHE_LIMIT				0x03e2	/* uint16 */
+#define CSR_PSKEY_FORCE_16MHZ_REF_PIO				0x03e1	/* uint16 */
+#define CSR_PSKEY_CDMA_LO_REF_LIMITS				0x03df	/* uint16 */
+#define CSR_PSKEY_CDMA_LO_ERROR_LIMITS				0x03de	/* uint16 */
+#define CSR_PSKEY_CLOCK_STARTUP_DELAY				0x03dd	/* uint16 */
+#define CSR_PSKEY_DEEP_SLEEP_CORRECTION_FACTOR			0x03dc	/* int16 */
+#define CSR_PSKEY_TEMPERATURE_CALIBRATION			0x03db	/* temperature_calibration */
+#define CSR_PSKEY_TEMPERATURE_VS_DELTA_INTERNAL_PA		0x03da	/* temperature_calibration[] */
+#define CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_PRE_LVL		0x03d9	/* temperature_calibration[] */
+#define CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB			0x03d8	/* temperature_calibration[] */
+#define CSR_PSKEY_TEMPERATURE_VS_DELTA_ANA_FTRIM		0x03d7	/* temperature_calibration[] */
+#define CSR_PSKEY_TEST_DELTA_OFFSET				0x03d6	/* uint16 */
+#define CSR_PSKEY_RX_DYNAMIC_LVL_OFFSET				0x03d4	/* uint16 */
+#define CSR_PSKEY_TEST_FORCE_OFFSET				0x03d3	/* bool */
+#define CSR_PSKEY_RF_TRAP_BAD_DIVISION_RATIOS			0x03cf	/* uint16 */
+#define CSR_PSKEY_RADIOTEST_CDMA_LO_REF_LIMITS			0x03ce	/* uint16 */
+#define CSR_PSKEY_INITIAL_BOOTMODE				0x03cd	/* int16 */
+#define CSR_PSKEY_ONCHIP_HCI_CLIENT				0x03cc	/* bool */
+#define CSR_PSKEY_RX_ATTEN_BACKOFF				0x03ca	/* uint16 */
+#define CSR_PSKEY_RX_ATTEN_UPDATE_RATE				0x03c9	/* uint16 */
+#define CSR_PSKEY_SYNTH_TXRX_THRESHOLDS				0x03c7	/* uint16 */
+#define CSR_PSKEY_MIN_WAIT_STATES				0x03c6	/* uint16 */
+#define CSR_PSKEY_RSSI_CORRECTION				0x03c5	/* int8 */
+#define CSR_PSKEY_SCHED_THROTTLE_TIMEOUT			0x03c4	/* TIME */
+#define CSR_PSKEY_DEEP_SLEEP_USE_EXTERNAL_CLOCK			0x03c3	/* bool */
+#define CSR_PSKEY_TRIM_RADIO_FILTERS				0x03c2	/* uint16 */
+#define CSR_PSKEY_TRANSMIT_OFFSET				0x03c1	/* int16 */
+#define CSR_PSKEY_USB_VM_CONTROL				0x03c0	/* bool */
+#define CSR_PSKEY_MR_ANA_RX_FTRIM				0x03bf	/* uint16 */
+#define CSR_PSKEY_I2C_CONFIG					0x03be	/* uint16 */
+#define CSR_PSKEY_IQ_LVL_RX					0x03bd	/* uint16 */
+#define CSR_PSKEY_MR_TX_FILTER_CONFIG				0x03bb	/* uint32 */
+#define CSR_PSKEY_MR_TX_CONFIG2					0x03ba	/* uint16 */
+#define CSR_PSKEY_USB_DONT_RESET_BOOTMODE_ON_HOST_RESET		0x03b9	/* bool */
+#define CSR_PSKEY_LC_USE_THROTTLING				0x03b8	/* bool */
+#define CSR_PSKEY_CHARGER_TRIM					0x03b7	/* uint16 */
+#define CSR_PSKEY_CLOCK_REQUEST_FEATURES			0x03b6	/* uint16 */
+#define CSR_PSKEY_TRANSMIT_OFFSET_CLASS1			0x03b4	/* int16 */
+#define CSR_PSKEY_TX_AVOID_PA_CLASS1_PIO			0x03b3	/* uint16 */
+#define CSR_PSKEY_MR_PIO_CONFIG					0x03b2	/* uint16 */
+#define CSR_PSKEY_UART_CONFIG2					0x03b1	/* uint8 */
+#define CSR_PSKEY_CLASS1_IQ_LVL					0x03b0	/* uint16 */
+#define CSR_PSKEY_CLASS1_TX_CONFIG2				0x03af	/* uint16 */
+#define CSR_PSKEY_TEMPERATURE_VS_DELTA_INTERNAL_PA_CLASS1	0x03ae	/* temperature_calibration[] */
+#define CSR_PSKEY_TEMPERATURE_VS_DELTA_EXTERNAL_PA_CLASS1	0x03ad	/* temperature_calibration[] */
+#define CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_PRE_LVL_MR		0x03ac	/* temperature_calibration[] */
+#define CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB_MR_HEADER		0x03ab	/* temperature_calibration[] */
+#define CSR_PSKEY_TEMPERATURE_VS_DELTA_TX_BB_MR_PAYLOAD		0x03aa	/* temperature_calibration[] */
+#define CSR_PSKEY_RX_MR_EQ_TAPS					0x03a9	/* uint16[] */
+#define CSR_PSKEY_TX_PRE_LVL_CLASS1				0x03a8	/* uint8 */
+#define CSR_PSKEY_ANALOGUE_ATTENUATOR				0x03a7	/* bool */
+#define CSR_PSKEY_MR_RX_FILTER_TRIM				0x03a6	/* uint16 */
+#define CSR_PSKEY_MR_RX_FILTER_RESPONSE				0x03a5	/* int16[] */
+#define CSR_PSKEY_PIO_WAKEUP_STATE				0x039f	/* uint16 */
+#define CSR_PSKEY_MR_TX_IF_ATTEN_OFF_TEMP			0x0394	/* int16 */
+#define CSR_PSKEY_LO_DIV_LATCH_BYPASS				0x0393	/* bool */
+#define CSR_PSKEY_LO_VCO_STANDBY				0x0392	/* bool */
+#define CSR_PSKEY_SLOW_CLOCK_FILTER_SHIFT			0x0391	/* uint16 */
+#define CSR_PSKEY_SLOW_CLOCK_FILTER_DIVIDER			0x0390	/* uint16 */
+#define CSR_PSKEY_USB_ATTRIBUTES_POWER				0x03f2	/* bool */
+#define CSR_PSKEY_USB_ATTRIBUTES_WAKEUP				0x03f3	/* bool */
+#define CSR_PSKEY_DFU_ATTRIBUTES_MANIFESTATION_TOLERANT		0x03f4	/* bool */
+#define CSR_PSKEY_DFU_ATTRIBUTES_CAN_UPLOAD			0x03f5	/* bool */
+#define CSR_PSKEY_DFU_ATTRIBUTES_CAN_DOWNLOAD			0x03f6	/* bool */
+#define CSR_PSKEY_UART_CONFIG_STOP_BITS				0x03fc	/* bool */
+#define CSR_PSKEY_UART_CONFIG_PARITY_BIT			0x03fd	/* uint16 */
+#define CSR_PSKEY_UART_CONFIG_FLOW_CTRL_EN			0x03fe	/* bool */
+#define CSR_PSKEY_UART_CONFIG_RTS_AUTO_EN			0x03ff	/* bool */
+#define CSR_PSKEY_UART_CONFIG_RTS				0x0400	/* bool */
+#define CSR_PSKEY_UART_CONFIG_TX_ZERO_EN			0x0401	/* bool */
+#define CSR_PSKEY_UART_CONFIG_NON_BCSP_EN			0x0402	/* bool */
+#define CSR_PSKEY_UART_CONFIG_RX_RATE_DELAY			0x0403	/* uint16 */
+#define CSR_PSKEY_UART_SEQ_TIMEOUT				0x0405	/* uint16 */
+#define CSR_PSKEY_UART_SEQ_RETRIES				0x0406	/* uint16 */
+#define CSR_PSKEY_UART_SEQ_WINSIZE				0x0407	/* uint16 */
+#define CSR_PSKEY_UART_USE_CRC_ON_TX				0x0408	/* bool */
+#define CSR_PSKEY_UART_HOST_INITIAL_STATE			0x0409	/* hwakeup_state */
+#define CSR_PSKEY_UART_HOST_ATTENTION_SPAN			0x040a	/* uint16 */
+#define CSR_PSKEY_UART_HOST_WAKEUP_TIME				0x040b	/* uint16 */
+#define CSR_PSKEY_UART_HOST_WAKEUP_WAIT				0x040c	/* uint16 */
+#define CSR_PSKEY_BCSP_LM_MODE					0x0410	/* uint16 */
+#define CSR_PSKEY_BCSP_LM_SYNC_RETRIES				0x0411	/* uint16 */
+#define CSR_PSKEY_BCSP_LM_TSHY					0x0412	/* uint16 */
+#define CSR_PSKEY_UART_DFU_CONFIG_STOP_BITS			0x0417	/* bool */
+#define CSR_PSKEY_UART_DFU_CONFIG_PARITY_BIT			0x0418	/* uint16 */
+#define CSR_PSKEY_UART_DFU_CONFIG_FLOW_CTRL_EN			0x0419	/* bool */
+#define CSR_PSKEY_UART_DFU_CONFIG_RTS_AUTO_EN			0x041a	/* bool */
+#define CSR_PSKEY_UART_DFU_CONFIG_RTS				0x041b	/* bool */
+#define CSR_PSKEY_UART_DFU_CONFIG_TX_ZERO_EN			0x041c	/* bool */
+#define CSR_PSKEY_UART_DFU_CONFIG_NON_BCSP_EN			0x041d	/* bool */
+#define CSR_PSKEY_UART_DFU_CONFIG_RX_RATE_DELAY			0x041e	/* uint16 */
+#define CSR_PSKEY_AMUX_AIO0					0x041f	/* ana_amux_sel */
+#define CSR_PSKEY_AMUX_AIO1					0x0420	/* ana_amux_sel */
+#define CSR_PSKEY_AMUX_AIO2					0x0421	/* ana_amux_sel */
+#define CSR_PSKEY_AMUX_AIO3					0x0422	/* ana_amux_sel */
+#define CSR_PSKEY_LOCAL_NAME_SIMPLIFIED				0x0423	/* local_name_complete */
+#define CSR_PSKEY_EXTENDED_STUB					0x2001	/* uint16 */
+
+char *csr_builddeftostr(uint16_t def);
+char *csr_buildidtostr(uint16_t id);
+char *csr_chipvertostr(uint16_t ver, uint16_t rev);
+char *csr_pskeytostr(uint16_t pskey);
+char *csr_pskeytoval(uint16_t pskey);
+
+int csr_open_hci(char *device);
+int csr_read_hci(uint16_t varid, uint8_t *value, uint16_t length);
+int csr_write_hci(uint16_t varid, uint8_t *value, uint16_t length);
+void csr_close_hci(void);
+
+int csr_open_usb(char *device);
+int csr_read_usb(uint16_t varid, uint8_t *value, uint16_t length);
+int csr_write_usb(uint16_t varid, uint8_t *value, uint16_t length);
+void csr_close_usb(void);
+
+int csr_open_bcsp(char *device, speed_t bcsp_rate);
+int csr_read_bcsp(uint16_t varid, uint8_t *value, uint16_t length);
+int csr_write_bcsp(uint16_t varid, uint8_t *value, uint16_t length);
+void csr_close_bcsp(void);
+
+int csr_open_h4(char *device);
+int csr_read_h4(uint16_t varid, uint8_t *value, uint16_t length);
+int csr_write_h4(uint16_t varid, uint8_t *value, uint16_t length);
+void csr_close_h4(void);
+
+int csr_open_3wire(char *device);
+int csr_read_3wire(uint16_t varid, uint8_t *value, uint16_t length);
+int csr_write_3wire(uint16_t varid, uint8_t *value, uint16_t length);
+void csr_close_3wire(void);
+
+int csr_write_varid_valueless(int dd, uint16_t seqnum, uint16_t varid);
+int csr_write_varid_complex(int dd, uint16_t seqnum, uint16_t varid, uint8_t *value, uint16_t length);
+int csr_read_varid_complex(int dd, uint16_t seqnum, uint16_t varid, uint8_t *value, uint16_t length);
+int csr_read_varid_uint16(int dd, uint16_t seqnum, uint16_t varid, uint16_t *value);
+int csr_read_varid_uint32(int dd, uint16_t seqnum, uint16_t varid, uint32_t *value);
+int csr_read_pskey_complex(int dd, uint16_t seqnum, uint16_t pskey, uint16_t stores, uint8_t *value, uint16_t length);
+int csr_write_pskey_complex(int dd, uint16_t seqnum, uint16_t pskey, uint16_t stores, uint8_t *value, uint16_t length);
+int csr_read_pskey_uint16(int dd, uint16_t seqnum, uint16_t pskey, uint16_t stores, uint16_t *value);
+int csr_write_pskey_uint16(int dd, uint16_t seqnum, uint16_t pskey, uint16_t stores, uint16_t value);
+int csr_read_pskey_uint32(int dd, uint16_t seqnum, uint16_t pskey, uint16_t stores, uint32_t *value);
+int csr_write_pskey_uint32(int dd, uint16_t seqnum, uint16_t pskey, uint16_t stores, uint32_t value);
+
+int psr_put(uint16_t pskey, uint8_t *value, uint16_t size);
+int psr_get(uint16_t *pskey, uint8_t *value, uint16_t *size);
+int psr_read(const char *filename);
+int psr_print(void);
diff --git a/tools/csr_3wire.c b/tools/csr_3wire.c
new file mode 100644
index 000000000..33fcf389a
--- /dev/null
+++ b/tools/csr_3wire.c
@@ -0,0 +1,62 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <stdint.h>
+
+#include "csr.h"
+
+static uint16_t seqnum = 0x0000;
+
+int csr_open_3wire(char *device)
+{
+	fprintf(stderr, "Transport not implemented\n");
+
+	return -1;
+}
+
+static int do_command(uint16_t command, uint16_t seqnum, uint16_t varid, uint8_t *value, uint16_t length)
+{
+	errno = EIO;
+
+	return -1;
+}
+
+int csr_read_3wire(uint16_t varid, uint8_t *value, uint16_t length)
+{
+	return do_command(0x0000, seqnum++, varid, value, length);
+}
+
+int csr_write_3wire(uint16_t varid, uint8_t *value, uint16_t length)
+{
+	return do_command(0x0002, seqnum++, varid, value, length);
+}
+
+void csr_close_3wire(void)
+{
+}
diff --git a/tools/csr_bcsp.c b/tools/csr_bcsp.c
new file mode 100644
index 000000000..e3eea34df
--- /dev/null
+++ b/tools/csr_bcsp.c
@@ -0,0 +1,257 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdint.h>
+#include <termios.h>
+
+#include "csr.h"
+#include "ubcsp.h"
+
+static uint16_t seqnum = 0x0000;
+
+static int fd = -1;
+
+static struct ubcsp_packet send_packet;
+static uint8_t send_buffer[512];
+
+static struct ubcsp_packet receive_packet;
+static uint8_t receive_buffer[512];
+
+int csr_open_bcsp(char *device, speed_t bcsp_rate)
+{
+	struct termios ti;
+	uint8_t delay, activity = 0x00;
+	int timeout = 0;
+
+	if (!device)
+		device = "/dev/ttyS0";
+
+	fd = open(device, O_RDWR | O_NOCTTY);
+	if (fd < 0) {
+		fprintf(stderr, "Can't open serial port: %s (%d)\n",
+						strerror(errno), errno);
+		return -1;
+	}
+
+	tcflush(fd, TCIOFLUSH);
+
+	if (tcgetattr(fd, &ti) < 0) {
+		fprintf(stderr, "Can't get port settings: %s (%d)\n",
+						strerror(errno), errno);
+		close(fd);
+		return -1;
+	}
+
+	cfmakeraw(&ti);
+
+	ti.c_cflag |=  CLOCAL;
+	ti.c_cflag &= ~CRTSCTS;
+	ti.c_cflag |=  PARENB;
+	ti.c_cflag &= ~PARODD;
+	ti.c_cflag &= ~CSIZE;
+	ti.c_cflag |=  CS8;
+	ti.c_cflag &= ~CSTOPB;
+
+	ti.c_cc[VMIN] = 1;
+	ti.c_cc[VTIME] = 0;
+
+	cfsetospeed(&ti, bcsp_rate);
+
+	if (tcsetattr(fd, TCSANOW, &ti) < 0) {
+		fprintf(stderr, "Can't change port settings: %s (%d)\n",
+						strerror(errno), errno);
+		close(fd);
+		return -1;
+	}
+
+	tcflush(fd, TCIOFLUSH);
+
+	if (fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK) < 0) {
+		fprintf(stderr, "Can't set non blocking mode: %s (%d)\n",
+						strerror(errno), errno);
+		close(fd);
+		return -1;
+	}
+
+	memset(&send_packet, 0, sizeof(send_packet));
+	memset(&receive_packet, 0, sizeof(receive_packet));
+
+	ubcsp_initialize();
+
+	send_packet.length = 512;
+	send_packet.payload = send_buffer;
+
+	receive_packet.length = 512;
+	receive_packet.payload = receive_buffer;
+
+	ubcsp_receive_packet(&receive_packet);
+
+	while (1) {
+		delay = ubcsp_poll(&activity);
+
+		if (activity & UBCSP_PACKET_SENT)
+			break;
+
+		if (delay) {
+			usleep(delay * 100);
+
+			if (timeout++ > 5000) {
+				fprintf(stderr, "Initialization timed out\n");
+				return -1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+void put_uart(uint8_t ch)
+{
+	if (write(fd, &ch, 1) < 0)
+		fprintf(stderr, "UART write error\n");
+}
+
+uint8_t get_uart(uint8_t *ch)
+{
+	int res = read(fd, ch, 1);
+	return res > 0 ? res : 0;
+}
+
+static int do_command(uint16_t command, uint16_t seqnum, uint16_t varid, uint8_t *value, uint16_t length)
+{
+	unsigned char cp[254], rp[254];
+	uint8_t cmd[10];
+	uint16_t size;
+	uint8_t delay, activity = 0x00;
+	int timeout = 0, sent = 0;
+
+	size = (length < 8) ? 9 : ((length + 1) / 2) + 5;
+
+	cmd[0] = command & 0xff;
+	cmd[1] = command >> 8;
+	cmd[2] = size & 0xff;
+	cmd[3] = size >> 8;
+	cmd[4] = seqnum & 0xff;
+	cmd[5] = seqnum >> 8;
+	cmd[6] = varid & 0xff;
+	cmd[7] = varid >> 8;
+	cmd[8] = 0x00;
+	cmd[9] = 0x00;
+
+	memset(cp, 0, sizeof(cp));
+	cp[0] = 0x00;
+	cp[1] = 0xfc;
+	cp[2] = (size * 2) + 1;
+	cp[3] = 0xc2;
+	memcpy(cp + 4, cmd, sizeof(cmd));
+	memcpy(cp + 14, value, length);
+
+	receive_packet.length = 512;
+	ubcsp_receive_packet(&receive_packet);
+
+	send_packet.channel  = 5;
+	send_packet.reliable = 1;
+	send_packet.length   = (size * 2) + 4;
+	memcpy(send_packet.payload, cp, (size * 2) + 4);
+
+	ubcsp_send_packet(&send_packet);
+
+	while (1) {
+		delay = ubcsp_poll(&activity);
+
+		if (activity & UBCSP_PACKET_SENT) {
+			switch (varid) {
+			case CSR_VARID_COLD_RESET:
+			case CSR_VARID_WARM_RESET:
+			case CSR_VARID_COLD_HALT:
+			case CSR_VARID_WARM_HALT:
+				return 0;
+			}
+
+			sent = 1;
+			timeout = 0;
+		}
+
+		if (activity & UBCSP_PACKET_RECEIVED) {
+			if (sent && receive_packet.channel == 5 &&
+					receive_packet.payload[0] == 0xff) {
+				memcpy(rp, receive_packet.payload,
+							receive_packet.length);
+				break;
+			}
+
+			receive_packet.length = 512;
+			ubcsp_receive_packet(&receive_packet);
+			timeout = 0;
+		}
+
+		if (delay) {
+			usleep(delay * 100);
+
+			if (timeout++ > 5000) {
+				fprintf(stderr, "Operation timed out\n");
+				errno = ETIMEDOUT;
+				return -1;
+			}
+		}
+	}
+
+	if (rp[0] != 0xff || rp[2] != 0xc2) {
+		errno = EIO;
+		return -1;
+	}
+
+	if ((rp[11] + (rp[12] << 8)) != 0) {
+		errno = ENXIO;
+		return -1;
+	}
+
+	memcpy(value, rp + 13, length);
+
+	return 0;
+}
+
+int csr_read_bcsp(uint16_t varid, uint8_t *value, uint16_t length)
+{
+	return do_command(0x0000, seqnum++, varid, value, length);
+}
+
+int csr_write_bcsp(uint16_t varid, uint8_t *value, uint16_t length)
+{
+	return do_command(0x0002, seqnum++, varid, value, length);
+}
+
+void csr_close_bcsp(void)
+{
+	close(fd);
+}
diff --git a/tools/csr_h4.c b/tools/csr_h4.c
new file mode 100644
index 000000000..2dcaec1e5
--- /dev/null
+++ b/tools/csr_h4.c
@@ -0,0 +1,166 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdint.h>
+#include <termios.h>
+
+#include "csr.h"
+
+static uint16_t seqnum = 0x0000;
+
+static int fd = -1;
+
+int csr_open_h4(char *device)
+{
+	struct termios ti;
+
+	if (!device)
+		device = "/dev/ttyS0";
+
+	fd = open(device, O_RDWR | O_NOCTTY);
+	if (fd < 0) {
+		fprintf(stderr, "Can't open serial port: %s (%d)\n",
+						strerror(errno), errno);
+		return -1;
+	}
+
+	tcflush(fd, TCIOFLUSH);
+
+	if (tcgetattr(fd, &ti) < 0) {
+		fprintf(stderr, "Can't get port settings: %s (%d)\n",
+						strerror(errno), errno);
+		close(fd);
+		return -1;
+	}
+
+	cfmakeraw(&ti);
+
+	ti.c_cflag |= CLOCAL;
+	ti.c_cflag |= CRTSCTS;
+
+	cfsetospeed(&ti, B38400);
+
+	if (tcsetattr(fd, TCSANOW, &ti) < 0) {
+		fprintf(stderr, "Can't change port settings: %s (%d)\n",
+						strerror(errno), errno);
+		close(fd);
+		return -1;
+	}
+
+	tcflush(fd, TCIOFLUSH);
+
+	return 0;
+}
+
+static int do_command(uint16_t command, uint16_t seqnum, uint16_t varid, uint8_t *value, uint16_t length)
+{
+	unsigned char cp[254], rp[254];
+	uint8_t cmd[10];
+	uint16_t size;
+	int len, offset = 3;
+
+	size = (length < 8) ? 9 : ((length + 1) / 2) + 5;
+
+	cmd[0] = command & 0xff;
+	cmd[1] = command >> 8;
+	cmd[2] = size & 0xff;
+	cmd[3] = size >> 8;
+	cmd[4] = seqnum & 0xff;
+	cmd[5] = seqnum >> 8;
+	cmd[6] = varid & 0xff;
+	cmd[7] = varid >> 8;
+	cmd[8] = 0x00;
+	cmd[9] = 0x00;
+
+	memset(cp, 0, sizeof(cp));
+	cp[0] = 0x01;
+	cp[1] = 0x00;
+	cp[2] = 0xfc;
+	cp[3] = (size * 2) + 1;
+	cp[4] = 0xc2;
+	memcpy(cp + 5, cmd, sizeof(cmd));
+	memcpy(cp + 15, value, length);
+
+	if (write(fd, cp, (size * 2) + 5) < 0)
+		return -1;
+
+	switch (varid) {
+	case CSR_VARID_COLD_RESET:
+	case CSR_VARID_WARM_RESET:
+	case CSR_VARID_COLD_HALT:
+	case CSR_VARID_WARM_HALT:
+		return 0;
+	}
+
+	do {
+		if (read(fd, rp, 1) < 1)
+			return -1;
+	} while (rp[0] != 0x04);
+
+	if (read(fd, rp + 1, 2) < 2)
+		return -1;
+
+	do {
+		len = read(fd, rp + offset, sizeof(rp) - offset);
+		offset += len;
+	} while (offset < rp[2] + 3);
+
+	if (rp[0] != 0x04 || rp[1] != 0xff || rp[3] != 0xc2) {
+		errno = EIO;
+		return -1;
+	}
+
+	if ((rp[12] + (rp[13] << 8)) != 0) {
+		errno = ENXIO;
+		return -1;
+	}
+
+	memcpy(value, rp + 14, length);
+
+	return 0;
+}
+
+int csr_read_h4(uint16_t varid, uint8_t *value, uint16_t length)
+{
+	return do_command(0x0000, seqnum++, varid, value, length);
+}
+
+int csr_write_h4(uint16_t varid, uint8_t *value, uint16_t length)
+{
+	return do_command(0x0002, seqnum++, varid, value, length);
+}
+
+void csr_close_h4(void)
+{
+	close(fd);
+}
diff --git a/tools/csr_hci.c b/tools/csr_hci.c
new file mode 100644
index 000000000..d2e4ab9c6
--- /dev/null
+++ b/tools/csr_hci.c
@@ -0,0 +1,160 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/socket.h>
+
+#include "lib/bluetooth.h"
+#include "lib/hci.h"
+#include "lib/hci_lib.h"
+
+#include "csr.h"
+
+static uint16_t seqnum = 0x0000;
+
+static int dd = -1;
+
+int csr_open_hci(char *device)
+{
+	struct hci_dev_info di;
+	struct hci_version ver;
+	int dev = 0;
+
+	if (device) {
+		dev = hci_devid(device);
+		if (dev < 0) {
+			fprintf(stderr, "Device not available\n");
+			return -1;
+		}
+	}
+
+	dd = hci_open_dev(dev);
+	if (dd < 0) {
+		fprintf(stderr, "Can't open device hci%d: %s (%d)\n",
+						dev, strerror(errno), errno);
+		return -1;
+	}
+
+	if (hci_devinfo(dev, &di) < 0) {
+		fprintf(stderr, "Can't get device info for hci%d: %s (%d)\n",
+						dev, strerror(errno), errno);
+		hci_close_dev(dd);
+		return -1;
+	}
+
+	if (hci_read_local_version(dd, &ver, 1000) < 0) {
+		fprintf(stderr, "Can't read version info for hci%d: %s (%d)\n",
+						dev, strerror(errno), errno);
+		hci_close_dev(dd);
+		return -1;
+	}
+
+	if (ver.manufacturer != 10) {
+		fprintf(stderr, "Unsupported manufacturer\n");
+		hci_close_dev(dd);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int do_command(uint16_t command, uint16_t seqnum, uint16_t varid, uint8_t *value, uint16_t length)
+{
+	unsigned char cp[254], rp[254];
+	struct hci_request rq;
+	uint8_t cmd[10];
+	uint16_t size;
+
+	size = (length < 8) ? 9 : ((length + 1) / 2) + 5;
+
+	cmd[0] = command & 0xff;
+	cmd[1] = command >> 8;
+	cmd[2] = size & 0xff;
+	cmd[3] = size >> 8;
+	cmd[4] = seqnum & 0xff;
+	cmd[5] = seqnum >> 8;
+	cmd[6] = varid & 0xff;
+	cmd[7] = varid >> 8;
+	cmd[8] = 0x00;
+	cmd[9] = 0x00;
+
+	memset(cp, 0, sizeof(cp));
+	cp[0] = 0xc2;
+	memcpy(cp + 1, cmd, sizeof(cmd));
+	memcpy(cp + 11, value, length);
+
+	switch (varid) {
+	case CSR_VARID_COLD_RESET:
+	case CSR_VARID_WARM_RESET:
+	case CSR_VARID_COLD_HALT:
+	case CSR_VARID_WARM_HALT:
+		return hci_send_cmd(dd, OGF_VENDOR_CMD, 0x00, (size * 2) + 1, cp);
+	}
+
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = OGF_VENDOR_CMD;
+	rq.ocf    = 0x00;
+	rq.event  = EVT_VENDOR;
+	rq.cparam = cp;
+	rq.clen   = (size * 2) + 1;
+	rq.rparam = rp;
+	rq.rlen   = sizeof(rp);
+
+	if (hci_send_req(dd, &rq, 2000) < 0)
+		return -1;
+
+	if (rp[0] != 0xc2) {
+		errno = EIO;
+		return -1;
+	}
+
+	if ((rp[9] + (rp[10] << 8)) != 0) {
+		errno = ENXIO;
+		return -1;
+	}
+
+	memcpy(value, rp + 11, length);
+
+	return 0;
+}
+
+int csr_read_hci(uint16_t varid, uint8_t *value, uint16_t length)
+{
+	return do_command(0x0000, seqnum++, varid, value, length);
+}
+
+int csr_write_hci(uint16_t varid, uint8_t *value, uint16_t length)
+{
+	return do_command(0x0002, seqnum++, varid, value, length);
+}
+
+void csr_close_hci(void)
+{
+	hci_close_dev(dd);
+}
diff --git a/tools/csr_usb.c b/tools/csr_usb.c
new file mode 100644
index 000000000..32fdf1f14
--- /dev/null
+++ b/tools/csr_usb.c
@@ -0,0 +1,308 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <errno.h>
+#include <ctype.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <dirent.h>
+#include <limits.h>
+#include <sys/ioctl.h>
+
+#include "csr.h"
+
+#define USB_TYPE_CLASS			(0x01 << 5)
+
+#define USB_RECIP_DEVICE		0x00
+
+#define USB_ENDPOINT_IN			0x80
+#define USB_ENDPOINT_OUT		0x00
+
+struct usbfs_ctrltransfer {
+	uint8_t  bmRequestType;
+	uint8_t  bRequest;
+	uint16_t wValue;
+	uint16_t wIndex;
+	uint16_t wLength;
+	uint32_t timeout;	/* in milliseconds */
+	void *data;		/* pointer to data */
+};
+
+struct usbfs_bulktransfer {
+	unsigned int ep;
+	unsigned int len;
+	unsigned int timeout;   /* in milliseconds */
+	void *data;		/* pointer to data */
+};
+
+#define USBFS_IOCTL_CONTROL	_IOWR('U', 0, struct usbfs_ctrltransfer)
+#define USBFS_IOCTL_BULK	_IOWR('U', 2, struct usbfs_bulktransfer)
+#define USBFS_IOCTL_CLAIMINTF	_IOR('U', 15, unsigned int)
+#define USBFS_IOCTL_RELEASEINTF	_IOR('U', 16, unsigned int)
+
+static int read_value(const char *name, const char *attr, bool hex_number)
+{
+	char path[PATH_MAX];
+	FILE *file;
+	int n, value;
+
+	snprintf(path, sizeof(path), "/sys/bus/usb/devices/%s/%s", name, attr);
+
+	file = fopen(path, "r");
+	if (!file)
+		return -1;
+
+	n = fscanf(file, hex_number ? "%d" : "%04x", &value);
+	if (n != 1) {
+		fclose(file);
+		return -1;
+	}
+
+	fclose(file);
+	return value;
+}
+
+#define read_hex_value(name, file) read_value((name), (file), true)
+#define read_num_value(name, file) read_value((name), (file), false)
+
+static char *check_device(const char *name)
+{
+	char path[PATH_MAX];
+	int busnum, devnum, vendor, product;
+
+	busnum = read_num_value(name, "busnum");
+	if (busnum < 0)
+		return NULL;
+
+	devnum = read_num_value(name, "devnum");
+	if (devnum < 0)
+		return NULL;
+
+	snprintf(path, sizeof(path), "/dev/bus/usb/%03u/%03u", busnum, devnum);
+
+	vendor = read_hex_value(name, "idVendor");
+	if (vendor < 0)
+		return NULL;
+
+	product = read_hex_value(name, "idProduct");
+	if (product < 0)
+		return NULL;
+
+	if (vendor != 0x0a12 || product != 0x0001)
+		return NULL;
+
+	return strdup(path);
+}
+
+static char *find_device(void)
+{
+	char *path = NULL;
+	DIR *dir;
+
+	dir = opendir("/sys/bus/usb/devices");
+	if (!dir)
+		return NULL;
+
+	while (1) {
+		struct dirent *d;
+
+		d = readdir(dir);
+		if (!d)
+			break;
+
+		if ((!isdigit(d->d_name[0]) && strncmp(d->d_name, "usb", 3))
+						|| strchr(d->d_name, ':'))
+			continue;
+
+		path = check_device(d->d_name);
+		if (path)
+			break;
+	}
+
+	closedir(dir);
+
+	return path;
+}
+
+static uint16_t seqnum = 0x0000;
+static int handle = -1;
+
+int csr_open_usb(char *device)
+{
+	int interface = 0;
+	char *path;
+
+	path = find_device();
+	if (!path) {
+		fprintf(stderr, "Device not available\n");
+		return -1;
+	}
+
+	handle = open(path, O_RDWR, O_CLOEXEC | O_NONBLOCK);
+
+	free(path);
+
+	if (handle < 0) {
+		fprintf(stderr, "Can't open device: %s (%d)\n",
+						strerror(errno), errno);
+		return -1;
+	}
+
+	if (ioctl(handle, USBFS_IOCTL_CLAIMINTF, &interface) < 0) {
+		fprintf(stderr, "Can't claim interface: %s (%d)\n",
+						strerror(errno), errno);
+		close(handle);
+		handle = -1;
+		return -1;
+	}
+
+	return 0;
+}
+
+static int control_write(int fd, void *data, unsigned short size)
+{
+	struct usbfs_ctrltransfer transfer;
+
+	transfer.bmRequestType = USB_TYPE_CLASS | USB_ENDPOINT_OUT |
+							USB_RECIP_DEVICE;
+	transfer.bRequest = 0;
+	transfer.wValue = 0;
+	transfer.wIndex = 0;
+	transfer.wLength = size,
+	transfer.timeout = 2000;
+	transfer.data = data;
+
+	if (ioctl(fd, USBFS_IOCTL_CONTROL, &transfer) < 0) {
+		fprintf(stderr, "Control transfer failed: %s (%d)\n",
+						strerror(errno), errno);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int interrupt_read(int fd, unsigned char endpoint,
+					void *data, unsigned short size)
+{
+	struct usbfs_bulktransfer transfer;
+
+	transfer.ep = endpoint;
+	transfer.len = size,
+	transfer.timeout = 20;
+	transfer.data = data;
+
+	return ioctl(fd, USBFS_IOCTL_BULK, &transfer);
+}
+
+static int do_command(uint16_t command, uint16_t seqnum, uint16_t varid,
+					uint8_t *value, uint16_t length)
+{
+	unsigned char cp[254], rp[254];
+	uint8_t cmd[10];
+	uint16_t size;
+	int len, offset = 0;
+
+	size = (length < 8) ? 9 : ((length + 1) / 2) + 5;
+
+	cmd[0] = command & 0xff;
+	cmd[1] = command >> 8;
+	cmd[2] = size & 0xff;
+	cmd[3] = size >> 8;
+	cmd[4] = seqnum & 0xff;
+	cmd[5] = seqnum >> 8;
+	cmd[6] = varid & 0xff;
+	cmd[7] = varid >> 8;
+	cmd[8] = 0x00;
+	cmd[9] = 0x00;
+
+	memset(cp, 0, sizeof(cp));
+	cp[0] = 0x00;
+	cp[1] = 0xfc;
+	cp[2] = (size * 2) + 1;
+	cp[3] = 0xc2;
+	memcpy(cp + 4, cmd, sizeof(cmd));
+	memcpy(cp + 14, value, length);
+
+	interrupt_read(handle, USB_ENDPOINT_IN | 0x01, rp, sizeof(rp));
+
+	control_write(handle, cp, (size * 2) + 4);
+
+	switch (varid) {
+	case CSR_VARID_COLD_RESET:
+	case CSR_VARID_WARM_RESET:
+	case CSR_VARID_COLD_HALT:
+	case CSR_VARID_WARM_HALT:
+		return 0;
+	}
+
+	do {
+		len = interrupt_read(handle, USB_ENDPOINT_IN | 0x01,
+					rp + offset, sizeof(rp) - offset);
+		if (len < 0)
+			break;
+		offset += len;
+	} while (len > 0);
+
+	if (rp[0] != 0xff || rp[2] != 0xc2) {
+		errno = EIO;
+		return -1;
+	}
+
+	if ((rp[11] + (rp[12] << 8)) != 0) {
+		errno = ENXIO;
+		return -1;
+	}
+
+	memcpy(value, rp + 13, length);
+
+	return 0;
+}
+
+int csr_read_usb(uint16_t varid, uint8_t *value, uint16_t length)
+{
+	return do_command(0x0000, seqnum++, varid, value, length);
+}
+
+int csr_write_usb(uint16_t varid, uint8_t *value, uint16_t length)
+{
+	return do_command(0x0002, seqnum++, varid, value, length);
+}
+
+void csr_close_usb(void)
+{
+	int interface = 0;
+
+	ioctl(handle, USBFS_IOCTL_RELEASEINTF, &interface);
+
+	close(handle);
+	handle = -1;
+}
diff --git a/tools/hciconfig.c b/tools/hciconfig.c
index e4d521583..34b39a973 100644
--- a/tools/hciconfig.c
+++ b/tools/hciconfig.c
@@ -33,6 +33,7 @@
 
 #include "src/textfile.h"
 #include "src/shared/util.h"
+#include "tools/csr.h"
 
 static struct hci_dev_info di;
 static int all;
@@ -1693,6 +1694,30 @@ static void print_rev_ericsson(int dd)
 	printf("\t%s\n", buf + 1);
 }
 
+static void print_rev_csr(int dd, uint16_t rev)
+{
+	uint16_t buildid, chipver, chiprev, maxkeylen, mapsco;
+
+	if (csr_read_varid_uint16(dd, 0, CSR_VARID_BUILDID, &buildid) < 0) {
+		printf("\t%s\n", csr_buildidtostr(rev));
+		return;
+	}
+
+	printf("\t%s\n", csr_buildidtostr(buildid));
+
+	if (!csr_read_varid_uint16(dd, 1, CSR_VARID_CHIPVER, &chipver)) {
+		if (csr_read_varid_uint16(dd, 2, CSR_VARID_CHIPREV, &chiprev) < 0)
+			chiprev = 0;
+		printf("\tChip version: %s\n", csr_chipvertostr(chipver, chiprev));
+	}
+
+	if (!csr_read_varid_uint16(dd, 3, CSR_VARID_MAX_CRYPT_KEY_LENGTH, &maxkeylen))
+		printf("\tMax key size: %d bit\n", maxkeylen * 8);
+
+	if (!csr_read_pskey_uint16(dd, 4, CSR_PSKEY_HOSTIO_MAP_SCO_PCM, 0x0000, &mapsco))
+		printf("\tSCO mapping:  %s\n", mapsco ? "PCM" : "HCI");
+}
+
 static void print_rev_digianswer(int dd)
 {
 	struct hci_request rq;
@@ -1755,6 +1780,9 @@ static void cmd_revision(int ctl, int hdev, char *opt)
 	case 48:
 		print_rev_ericsson(dd);
 		break;
+	case 10:
+		print_rev_csr(dd, ver.hci_rev);
+		break;
 	case 12:
 		print_rev_digianswer(dd);
 		break;
diff --git a/tools/ubcsp.c b/tools/ubcsp.c
new file mode 100644
index 000000000..b3f883a03
--- /dev/null
+++ b/tools/ubcsp.c
@@ -0,0 +1,1180 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2000-2005  CSR Ltd.
+ *
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be included
+ *  in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ *  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ *  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ *  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ *  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp,c                                                                 **/
+/**                                                                         **/
+/** MicroBCSP - a very low cost implementation of the BCSP protocol         **/
+/**                                                                         **/
+/*****************************************************************************/
+
+#include "ubcsp.h"
+
+#if SHOW_PACKET_ERRORS || SHOW_LE_STATES
+#include <stdio.h>
+#include <windows.h>
+#endif
+
+static uint16 ubcsp_calc_crc (uint8 ch, uint16 crc);
+static uint16 ubcsp_crc_reverse (uint16);
+
+/*****************************************************************************/
+/**                                                                         **/
+/** Constant Data - ROM                                                     **/
+/**                                                                         **/
+/*****************************************************************************/
+
+/* This is the storage for the link establishment messages */
+
+static const uint8 ubcsp_le_buffer[4][4] =
+	{
+		{ 0xDA, 0xDC, 0xED, 0xED },
+		{ 0xAC, 0xAF, 0xEF, 0xEE },
+		{ 0xAD, 0xEF, 0xAC, 0xED },
+		{ 0xDE, 0xAD, 0xD0, 0xD0 },
+	};
+
+/* These are the link establishment headers */
+/* The two version are for the CRC and non-CRC varients */
+
+#if UBCSP_CRC
+static const uint8 ubcsp_send_le_header[4] = 
+	{
+		0x40, 0x41, 0x00, 0x7E
+	};
+#else
+static const uint8 ubcsp_send_le_header[4] = 
+	{
+		0x00, 0x41, 0x00, 0xBE
+	};
+#endif
+
+/*****************************************************************************/
+/**                                                                         **/
+/** Static Data - RAM                                                       **/
+/**                                                                         **/
+/*****************************************************************************/
+
+/* This is the storage for all state data for ubcsp */
+
+static struct ubcsp_configuration ubcsp_config;
+
+/* This is the ACK packet header - this will be overwritten when
+   we create an ack packet */
+
+static uint8 ubcsp_send_ack_header[4] = 
+	{
+		0x00, 0x00, 0x00, 0x00
+	};
+
+/* This is the deslip lookup table */
+
+static const uint8 ubcsp_deslip[2] =
+	{
+		SLIP_FRAME, SLIP_ESCAPE,
+	};
+
+/* This is a state machine table for link establishment */
+
+static uint8 next_le_packet[16] =
+	{
+		ubcsp_le_sync,			// uninit
+		ubcsp_le_conf,			// init
+		ubcsp_le_none,			// active
+		ubcsp_le_none,
+		ubcsp_le_sync_resp,		// sync_resp
+		ubcsp_le_sync_resp,
+		ubcsp_le_none,
+		ubcsp_le_none,
+		ubcsp_le_none,			// conf_resp
+		ubcsp_le_conf_resp,
+		ubcsp_le_conf_resp,
+		ubcsp_le_none,
+	};
+
+/* This is the storage required for building send and crc data */
+
+static uint8 ubcsp_send_header[4];
+static uint8 ubcsp_send_crc[2];
+
+/* This is where the receive header is stored before the payload arrives */
+
+static uint8 ubcsp_receive_header[4];
+
+/*****************************************************************************/
+/**                                                                         **/
+/** Code - ROM or RAM                                                       **/
+/**                                                                         **/
+/*****************************************************************************/
+
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp_initialize                                                        **/
+/**                                                                         **/
+/** This initializes the state of the ubcsp engine to a known values        **/
+/**                                                                         **/
+/*****************************************************************************/
+
+void ubcsp_initialize (void)
+{
+	ubcsp_config.ack_number = 0;
+	ubcsp_config.sequence_number = 0;
+	ubcsp_config.send_ptr = 0;
+	ubcsp_config.send_size = 0;
+	ubcsp_config.receive_index = -4;
+
+	ubcsp_config.delay = 0;
+
+#if SHOW_LE_STATES
+	printf ("Hello Link Uninitialized\n");
+#endif
+
+	ubcsp_config.link_establishment_state = ubcsp_le_uninitialized;
+	ubcsp_config.link_establishment_packet = ubcsp_le_sync;
+}
+
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp_send_packet                                                       **/
+/**                                                                         **/
+/** This sends a packet structure for sending to the ubcsp engine           **/
+/** This can only be called when the activity indication from ubcsp_poll    **/
+/** indicates that a packet can be sent with UBCSP_PACKET_SENT              **/
+/**                                                                         **/
+/*****************************************************************************/
+
+void ubcsp_send_packet (struct ubcsp_packet *send_packet)
+{
+	/* Initialize the send data to the packet we want to send */
+
+	ubcsp_config.send_packet = send_packet;
+
+	/* we cannot send the packet at the moment
+	   when we can at the moment, just set things to 0 */
+
+	ubcsp_config.send_size = 0;
+	ubcsp_config.send_ptr = 0;
+}
+
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp_receive_packet                                                    **/
+/**                                                                         **/
+/** This sends a packet structure for receiving to the ubcsp engine         **/
+/** This can only be called when the activity indication from ubcsp_poll    **/
+/** indicates that a packet can be sent with UBCSP_PACKET_RECEIVED          **/
+/**                                                                         **/
+/*****************************************************************************/
+
+void ubcsp_receive_packet (struct ubcsp_packet *receive_packet)
+{
+	/* Initialize the receive data to the packet we want to receive */
+
+	ubcsp_config.receive_packet = receive_packet;
+
+	/* setup to receive the header first */
+
+	ubcsp_config.receive_index = -4;
+}
+
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp_calc_crc                                                          **/
+/**                                                                         **/
+/** Takes the next 8 bit value ch, and updates the crc with this value      **/
+/**                                                                         **/
+/*****************************************************************************/
+
+
+#ifdef UBCSP_CRC
+
+static uint16 ubcsp_calc_crc (uint8 ch, uint16 crc)
+{
+	/* Calculate the CRC using the above 16 entry lookup table */
+
+	static const uint16 crc_table[] =
+		{
+			0x0000, 0x1081, 0x2102, 0x3183,
+			0x4204, 0x5285, 0x6306, 0x7387,
+			0x8408, 0x9489, 0xa50a, 0xb58b,
+			0xc60c, 0xd68d, 0xe70e, 0xf78f
+		};
+
+	/* Do this four bits at a time - more code, less space */
+
+    crc = (crc >> 4) ^ crc_table[(crc ^ ch) & 0x000f];
+    crc = (crc >> 4) ^ crc_table[(crc ^ (ch >> 4)) & 0x000f];
+
+	return crc;
+}
+
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp_crc_reverse                                                       **/
+/**                                                                         **/
+/** Reserves the bits in crc and returns the new value                      **/
+/**                                                                         **/
+/*****************************************************************************/
+
+static uint16 ubcsp_crc_reverse (uint16 crc)
+{
+	int32
+		b,
+		rev;
+
+	/* Reserse the bits to compute the actual CRC value */
+
+	for (b = 0, rev=0; b < 16; b++)
+	{
+		rev = rev << 1;
+		rev |= (crc & 1);
+		crc = crc >> 1;
+	}
+
+	return rev;
+}
+
+#endif
+
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp_put_slip_uart                                                     **/
+/**                                                                         **/
+/** Outputs a single octet to the uart                                      **/
+/** If the octet needs to be escaped, then output the escape value          **/
+/** and then store the second octet to be output later                      **/
+/**                                                                         **/
+/*****************************************************************************/
+
+static void ubcsp_put_slip_uart (uint8 ch)
+{
+	/* output a single UART octet */
+
+	/* If it needs to be escaped, then output the escape octet
+	   and set the send_slip_escape so that the next time we
+	   output the second octet for the escape correctly.
+	   This is done right at the top of ubcsp_poll */
+
+	if (ch == SLIP_FRAME)
+	{
+		put_uart (SLIP_ESCAPE);
+		ubcsp_config.send_slip_escape = SLIP_ESCAPE_FRAME;
+	}
+	else if (ch == SLIP_ESCAPE)
+	{
+		put_uart (SLIP_ESCAPE);
+		ubcsp_config.send_slip_escape = SLIP_ESCAPE_ESCAPE;
+	}
+	else
+	{
+		/* Not escaped, so just output octet */
+
+		put_uart (ch);
+	}
+}
+
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp_which_le_payload                                                  **/
+/**                                                                         **/
+/** Check the payload of this packet, and determine which of the four       **/
+/** link establishment packets this was.                                    **/
+/** Can return 5 if it is not a valid link establishment packet             **/
+/**                                                                         **/
+/*****************************************************************************/
+
+static uint32 ubcsp_which_le_payload (const uint8 *payload)
+{
+	static int32
+		octet,
+		loop;
+
+	/* Search through the various link establishment payloads to find
+	   which one we have received */
+
+	for (loop = 0; loop < 4; loop ++)
+	{
+		for (octet = 0; octet < 4; octet ++)
+		{
+			if (payload[octet] != ubcsp_le_buffer[loop][octet])
+			{
+				/* Bad match, just to loop again */
+				goto bad_match_loop;
+			}
+		}
+
+		/* All the octets matched, return the value */
+
+		return loop;
+
+		/* Jumps out of octet loop if we got a bad match */
+bad_match_loop:
+		{}
+	}
+
+	/* Non of the link establishment payloads matched - return invalid value */
+
+	return 5;
+}
+
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp_recevied_packet                                                   **/
+/**                                                                         **/
+/** This function is called when we have a SLIP END octet and a full        **/
+/** packet header and possibly data in the receive packet                   **/
+/**                                                                         **/
+/*****************************************************************************/
+
+static uint8 ubcsp_recevied_packet (void)
+{
+	static uint8
+		receive_crc,
+		receive_seq,
+		receive_ack,
+		activity;
+
+#if UBCSP_CRC
+	static int32
+		loop;
+
+	static uint16
+		crc;
+#endif
+
+	static uint16
+		length;
+
+	/* Keep track of what activity this received packet will cause */
+
+	activity = 0;
+
+	/*** Do all error checks that we can ***/
+
+	/* First check the header checksum */
+
+	if (((ubcsp_receive_header[0] + ubcsp_receive_header[1] + ubcsp_receive_header[2] + ubcsp_receive_header[3]) & 0xff) != 0xff)
+	{
+		/* Header Checksum Error */
+
+#if SHOW_PACKET_ERRORS
+		printf ("\n######################## Header Checksum Error %02X %02X %02X %02X\n",
+			ubcsp_receive_header[0],
+			ubcsp_receive_header[1],
+			ubcsp_receive_header[2],
+			ubcsp_receive_header[3]);
+#endif
+
+		/* If we have a header checksum error, send an ack in return
+		   this gets a packet to be resent as quickly as possible */
+
+		ubcsp_config.send_ack = 1;
+
+		return activity;
+	}
+
+	/* Decode the received packets header */
+
+	ubcsp_config.receive_packet->reliable = (ubcsp_receive_header[0] & 0x80) >> 7;
+
+	receive_crc = (ubcsp_receive_header[0] & 0x40) >> 6;
+	receive_ack = (ubcsp_receive_header[0] & 0x38) >> 3;
+	receive_seq = (ubcsp_receive_header[0] & 0x07);
+
+	ubcsp_config.receive_packet->channel = (ubcsp_receive_header[1] & 0x0f);
+
+	length =
+		((ubcsp_receive_header[1] & 0xf0) >> 4) |
+		(ubcsp_receive_header[2] << 4);
+
+#if SHOW_PACKET_ERRORS
+	if (ubcsp_config.receive_packet->reliable)
+	{
+		printf (" : %10d         Recv SEQ: %d ACK %d\n",
+			GetTickCount () % 100000,
+			receive_seq,
+			receive_ack);
+	}
+	else if (ubcsp_config.receive_packet->channel != 1)
+	{
+		printf (" : %10d          Recv        ACK %d\n",
+			GetTickCount () % 100000,
+			receive_ack);
+	}
+#endif
+
+	/* Check for length errors */
+
+#if UBCSP_CRC
+	if (receive_crc)
+	{
+		/* If this packet had a CRC, then the length of the payload 
+		   should be 2 less than the received size of the payload */
+
+		if (length + 2 != ubcsp_config.receive_index)
+		{
+			/* Slip Length Error */
+
+#if SHOW_PACKET_ERRORS
+			printf ("\n######################## Slip Length Error (With CRC) %d,%d\n", length, ubcsp_config.receive_index - 2);
+#endif
+
+			/* If we have a payload length error, send an ack in return
+			   this gets a packet to be resent as quickly as possible */
+
+			ubcsp_config.send_ack = 1;
+			return activity;
+		}
+
+		/* We have a CRC at the end of this packet */
+
+		ubcsp_config.receive_index -= 2;
+
+		/* Calculate the packet CRC */
+
+		crc = 0xffff;
+
+		/* CRC the packet header */
+
+		for (loop = 0; loop < 4; loop ++)
+		{
+			crc = ubcsp_calc_crc (ubcsp_receive_header[loop], crc);
+		}
+
+		/* CRC the packet payload - without the CRC bytes */
+
+		for (loop = 0; loop < ubcsp_config.receive_index; loop ++)
+		{
+			crc = ubcsp_calc_crc (ubcsp_config.receive_packet->payload[loop], crc);
+		}
+
+		/* Reverse the CRC */
+
+		crc = ubcsp_crc_reverse (crc);
+
+		/* Check the CRC is correct */
+
+		if
+		(
+			(((crc & 0xff00) >> 8) != ubcsp_config.receive_packet->payload[ubcsp_config.receive_index]) ||
+			((crc & 0xff) != ubcsp_config.receive_packet->payload[ubcsp_config.receive_index + 1])
+		)
+		{
+#if SHOW_PACKET_ERRORS
+			printf ("\n######################## CRC Error\n");
+#endif
+
+			/* If we have a packet crc error, send an ack in return
+			   this gets a packet to be resent as quickly as possible */
+
+			ubcsp_config.send_ack = 1;
+			return activity;
+		}
+	}
+	else
+	{
+#endif
+		/* No CRC present, so just check the length of payload with that received */
+
+		if (length != ubcsp_config.receive_index)
+		{
+			/* Slip Length Error */
+
+#if SHOW_PACKET_ERRORS
+			printf ("\n######################## Slip Length Error (No CRC) %d,%d\n", length, ubcsp_config.receive_index);
+#endif
+
+			/* If we have a payload length error, send an ack in return
+			   this gets a packet to be resent as quickly as possible */
+
+			ubcsp_config.send_ack = 1;
+			return activity;
+		}
+#if UBCSP_CRC
+	}
+#endif
+
+	/*** We have a fully formed packet having passed all data integrity checks ***/
+
+	/* Check if we have an ACK for the last packet we sent */
+
+	if (receive_ack != ubcsp_config.sequence_number)
+	{
+		/* Since we only have a window size of 1, if the ACK is not equal to SEQ
+		   then the packet was sent */
+
+		if
+		(
+			(ubcsp_config.send_packet) &&
+			(ubcsp_config.send_packet->reliable)
+		)
+		{
+			/* We had sent a reliable packet, so clear this packet
+			   Then increament the sequence number for the next packet */
+
+			ubcsp_config.send_packet = 0;
+			ubcsp_config.sequence_number ++;
+			ubcsp_config.delay = 0;
+
+			/* Notify the caller that we have SENT a packet */
+
+			activity |= UBCSP_PACKET_SENT;
+		}
+	}
+
+	/*** Now we can concentrate of the packet we have received ***/
+
+	/* Check for Link Establishment packets */
+
+	if (ubcsp_config.receive_packet->channel == 1)
+	{
+		/* Link Establishment */
+
+		ubcsp_config.delay = 0;
+
+		/* Find which link establishment packet this payload means
+		   This could return 5, meaning none */
+
+		switch (ubcsp_which_le_payload (ubcsp_config.receive_packet->payload))
+		{
+			case 0:
+			{
+				/* SYNC Recv'd */
+
+#if SHOW_LE_STATES
+				printf ("Recv SYNC\n");
+#endif
+
+				/* If we receive a SYNC, then we respond to it with a SYNC RESP
+				   but only if we are not active.
+				   If we are active, then we have a PEER RESET */
+
+				if (ubcsp_config.link_establishment_state < ubcsp_le_active)
+				{
+					ubcsp_config.link_establishment_resp = 1;
+				}
+				else
+				{
+					/* Peer reset !!!! */
+
+#if SHOW_LE_STATES
+					printf ("\n\n\n\n\nPEER RESET\n\n");
+#endif
+
+					/* Reinitialize the link */
+
+					ubcsp_initialize ();
+
+					/* Tell the host what has happened */
+
+					return UBCSP_PEER_RESET;
+				}
+				break;
+			}
+
+			case 1:
+			{
+				/* SYNC RESP Recv'd */
+
+#if SHOW_LE_STATES
+				printf ("Recv SYNC RESP\n");
+#endif
+
+				/* If we receive a SYNC RESP, push us into the initialized state */
+
+				if (ubcsp_config.link_establishment_state < ubcsp_le_initialized)
+				{
+#if SHOW_LE_STATES
+					printf ("Link Initialized\n");
+#endif
+					ubcsp_config.link_establishment_state = ubcsp_le_initialized;
+				}
+
+				break;
+			}
+
+			case 2:
+			{
+				/* CONF Recv'd */
+
+#if SHOW_LE_STATES
+				printf ("Recv CONF\n");
+#endif
+
+				/* If we receive a CONF, and we are initialized or active
+				   then respond with a CONF RESP */
+
+				if (ubcsp_config.link_establishment_state >= ubcsp_le_initialized)
+				{
+					ubcsp_config.link_establishment_resp = 2;
+				}
+
+				break;
+			}
+
+			case 3:
+			{
+				/* CONF RESP Recv'd */
+
+#if SHOW_LE_STATES
+				printf ("Recv CONF RESP\n");
+#endif
+
+				/* If we received a CONF RESP, then push us into the active state */
+
+				if (ubcsp_config.link_establishment_state < ubcsp_le_active)
+				{
+#if SHOW_LE_STATES
+					printf ("Link Active\n");
+#endif
+
+					ubcsp_config.link_establishment_state = ubcsp_le_active;
+					ubcsp_config.send_size = 0;
+
+					return activity | UBCSP_PACKET_SENT;
+				}
+
+				break;
+			}
+		}
+
+		/* We have finished processing Link Establishment packets */
+	}
+	else if (ubcsp_config.receive_index)
+	{
+		/* We have some payload data we need to process
+		   but only if we are active - otherwise, we just ignore it */
+
+		if (ubcsp_config.link_establishment_state == ubcsp_le_active)
+		{
+			if (ubcsp_config.receive_packet->reliable)
+			{
+				/* If the packet we've just received was reliable
+				   then send an ACK */
+
+				ubcsp_config.send_ack = 1;
+
+				/* We the sequence number we received is the same as 
+				   the last ACK we sent, then we have received a packet in sequence */
+
+				if (receive_seq == ubcsp_config.ack_number)
+				{
+					/* Increase the ACK number - which will be sent in the next ACK 
+					   or normal packet we send */
+
+					ubcsp_config.ack_number ++;
+
+					/* Set the values in the receive_packet structure, so the caller
+					   knows how much data we have */
+
+					ubcsp_config.receive_packet->length = length;
+					ubcsp_config.receive_packet = 0;
+
+					/* Tell the caller that we have received a packet, and that it
+					   will be ACK'ed */
+
+					activity |= UBCSP_PACKET_RECEIVED | UBCSP_PACKET_ACK;
+				}
+			}
+			else 
+			{
+				/* Set the values in the receive_packet structure, so the caller
+				   knows how much data we have */
+
+				ubcsp_config.receive_packet->length = length;
+				ubcsp_config.receive_packet = 0;
+
+				/* Tell the caller that we have received a packet */
+
+				activity |= UBCSP_PACKET_RECEIVED;
+			}
+		}
+	}
+
+	/* Just return any activity that occurred */
+
+	return activity;
+}
+
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp_setup_packet                                                      **/
+/**                                                                         **/
+/** This function is called to setup a packet to be sent                    **/
+/** This allows just a header, or a header and payload to be sent           **/
+/** It also allows the header checksum to be precalcuated                   **/
+/** or calculated here                                                      **/
+/** part1 is always 4 bytes                                                 **/
+/**                                                                         **/
+/*****************************************************************************/
+
+static void ubcsp_setup_packet (uint8 *part1, uint8 calc, uint8 *part2, uint16 len2)
+{
+	/* If we need to calculate the checksum, do that now */
+
+	if (calc)
+	{
+		part1[3] =
+			~(part1[0] + part1[1] + part1[2]);
+	}
+
+	/* Setup the header send pointer and size so we can clock this out */
+
+	ubcsp_config.send_ptr = part1;
+	ubcsp_config.send_size = 4;
+
+	/* Setup the payload send pointer and size */
+
+	ubcsp_config.next_send_ptr = part2;
+	ubcsp_config.next_send_size = len2;
+
+#if UBCSP_CRC
+	/* Initialize the crc as required */
+
+	ubcsp_config.send_crc = -1;
+
+	ubcsp_config.need_send_crc = 1;
+#endif
+}
+
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp_sent_packet                                                       **/
+/**                                                                         **/
+/** Called when we have finished sending a packet                           **/
+/** If this packet was unreliable, then notify caller, and clear the data   **/
+/**                                                                         **/
+/*****************************************************************************/
+
+static uint8 ubcsp_sent_packet (void)
+{
+	if (ubcsp_config.send_packet)
+	{
+		if (!ubcsp_config.send_packet->reliable)
+		{
+			/* We had a packet sent that was unreliable */
+
+			/* Forget about this packet */
+
+			ubcsp_config.send_packet = 0;
+
+			/* Notify caller that they can send another one */
+
+			return UBCSP_PACKET_SENT;
+		}
+	}
+
+	/* We didn't have a packet, or it was reliable
+	   Must wait for ACK before allowing another packet to be sent */
+
+	return 0;
+}
+
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp_poll                                                              **/
+/**                                                                         **/
+/** This is the main function for ubcsp                                     **/
+/** It performs a number of tasks                                           **/
+/**                                                                         **/
+/** 1) Send another octet to the UART - escaping as required                **/
+/** 2) Setup the payload to be sent after the header has been sent          **/
+/** 3) Send the CRC for the packet if required                              **/
+/**                                                                         **/
+/** 4) Calculate the next Link Establishment State                          **/
+/** 5) Send a Link Establishment packet                                     **/
+/** 6) Send a normal packet if available                                    **/
+/** 7) Send an ACK packet if required                                       **/
+/**                                                                         **/
+/** 8) Receive octets from UART and deslip them as required                 **/
+/** 9) Place received octets into receive header or receive payload buffer  **/
+/** 10) Process received packet when SLIP_END is received                   **/
+/**                                                                         **/
+/** 11) Keep track of ability of caller to delay recalling                  **/
+/**                                                                         **/
+/*****************************************************************************/
+
+uint8 ubcsp_poll (uint8 *activity)
+{
+	uint8
+		delay = UBCSP_POLL_TIME_IMMEDIATE;
+
+	uint8
+		value;
+
+	/* Assume no activity to start with */
+
+	*activity = 0;
+
+	/* If we don't have to delay, then send something if we can */
+
+	if (!ubcsp_config.delay)
+	{
+		/* Do we have something we are sending to send */
+
+		if (ubcsp_config.send_size)
+		{
+			/* We have something to send so send it */
+
+			if (ubcsp_config.send_slip_escape)
+			{
+				/* Last time we send a SLIP_ESCAPE octet
+				   this time send the second escape code */
+
+				put_uart (ubcsp_config.send_slip_escape);
+
+				ubcsp_config.send_slip_escape = 0;
+			}
+			else
+			{
+#if UBCSP_CRC
+				/* get the value to send, and calculate CRC as we go */
+
+				value = *ubcsp_config.send_ptr ++;
+
+				ubcsp_config.send_crc = ubcsp_calc_crc (value, ubcsp_config.send_crc);
+
+				/* Output the octet */
+
+				ubcsp_put_slip_uart (value);
+#else
+				/* Just output the octet*/
+
+				ubcsp_put_slip_uart (*ubcsp_config.send_ptr ++);
+#endif
+			}
+
+			/* If we did output a SLIP_ESCAPE, then don't process the end of a block */
+
+			if ((!ubcsp_config.send_slip_escape) && ((ubcsp_config.send_size = ubcsp_config.send_size - 1) == 0))
+			{
+				/*** We are at the end of a block - either header or payload ***/
+
+				/* setup the next block */
+
+				ubcsp_config.send_ptr = ubcsp_config.next_send_ptr;
+				ubcsp_config.send_size = ubcsp_config.next_send_size;
+				ubcsp_config.next_send_ptr = 0;
+				ubcsp_config.next_send_size = 0;
+
+#if UBCSP_CRC
+				/* If we have no successor block
+				   then we might need to send the CRC */
+
+				if (!ubcsp_config.send_ptr)
+				{
+					if (ubcsp_config.need_send_crc)
+					{
+						/* reverse the CRC from what we computed along the way */
+
+						ubcsp_config.need_send_crc = 0;
+
+						ubcsp_config.send_crc = ubcsp_crc_reverse (ubcsp_config.send_crc);
+
+						/* Save in the send_crc buffer */
+
+						ubcsp_send_crc[0] = (uint8) (ubcsp_config.send_crc >> 8);
+						ubcsp_send_crc[1] = (uint8) ubcsp_config.send_crc;
+
+						/* Setup to send this buffer */
+
+						ubcsp_config.send_ptr = ubcsp_send_crc;
+						ubcsp_config.send_size = 2;
+					}
+					else
+					{
+						/* We don't need to send the crc
+						   either we just have, or this packet doesn't include it */
+
+						/* Output the end of FRAME marker */
+
+						put_uart (SLIP_FRAME);
+
+						/* Check if this is an unreliable packet */
+
+						*activity |= ubcsp_sent_packet ();
+
+						/* We've sent the packet, so don't need to have be called quickly soon */
+
+						delay = UBCSP_POLL_TIME_DELAY;
+					}
+				}
+#else
+				/* If we have no successor block
+				   then we might need to send the CRC */
+
+				if (!ubcsp_config.send_ptr)
+				{
+					/* Output the end of FRAME marker */
+
+					put_uart (SLIP_FRAME);
+
+					/* Check if this is an unreliable packet */
+
+					*activity |= ubcsp_sent_packet ();
+
+					/* We've sent the packet, so don't need to have be called quickly soon */
+
+					delay = UBCSP_POLL_TIME_DELAY;
+				}
+#endif
+			}
+		}
+		else if (ubcsp_config.link_establishment_packet == ubcsp_le_none)
+		{
+			/* We didn't have something to send
+			   AND we have no Link Establishment packet to send */
+
+			if (ubcsp_config.link_establishment_resp & 2)
+			{
+				/* Send the start of FRAME packet */
+
+				put_uart (SLIP_FRAME);
+
+				/* We did require a RESP packet - so setup the send */
+
+				ubcsp_setup_packet ((uint8*) ubcsp_send_le_header, 0, (uint8*) ubcsp_le_buffer[ubcsp_le_conf_resp], 4);
+
+				/* We have now "sent" this packet */
+
+				ubcsp_config.link_establishment_resp = 0;
+			}
+			else if (ubcsp_config.send_packet)
+			{
+				/* There is a packet ready to be sent */
+
+				/* Send the start of FRAME packet */
+
+				put_uart (SLIP_FRAME);
+
+				/* Encode up the packet header using ACK and SEQ numbers */
+
+				ubcsp_send_header[0] =
+					(ubcsp_config.send_packet->reliable << 7) |
+#if UBCSP_CRC
+					0x40 |	/* Always use CRC's */
+#endif
+					(ubcsp_config.ack_number << 3) | 
+					(ubcsp_config.sequence_number);
+
+				/* Encode up the packet header's channel and length */
+				ubcsp_send_header[1] =
+					(ubcsp_config.send_packet->channel & 0x0f) |
+					((ubcsp_config.send_packet->length << 4) & 0xf0);
+
+				ubcsp_send_header[2] =
+					(ubcsp_config.send_packet->length >> 4) & 0xff;
+
+				/* Let the ubcsp_setup_packet function calculate the header checksum */
+
+				ubcsp_setup_packet ((uint8*) ubcsp_send_header, 1, ubcsp_config.send_packet->payload, ubcsp_config.send_packet->length);
+
+				/* Don't need to send an ACK - we just place on in this packet */
+
+				ubcsp_config.send_ack = 0;
+				
+#if SHOW_PACKET_ERRORS
+				printf (" : %10d Send %d Ack %d\n",
+					GetTickCount () % 100000,
+					ubcsp_config.sequence_number,
+					ubcsp_config.ack_number);
+#endif
+			}
+			else if (ubcsp_config.send_ack)
+			{
+				/* Send the start of FRAME packet */
+
+				put_uart (SLIP_FRAME);
+
+#if SHOW_PACKET_ERRORS
+				printf (" : %10d Send ACK %d\n",
+					GetTickCount () % 100000,
+					ubcsp_config.ack_number);
+#endif
+
+				/* The ack packet is already computed apart from the first octet */
+
+				ubcsp_send_ack_header[0] =
+#if UBCSP_CRC
+					0x40 | 
+#endif
+					(ubcsp_config.ack_number << 3);
+
+				/* Let the ubcsp_setup_packet function calculate the header checksum */
+
+				ubcsp_setup_packet (ubcsp_send_ack_header, 1, 0, 0);
+
+				/* We've now sent the ack */
+
+				ubcsp_config.send_ack = 0;
+			}
+			else
+			{
+				/* We didn't have a Link Establishment response packet,
+				   a normal packet or an ACK packet to send */
+
+				delay = UBCSP_POLL_TIME_DELAY;
+			}
+		}
+		else
+		{
+#if SHOW_PACKET_ERRORS
+//			printf (" : %10d Send LE %d\n",
+//				GetTickCount () % 100000,
+//				ubcsp_config.link_establishment_packet);
+#endif
+
+			/* Send A Link Establishment Message */
+
+			put_uart (SLIP_FRAME);
+
+			/* Send the Link Establishment header followed by the 
+			   Link Establishment packet */
+
+			ubcsp_setup_packet ((uint8*) ubcsp_send_le_header, 0, (uint8*) ubcsp_le_buffer[ubcsp_config.link_establishment_packet], 4);
+
+			/* start sending immediately */
+
+			ubcsp_config.delay = 0;
+
+			/* workout what the next link establishment packet should be */
+
+			ubcsp_config.link_establishment_packet = next_le_packet[ubcsp_config.link_establishment_state + ubcsp_config.link_establishment_resp * 4];
+
+			/* We have now delt with any response packet that we needed */
+
+			ubcsp_config.link_establishment_resp = 0;
+
+			return 0;
+		}
+	}
+
+	/* We now need to receive any octets from the UART */
+
+	while ((ubcsp_config.receive_packet) && (get_uart (&value)))
+	{
+		/* If the last octet was SLIP_ESCAPE, then special processing is required */
+
+		if (ubcsp_config.receive_slip_escape)
+		{
+			/* WARNING - out of range values are not detected !!!
+			   This will probably be caught with the checksum or CRC check */
+
+			value = ubcsp_deslip[value - SLIP_ESCAPE_FRAME];
+
+			ubcsp_config.receive_slip_escape = 0;
+		}
+		else
+		{
+			/* Check for the SLIP_FRAME octet - must be start or end of packet */
+			if (value == SLIP_FRAME)
+			{
+				/* If we had a full header then we have a packet */
+
+				if (ubcsp_config.receive_index >= 0)
+				{
+					/* process the received packet */
+
+					*activity |= ubcsp_recevied_packet ();
+
+					if (*activity & UBCSP_PACKET_ACK)
+					{
+						/* We need to ACK this packet, then don't delay its sending */
+						ubcsp_config.delay = 0;
+					}
+				}
+
+				/* Setup to receive the next packet */
+
+				ubcsp_config.receive_index = -4;
+
+				/* Ok, next octet */
+
+				goto finished_receive;
+			}
+			else if (value == SLIP_ESCAPE)
+			{
+				/* If we receive a SLIP_ESCAPE,
+				   then remember to process the next special octet */
+
+				ubcsp_config.receive_slip_escape = 1;
+
+				goto finished_receive;
+			}
+		}
+
+		if (ubcsp_config.receive_index < 0)
+		{
+			/* We are still receiving the header */
+
+			ubcsp_receive_header[ubcsp_config.receive_index + 4] = value;
+
+			ubcsp_config.receive_index ++;
+		}
+		else if (ubcsp_config.receive_index < ubcsp_config.receive_packet->length)
+		{
+			/* We are receiving the payload */
+			/* We might stop coming here if we are receiving a
+			   packet which is longer than the receive_packet->length
+			   given by the host */
+
+			ubcsp_config.receive_packet->payload[ubcsp_config.receive_index] = value;
+
+			ubcsp_config.receive_index ++;
+		}
+
+finished_receive:
+		{
+		}
+	}
+
+	if (ubcsp_config.delay > 0)
+	{
+		/* We were delayed so delay some more
+		   this could be cancelled if we received something */
+
+		ubcsp_config.delay --;
+	}
+	else
+	{
+		/* We had no delay, so use the delay we just decided to us */
+
+		ubcsp_config.delay = delay;
+	}
+
+	/* Report the current delay to the user */
+
+	return ubcsp_config.delay;
+}
diff --git a/tools/ubcsp.h b/tools/ubcsp.h
new file mode 100644
index 000000000..6a74e9a16
--- /dev/null
+++ b/tools/ubcsp.h
@@ -0,0 +1,208 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2000-2005  CSR Ltd.
+ *
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be included
+ *  in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ *  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ *  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ *  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ *  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef UBCSP_INCLUDE_H
+#define UBCSP_INCLUDE_H
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp.h                                                                 **/
+/**                                                                         **/
+/** MicroBCSP - a very low cost implementation of the BCSP protocol         **/
+/**                                                                         **/
+/*****************************************************************************/
+
+/* If we wish to use CRC's, then change 0 to 1 in the next line */
+#define UBCSP_CRC 1
+
+/* Define some basic types - change these for your architecture */
+typedef unsigned char uint8;
+typedef unsigned short uint16;
+typedef unsigned int uint32;
+typedef signed char int8;
+typedef signed short int16;
+typedef signed int int32;
+
+/* The defines below require a printf function to be available */
+
+/* Do we want to show packet errors in debug output */
+#define SHOW_PACKET_ERRORS	0
+
+/* Do we want to show Link Establishment State transitions in debug output */
+#define SHOW_LE_STATES		0
+
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp_packet                                                            **/
+/**                                                                         **/
+/** This is description of a bcsp packet for the upper layer                **/
+/**                                                                         **/
+/*****************************************************************************/
+
+struct ubcsp_packet
+{
+	uint8 channel;		/* Which Channel this packet is to/from */
+	uint8 reliable;		/* Is this packet reliable */
+	uint8 use_crc;		/* Does this packet use CRC data protection */
+	uint16 length;		/* What is the length of the payload data */
+	uint8 *payload;		/* The payload data itself - size of length */
+};
+
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp_configuration                                                     **/
+/**                                                                         **/
+/** This is the main configuration of the ubcsp engine                      **/
+/** All state variables are stored in this structure                        **/
+/**                                                                         **/
+/*****************************************************************************/
+
+enum ubcsp_link_establishment_state
+{
+	ubcsp_le_uninitialized,
+	ubcsp_le_initialized,
+	ubcsp_le_active
+};
+
+enum ubcsp_link_establishment_packet
+{
+	ubcsp_le_sync,
+	ubcsp_le_sync_resp,
+	ubcsp_le_conf,
+	ubcsp_le_conf_resp,
+	ubcsp_le_none
+};
+
+struct ubcsp_configuration
+{
+	uint8 link_establishment_state;
+	uint8 link_establishment_resp;
+	uint8 link_establishment_packet;
+
+	uint8 sequence_number:3;
+	uint8 ack_number:3;
+	uint8 send_ack;
+	struct ubcsp_packet *send_packet;
+	struct ubcsp_packet *receive_packet;
+
+	uint8 receive_header_checksum;
+	uint8 receive_slip_escape;
+	int32 receive_index;
+
+	uint8 send_header_checksum;
+#ifdef UBCSP_CRC
+	uint8 need_send_crc;
+	uint16 send_crc;
+#endif
+	uint8 send_slip_escape;
+
+	uint8 *send_ptr;
+	int32 send_size;
+	uint8 *next_send_ptr;
+	int32 next_send_size;
+
+	int8 delay;
+};
+
+/*****************************************************************************/
+/**                                                                         **/
+/** ubcsp_poll sets activity from an OR of these flags                      **/
+/**                                                                         **/
+/*****************************************************************************/
+
+#define UBCSP_PACKET_SENT 0x01
+#define UBCSP_PACKET_RECEIVED 0x02
+#define UBCSP_PEER_RESET 0x04
+#define UBCSP_PACKET_ACK 0x08
+
+/*****************************************************************************/
+/**                                                                         **/
+/** This is the functional interface for ucbsp                              **/
+/**                                                                         **/
+/*****************************************************************************/
+
+void ubcsp_initialize (void);
+void ubcsp_send_packet (struct ubcsp_packet *send_packet);
+void ubcsp_receive_packet (struct ubcsp_packet *receive_packet);
+uint8 ubcsp_poll (uint8 *activity);
+
+/*****************************************************************************/
+/**                                                                         **/
+/** Slip Escape Values                                                      **/
+/**                                                                         **/
+/*****************************************************************************/
+
+#define SLIP_FRAME 0xC0
+#define SLIP_ESCAPE 0xDB
+#define SLIP_ESCAPE_FRAME 0xDC
+#define SLIP_ESCAPE_ESCAPE 0xDD
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*****************************************************************************/
+
+/*****************************************************************************/
+/**                                                                         **/
+/** These functions need to be linked into your system                      **/
+/**                                                                         **/
+/*****************************************************************************/
+
+/*****************************************************************************/
+/**                                                                         **/
+/** put_uart outputs a single octet over the UART Tx line                   **/
+/**                                                                         **/
+/*****************************************************************************/
+
+extern void put_uart (uint8);
+
+/*****************************************************************************/
+/**                                                                         **/
+/** get_uart receives a single octet over the UART Rx line                  **/
+/** if no octet is available, then this returns 0                           **/
+/** if an octet was read, then this is returned in the argument and         **/
+/**   the function returns 1                                                **/
+/**                                                                         **/
+/*****************************************************************************/
+
+extern uint8 get_uart (uint8 *);
+
+/*****************************************************************************/
+/**                                                                         **/
+/** These defines should be changed to your systems concept of 100ms        **/
+/**                                                                         **/
+/*****************************************************************************/
+
+#define UBCSP_POLL_TIME_IMMEDIATE   0
+#define UBCSP_POLL_TIME_DELAY       25
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*****************************************************************************/
+#endif
-- 
2.36.0

