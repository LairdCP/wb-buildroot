From b9a5922c36d77d1c6bb90fdc5225b5c838e5aa39 Mon Sep 17 00:00:00 2001
From: Zuzana Svetlikova <zsvetlik@redhat.com>
Date: Wed, 19 Feb 2020 10:31:43 +0000
Subject: [PATCH 3/4] fix failing tests

---
 doc/api/cli.md                                     |   5 +-
 test/doctool/test-make-doc.js                      |  63 ------
 test/known_issues/test-crypto-aes-wrap.js          |  62 ++++++
 test/known_issues/test-crypto-des3-wrap.js         |  25 +++
 test/known_issues/test-crypto-hash-stream-pipe.js  |  46 ++++
 test/known_issues/test-make-doc.js                 |  63 ++++++
 test/known_issues/test-tls-cli-max-version-1.3.js  |  15 ++
 test/known_issues/test-tls-cli-min-max-conflict.js |  14 ++
 test/known_issues/test-tls-cli-min-version-1.3.js  |  15 ++
 .../test-tls-client-renegotiation-13.js            |  41 ++++
 test/known_issues/test-tls-keylog-tlsv13.js        |  32 +++
 test/known_issues/test-tls-no-sslv3.js             |  49 +++++
 test/known_issues/test-tls-ticket-12.js            |  12 +
 test/known_issues/test-tls-ticket-cluster.js       | 135 ++++++++++++
 test/known_issues/test-tls-ticket.js               | 159 ++++++++++++++
 test/known_issues/test-v8-serdes.js                | 244 +++++++++++++++++++++
 test/parallel/test-crypto-aes-wrap.js              |  62 ------
 test/parallel/test-crypto-authenticated.js         |  54 +----
 test/parallel/test-crypto-des3-wrap.js             |  25 ---
 test/parallel/test-crypto-hash-stream-pipe.js      |  46 ----
 test/parallel/test-crypto-hash.js                  |  81 -------
 test/parallel/test-crypto-key-objects.js           | 175 ---------------
 test/parallel/test-crypto-keygen.js                |  54 -----
 test/parallel/test-crypto-pbkdf2.js                |  18 --
 test/parallel/test-crypto-sign-verify.js           |   8 -
 test/parallel/test-crypto.js                       |   6 +-
 test/parallel/test-https-agent-session-eviction.js |  42 +++-
 test/parallel/test-tls-alert-handling.js           |   2 +-
 test/parallel/test-tls-cli-max-version-1.3.js      |  15 --
 test/parallel/test-tls-cli-min-max-conflict.js     |  14 --
 test/parallel/test-tls-cli-min-version-1.0.js      |   2 +-
 test/parallel/test-tls-cli-min-version-1.1.js      |   2 +-
 test/parallel/test-tls-cli-min-version-1.2.js      |   2 +-
 test/parallel/test-tls-cli-min-version-1.3.js      |  15 --
 .../test-tls-client-getephemeralkeyinfo.js         |   2 -
 test/parallel/test-tls-client-renegotiation-13.js  |  41 ----
 test/parallel/test-tls-destroy-stream.js           |   2 +-
 test/parallel/test-tls-getcipher.js                |  25 +--
 test/parallel/test-tls-keylog-tlsv13.js            |  32 ---
 test/parallel/test-tls-min-max-version.js          |  29 +--
 test/parallel/test-tls-multi-key.js                |   4 +-
 test/parallel/test-tls-multi-pfx.js                |   4 +-
 test/parallel/test-tls-no-sslv3.js                 |  49 -----
 test/parallel/test-tls-passphrase.js               |   2 +-
 test/parallel/test-tls-set-ciphers.js              |  27 +--
 test/parallel/test-tls-ticket-12.js                |  12 -
 test/parallel/test-tls-ticket-cluster.js           | 135 ------------
 test/parallel/test-tls-ticket.js                   | 159 --------------
 test/parallel/test-v8-serdes.js                    | 244 ---------------------
 49 files changed, 973 insertions(+), 1397 deletions(-)
 delete mode 100644 test/doctool/test-make-doc.js
 create mode 100644 test/known_issues/test-crypto-aes-wrap.js
 create mode 100644 test/known_issues/test-crypto-des3-wrap.js
 create mode 100644 test/known_issues/test-crypto-hash-stream-pipe.js
 create mode 100644 test/known_issues/test-make-doc.js
 create mode 100644 test/known_issues/test-tls-cli-max-version-1.3.js
 create mode 100644 test/known_issues/test-tls-cli-min-max-conflict.js
 create mode 100644 test/known_issues/test-tls-cli-min-version-1.3.js
 create mode 100644 test/known_issues/test-tls-client-renegotiation-13.js
 create mode 100644 test/known_issues/test-tls-keylog-tlsv13.js
 create mode 100644 test/known_issues/test-tls-no-sslv3.js
 create mode 100644 test/known_issues/test-tls-ticket-12.js
 create mode 100644 test/known_issues/test-tls-ticket-cluster.js
 create mode 100644 test/known_issues/test-tls-ticket.js
 create mode 100644 test/known_issues/test-v8-serdes.js
 delete mode 100644 test/parallel/test-crypto-aes-wrap.js
 delete mode 100644 test/parallel/test-crypto-des3-wrap.js
 delete mode 100644 test/parallel/test-crypto-hash-stream-pipe.js
 delete mode 100644 test/parallel/test-tls-cli-max-version-1.3.js
 delete mode 100644 test/parallel/test-tls-cli-min-max-conflict.js
 delete mode 100644 test/parallel/test-tls-cli-min-version-1.3.js
 delete mode 100644 test/parallel/test-tls-client-renegotiation-13.js
 delete mode 100644 test/parallel/test-tls-keylog-tlsv13.js
 delete mode 100644 test/parallel/test-tls-no-sslv3.js
 delete mode 100644 test/parallel/test-tls-ticket-12.js
 delete mode 100644 test/parallel/test-tls-ticket-cluster.js
 delete mode 100644 test/parallel/test-tls-ticket.js
 delete mode 100644 test/parallel/test-v8-serdes.js

diff --git a/doc/api/cli.md b/doc/api/cli.md
index ecf7632..15124c5 100644
--- a/doc/api/cli.md
+++ b/doc/api/cli.md
@@ -711,8 +711,7 @@ with crypto support (default).
 added: v12.0.0
 -->
 
-Set [`tls.DEFAULT_MAX_VERSION`][] to 'TLSv1.2'. Use to disable support for
-TLSv1.3.
+Set [`tls.DEFAULT_MAX_VERSION`][] to 'TLSv1.2'.
 
 ### `--tls-min-v1.0`
 <!-- YAML
@@ -1094,11 +1093,9 @@ Node.js options that are allowed are:
 * `--title`
 * `--tls-cipher-list`
 * `--tls-max-v1.2`
-* `--tls-max-v1.3`
 * `--tls-min-v1.0`
 * `--tls-min-v1.1`
 * `--tls-min-v1.2`
-* `--tls-min-v1.3`
 * `--trace-deprecation`
 * `--trace-event-categories`
 * `--trace-event-file-pattern`
diff --git a/test/doctool/test-make-doc.js b/test/doctool/test-make-doc.js
deleted file mode 100644
index 7f4f3ae..0000000
--- a/test/doctool/test-make-doc.js
+++ /dev/null
@@ -1,63 +0,0 @@
-'use strict';
-const common = require('../common');
-if (common.isWindows) {
-  common.skip('`make doc` does not run on Windows');
-}
-
-// This tests that `make doc` generates the documentation properly.
-// Note that for this test to pass, `make doc` must be run first.
-
-const assert = require('assert');
-const fs = require('fs');
-const path = require('path');
-
-const apiPath = path.resolve(__dirname, '..', '..', 'out', 'doc', 'api');
-const mdPath = path.resolve(__dirname, '..', '..', 'doc', 'api');
-const allMD = fs.readdirSync(mdPath);
-const allDocs = fs.readdirSync(apiPath);
-assert.ok(allDocs.includes('index.html'));
-
-const actualDocs = allDocs.filter(
-  (name) => {
-    const extension = path.extname(name);
-    return extension === '.html' || extension === '.json';
-  }
-);
-
-for (const name of actualDocs) {
-  if (name.startsWith('all.')) continue;
-
-  assert.ok(
-    allMD.includes(name.replace(/\.\w+$/, '.md')),
-    `Unexpected output: out/doc/api/${name}, remove and rerun.`
-  );
-}
-
-const toc = fs.readFileSync(path.resolve(apiPath, 'index.html'), 'utf8');
-const re = /href="([^/]+\.html)"/;
-const globalRe = new RegExp(re, 'g');
-const links = toc.match(globalRe);
-assert.notStrictEqual(links, null);
-
-// Filter out duplicate links, leave just filenames, add expected JSON files.
-const linkedHtmls = [...new Set(links)].map((link) => link.match(re)[1]);
-const expectedJsons = linkedHtmls
-                       .map((name) => name.replace('.html', '.json'));
-const expectedDocs = linkedHtmls.concat(expectedJsons);
-
-// Test that all the relative links in the TOC match to the actual documents.
-for (const expectedDoc of expectedDocs) {
-  assert.ok(actualDocs.includes(expectedDoc), `${expectedDoc} does not exist`);
-}
-
-// Test that all the actual documents match to the relative links in the TOC
-// and that they are not empty files.
-for (const actualDoc of actualDocs) {
-  assert.ok(
-    expectedDocs.includes(actualDoc), `${actualDoc} does not match TOC`);
-
-  assert.ok(
-    fs.statSync(path.join(apiPath, actualDoc)).size !== 0,
-    `${actualDoc} is empty`
-  );
-}
diff --git a/test/known_issues/test-crypto-aes-wrap.js b/test/known_issues/test-crypto-aes-wrap.js
new file mode 100644
index 0000000..6fe3525
--- /dev/null
+++ b/test/known_issues/test-crypto-aes-wrap.js
@@ -0,0 +1,62 @@
+'use strict';
+const common = require('../common');
+if (!common.hasCrypto)
+  common.skip('missing crypto');
+
+const assert = require('assert');
+const crypto = require('crypto');
+
+const test = [
+  {
+    algorithm: 'aes128-wrap',
+    key: 'b26f309fbe57e9b3bb6ae5ef31d54450',
+    iv: '3fd838af4093d749',
+    text: '12345678123456781234567812345678'
+  },
+  {
+    algorithm: 'id-aes128-wrap-pad',
+    key: 'b26f309fbe57e9b3bb6ae5ef31d54450',
+    iv: '3fd838af',
+    text: '12345678123456781234567812345678123'
+  },
+  {
+    algorithm: 'aes192-wrap',
+    key: '40978085d68091f7dfca0d7dfc7a5ee76d2cc7f2f345a304',
+    iv: '3fd838af4093d749',
+    text: '12345678123456781234567812345678'
+  },
+  {
+    algorithm: 'id-aes192-wrap-pad',
+    key: '40978085d68091f7dfca0d7dfc7a5ee76d2cc7f2f345a304',
+    iv: '3fd838af',
+    text: '12345678123456781234567812345678123'
+  },
+  {
+    algorithm: 'aes256-wrap',
+    key: '29c9eab5ed5ad44134a1437fe2e673b4d88a5b7c72e68454fea08721392b7323',
+    iv: '3fd838af4093d749',
+    text: '12345678123456781234567812345678'
+  },
+  {
+    algorithm: 'id-aes256-wrap-pad',
+    key: '29c9eab5ed5ad44134a1437fe2e673b4d88a5b7c72e68454fea08721392b7323',
+    iv: '3fd838af',
+    text: '12345678123456781234567812345678123'
+  },
+];
+
+test.forEach((data) => {
+  const cipher = crypto.createCipheriv(
+    data.algorithm,
+    Buffer.from(data.key, 'hex'),
+    Buffer.from(data.iv, 'hex'));
+  const ciphertext = cipher.update(data.text, 'utf8');
+
+  const decipher = crypto.createDecipheriv(
+    data.algorithm,
+    Buffer.from(data.key, 'hex'),
+    Buffer.from(data.iv, 'hex'));
+  const msg = decipher.update(ciphertext, 'buffer', 'utf8');
+
+  assert.strictEqual(msg, data.text, `${data.algorithm} test case failed`);
+});
diff --git a/test/known_issues/test-crypto-des3-wrap.js b/test/known_issues/test-crypto-des3-wrap.js
new file mode 100644
index 0000000..75c8cd5
--- /dev/null
+++ b/test/known_issues/test-crypto-des3-wrap.js
@@ -0,0 +1,25 @@
+'use strict';
+const common = require('../common');
+if (!common.hasCrypto)
+  common.skip('missing crypto');
+
+const assert = require('assert');
+const crypto = require('crypto');
+
+// Test case for des-ede3 wrap/unwrap. des3-wrap needs extra 2x blocksize
+// then plaintext to store ciphertext.
+const test = {
+  key: Buffer.from('3c08e25be22352910671cfe4ba3652b1220a8a7769b490ba', 'hex'),
+  iv: Buffer.alloc(0),
+  plaintext: '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBG' +
+    'WWELweCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZU' +
+    'JjAfaFg**'
+};
+
+const cipher = crypto.createCipheriv('des3-wrap', test.key, test.iv);
+const ciphertext = cipher.update(test.plaintext, 'utf8');
+
+const decipher = crypto.createDecipheriv('des3-wrap', test.key, test.iv);
+const msg = decipher.update(ciphertext, 'buffer', 'utf8');
+
+assert.strictEqual(msg, test.plaintext);
diff --git a/test/known_issues/test-crypto-hash-stream-pipe.js b/test/known_issues/test-crypto-hash-stream-pipe.js
new file mode 100644
index 0000000..d22281a
--- /dev/null
+++ b/test/known_issues/test-crypto-hash-stream-pipe.js
@@ -0,0 +1,46 @@
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+'use strict';
+const common = require('../common');
+
+if (!common.hasCrypto)
+  common.skip('missing crypto');
+
+const assert = require('assert');
+const crypto = require('crypto');
+
+const stream = require('stream');
+const s = new stream.PassThrough();
+const h = crypto.createHash('sha3-512');
+const expect = '36a38a2a35e698974d4e5791a3f05b05' +
+               '198235381e864f91a0e8cd6a26b677ec' +
+               'dcde8e2b069bd7355fabd68abd6fc801' +
+               '19659f25e92f8efc961ee3a7c815c758';
+
+s.pipe(h).on('data', common.mustCall(function(c) {
+  assert.strictEqual(c, expect);
+  // Calling digest() after piping into a stream with SHA3 should not cause
+  // a segmentation fault, see https://github.com/nodejs/node/issues/28245.
+  assert.strictEqual(h.digest('hex'), expect);
+})).setEncoding('hex');
+
+s.end('aoeu');
diff --git a/test/known_issues/test-make-doc.js b/test/known_issues/test-make-doc.js
new file mode 100644
index 0000000..7f4f3ae
--- /dev/null
+++ b/test/known_issues/test-make-doc.js
@@ -0,0 +1,63 @@
+'use strict';
+const common = require('../common');
+if (common.isWindows) {
+  common.skip('`make doc` does not run on Windows');
+}
+
+// This tests that `make doc` generates the documentation properly.
+// Note that for this test to pass, `make doc` must be run first.
+
+const assert = require('assert');
+const fs = require('fs');
+const path = require('path');
+
+const apiPath = path.resolve(__dirname, '..', '..', 'out', 'doc', 'api');
+const mdPath = path.resolve(__dirname, '..', '..', 'doc', 'api');
+const allMD = fs.readdirSync(mdPath);
+const allDocs = fs.readdirSync(apiPath);
+assert.ok(allDocs.includes('index.html'));
+
+const actualDocs = allDocs.filter(
+  (name) => {
+    const extension = path.extname(name);
+    return extension === '.html' || extension === '.json';
+  }
+);
+
+for (const name of actualDocs) {
+  if (name.startsWith('all.')) continue;
+
+  assert.ok(
+    allMD.includes(name.replace(/\.\w+$/, '.md')),
+    `Unexpected output: out/doc/api/${name}, remove and rerun.`
+  );
+}
+
+const toc = fs.readFileSync(path.resolve(apiPath, 'index.html'), 'utf8');
+const re = /href="([^/]+\.html)"/;
+const globalRe = new RegExp(re, 'g');
+const links = toc.match(globalRe);
+assert.notStrictEqual(links, null);
+
+// Filter out duplicate links, leave just filenames, add expected JSON files.
+const linkedHtmls = [...new Set(links)].map((link) => link.match(re)[1]);
+const expectedJsons = linkedHtmls
+                       .map((name) => name.replace('.html', '.json'));
+const expectedDocs = linkedHtmls.concat(expectedJsons);
+
+// Test that all the relative links in the TOC match to the actual documents.
+for (const expectedDoc of expectedDocs) {
+  assert.ok(actualDocs.includes(expectedDoc), `${expectedDoc} does not exist`);
+}
+
+// Test that all the actual documents match to the relative links in the TOC
+// and that they are not empty files.
+for (const actualDoc of actualDocs) {
+  assert.ok(
+    expectedDocs.includes(actualDoc), `${actualDoc} does not match TOC`);
+
+  assert.ok(
+    fs.statSync(path.join(apiPath, actualDoc)).size !== 0,
+    `${actualDoc} is empty`
+  );
+}
diff --git a/test/known_issues/test-tls-cli-max-version-1.3.js b/test/known_issues/test-tls-cli-max-version-1.3.js
new file mode 100644
index 0000000..c04354f
--- /dev/null
+++ b/test/known_issues/test-tls-cli-max-version-1.3.js
@@ -0,0 +1,15 @@
+// Flags: --tls-max-v1.3
+'use strict';
+const common = require('../common');
+if (!common.hasCrypto) common.skip('missing crypto');
+
+// Check that node `--tls-max-v1.3` is supported.
+
+const assert = require('assert');
+const tls = require('tls');
+
+assert.strictEqual(tls.DEFAULT_MAX_VERSION, 'TLSv1.3');
+assert.strictEqual(tls.DEFAULT_MIN_VERSION, 'TLSv1.2');
+
+// Check the min-max version protocol versions against these CLI settings.
+require('./test-tls-min-max-version.js');
diff --git a/test/known_issues/test-tls-cli-min-max-conflict.js b/test/known_issues/test-tls-cli-min-max-conflict.js
new file mode 100644
index 0000000..68aae4c
--- /dev/null
+++ b/test/known_issues/test-tls-cli-min-max-conflict.js
@@ -0,0 +1,14 @@
+'use strict';
+const common = require('../common');
+if (!common.hasCrypto) common.skip('missing crypto');
+
+// Check that conflicting TLS protocol versions are not allowed
+
+const assert = require('assert');
+const child_process = require('child_process');
+
+const args = ['--tls-min-v1.3', '--tls-max-v1.2', '-p', 'process.version'];
+child_process.execFile(process.argv[0], args, (err) => {
+  assert(err);
+  assert(/not both/.test(err.message));
+});
diff --git a/test/known_issues/test-tls-cli-min-version-1.3.js b/test/known_issues/test-tls-cli-min-version-1.3.js
new file mode 100644
index 0000000..1bccc2f
--- /dev/null
+++ b/test/known_issues/test-tls-cli-min-version-1.3.js
@@ -0,0 +1,15 @@
+// Flags: --tls-min-v1.3
+'use strict';
+const common = require('../common');
+if (!common.hasCrypto) common.skip('missing crypto');
+
+// Check that node `--tls-min-v1.3` is supported.
+
+const assert = require('assert');
+const tls = require('tls');
+
+assert.strictEqual(tls.DEFAULT_MAX_VERSION, 'TLSv1.3');
+assert.strictEqual(tls.DEFAULT_MIN_VERSION, 'TLSv1.3');
+
+// Check the min-max version protocol versions against these CLI settings.
+require('./test-tls-min-max-version.js');
diff --git a/test/known_issues/test-tls-client-renegotiation-13.js b/test/known_issues/test-tls-client-renegotiation-13.js
new file mode 100644
index 0000000..075eb70
--- /dev/null
+++ b/test/known_issues/test-tls-client-renegotiation-13.js
@@ -0,0 +1,41 @@
+'use strict';
+
+const common = require('../common');
+const fixtures = require('../common/fixtures');
+
+// Confirm that for TLSv1.3, renegotiate() is disallowed.
+
+const {
+  assert, connect, keys
+} = require(fixtures.path('tls-connect'));
+
+const server = keys.agent10;
+
+connect({
+  client: {
+    ca: server.ca,
+    checkServerIdentity: common.mustCall(),
+  },
+  server: {
+    key: server.key,
+    cert: server.cert,
+  },
+}, function(err, pair, cleanup) {
+  assert.ifError(err);
+
+  const client = pair.client.conn;
+
+  assert.strictEqual(client.getProtocol(), 'TLSv1.3');
+
+  const ok = client.renegotiate({}, common.mustCall((err) => {
+    assert.throws(() => { throw err; }, {
+      message: 'error:1420410A:SSL routines:SSL_renegotiate:wrong ssl version',
+      code: 'ERR_SSL_WRONG_SSL_VERSION',
+      library: 'SSL routines',
+      reason: 'wrong ssl version',
+    });
+    cleanup();
+  }));
+
+  assert.strictEqual(ok, false);
+});
diff --git a/test/known_issues/test-tls-keylog-tlsv13.js b/test/known_issues/test-tls-keylog-tlsv13.js
new file mode 100644
index 0000000..0f65564
--- /dev/null
+++ b/test/known_issues/test-tls-keylog-tlsv13.js
@@ -0,0 +1,32 @@
+'use strict';
+
+const common = require('../common');
+if (!common.hasCrypto)
+  common.skip('missing crypto');
+
+const assert = require('assert');
+const tls = require('tls');
+const fixtures = require('../common/fixtures');
+
+const server = tls.createServer({
+  key: fixtures.readKey('agent2-key.pem'),
+  cert: fixtures.readKey('agent2-cert.pem'),
+  // Amount of keylog events depends on negotiated protocol
+  // version, so force a specific one:
+  minVersion: 'TLSv1.3',
+  maxVersion: 'TLSv1.3',
+}).listen(() => {
+  const client = tls.connect({
+    port: server.address().port,
+    rejectUnauthorized: false,
+  });
+
+  const verifyBuffer = (line) => assert(Buffer.isBuffer(line));
+  server.on('keylog', common.mustCall(verifyBuffer, 5));
+  client.on('keylog', common.mustCall(verifyBuffer, 5));
+
+  client.once('secureConnect', () => {
+    server.close();
+    client.end();
+  });
+});
diff --git a/test/known_issues/test-tls-no-sslv3.js b/test/known_issues/test-tls-no-sslv3.js
new file mode 100644
index 0000000..1acb1f9
--- /dev/null
+++ b/test/known_issues/test-tls-no-sslv3.js
@@ -0,0 +1,49 @@
+'use strict';
+const common = require('../common');
+if (!common.hasCrypto)
+  common.skip('missing crypto');
+
+if (common.opensslCli === false)
+  common.skip('node compiled without OpenSSL CLI.');
+
+const assert = require('assert');
+const tls = require('tls');
+const spawn = require('child_process').spawn;
+const fixtures = require('../common/fixtures');
+
+const cert = fixtures.readKey('rsa_cert.crt');
+const key = fixtures.readKey('rsa_private.pem');
+const server = tls.createServer({ cert, key }, common.mustNotCall());
+const errors = [];
+let stderr = '';
+
+server.listen(0, '127.0.0.1', function() {
+  const address = `${this.address().address}:${this.address().port}`;
+  const args = ['s_client',
+                '-ssl3',
+                '-connect', address];
+
+  const client = spawn(common.opensslCli, args, { stdio: 'pipe' });
+  client.stdout.pipe(process.stdout);
+  client.stderr.pipe(process.stderr);
+  client.stderr.setEncoding('utf8');
+  client.stderr.on('data', (data) => stderr += data);
+
+  client.once('exit', common.mustCall(function(exitCode) {
+    assert.strictEqual(exitCode, 1);
+    server.close();
+  }));
+});
+
+server.on('tlsClientError', (err) => errors.push(err));
+
+process.on('exit', function() {
+  if (/unknown option -ssl3/.test(stderr)) {
+    common.printSkipMessage('`openssl s_client -ssl3` not supported.');
+  } else {
+    assert.strictEqual(errors.length, 1);
+    // OpenSSL 1.0.x and 1.1.x report invalid client versions differently.
+    assert(/:wrong version number/.test(errors[0].message) ||
+           /:version too low/.test(errors[0].message));
+  }
+});
diff --git a/test/known_issues/test-tls-ticket-12.js b/test/known_issues/test-tls-ticket-12.js
new file mode 100644
index 0000000..600c571
--- /dev/null
+++ b/test/known_issues/test-tls-ticket-12.js
@@ -0,0 +1,12 @@
+'use strict';
+const common = require('../common');
+if (!common.hasCrypto)
+  common.skip('missing crypto');
+
+// Run test-tls-ticket.js with TLS1.2
+
+const tls = require('tls');
+
+tls.DEFAULT_MAX_VERSION = 'TLSv1.2';
+
+require('./test-tls-ticket.js');
diff --git a/test/known_issues/test-tls-ticket-cluster.js b/test/known_issues/test-tls-ticket-cluster.js
new file mode 100644
index 0000000..cc4f46e
--- /dev/null
+++ b/test/known_issues/test-tls-ticket-cluster.js
@@ -0,0 +1,135 @@
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+'use strict';
+const common = require('../common');
+if (!common.hasCrypto)
+  common.skip('missing crypto');
+
+const assert = require('assert');
+const tls = require('tls');
+const cluster = require('cluster');
+const fixtures = require('../common/fixtures');
+
+const workerCount = 4;
+const expectedReqCount = 16;
+
+if (cluster.isMaster) {
+  let reusedCount = 0;
+  let reqCount = 0;
+  let lastSession = null;
+  let shootOnce = false;
+  let workerPort = null;
+
+  function shoot() {
+    console.error('[master] connecting', workerPort, 'session?', !!lastSession);
+    const c = tls.connect(workerPort, {
+      session: lastSession,
+      rejectUnauthorized: false
+    }, () => {
+      c.end();
+    }).on('close', () => {
+      // Wait for close to shoot off another connection. We don't want to shoot
+      // until a new session is allocated, if one will be. The new session is
+      // not guaranteed on secureConnect (it depends on TLS1.2 vs TLS1.3), but
+      // it is guaranteed to happen before the connection is closed.
+      if (++reqCount === expectedReqCount) {
+        Object.keys(cluster.workers).forEach(function(id) {
+          cluster.workers[id].send('die');
+        });
+      } else {
+        shoot();
+      }
+    }).once('session', (session) => {
+      assert(!lastSession);
+      lastSession = session;
+    });
+
+    c.resume(); // See close_notify comment in server
+  }
+
+  function fork() {
+    const worker = cluster.fork();
+    worker.on('message', ({ msg, port }) => {
+      console.error('[master] got %j', msg);
+      if (msg === 'reused') {
+        ++reusedCount;
+      } else if (msg === 'listening' && !shootOnce) {
+        workerPort = port || workerPort;
+        shootOnce = true;
+        shoot();
+      }
+    });
+
+    worker.on('exit', () => {
+      console.error('[master] worker died');
+    });
+  }
+  for (let i = 0; i < workerCount; i++) {
+    fork();
+  }
+
+  process.on('exit', () => {
+    assert.strictEqual(reqCount, expectedReqCount);
+    assert.strictEqual(reusedCount + 1, reqCount);
+  });
+  return;
+}
+
+const key = fixtures.readKey('rsa_private.pem');
+const cert = fixtures.readKey('rsa_cert.crt');
+
+const options = { key, cert };
+
+const server = tls.createServer(options, (c) => {
+  console.error('[worker] connection reused?', c.isSessionReused());
+  if (c.isSessionReused()) {
+    process.send({ msg: 'reused' });
+  } else {
+    process.send({ msg: 'not-reused' });
+  }
+  // Used to just .end(), but that means client gets close_notify before
+  // NewSessionTicket. Send data until that problem is solved.
+  c.end('x');
+});
+
+server.listen(0, () => {
+  const { port } = server.address();
+  process.send({
+    msg: 'listening',
+    port,
+  });
+});
+
+process.on('message', function listener(msg) {
+  console.error('[worker] got %j', msg);
+  if (msg === 'die') {
+    server.close(() => {
+      console.error('[worker] server close');
+
+      process.exit();
+    });
+  }
+});
+
+process.on('exit', () => {
+  console.error('[worker] exit');
+});
diff --git a/test/known_issues/test-tls-ticket.js b/test/known_issues/test-tls-ticket.js
new file mode 100644
index 0000000..8d9cd8c
--- /dev/null
+++ b/test/known_issues/test-tls-ticket.js
@@ -0,0 +1,159 @@
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+'use strict';
+const common = require('../common');
+if (!common.hasCrypto)
+  common.skip('missing crypto');
+
+const assert = require('assert');
+const tls = require('tls');
+const net = require('net');
+const crypto = require('crypto');
+const fixtures = require('../common/fixtures');
+
+const keys = crypto.randomBytes(48);
+const serverLog = [];
+const ticketLog = [];
+
+let s;
+
+let serverCount = 0;
+function createServer() {
+  const id = serverCount++;
+
+  let counter = 0;
+  let previousKey = null;
+
+  const server = tls.createServer({
+    key: fixtures.readKey('agent1-key.pem'),
+    cert: fixtures.readKey('agent1-cert.pem'),
+    ticketKeys: keys
+  }, function(c) {
+    serverLog.push(id);
+    // TODO(@sam-github) Triggers close_notify before NewSessionTicket bug.
+    // c.end();
+    c.end('x');
+
+    counter++;
+
+    // Rotate ticket keys
+    //
+    // Take especial care to account for TLS1.2 and TLS1.3 differences around
+    // when ticket keys are encrypted. In TLS1.2, they are encrypted before the
+    // handshake complete callback, but in TLS1.3, they are encrypted after.
+    // There is no callback or way for us to know when they were sent, so hook
+    // the client's reception of the keys, and use it as proof that the current
+    // keys were used, and its safe to rotate them.
+    //
+    // Rotation can occur right away if the session was reused, the keys were
+    // already decrypted or we wouldn't have a reused session.
+    function setTicketKeys(keys) {
+      if (c.isSessionReused())
+        server.setTicketKeys(keys);
+      else
+        s.once('session', () => {
+          server.setTicketKeys(keys);
+        });
+    }
+    if (counter === 1) {
+      previousKey = server.getTicketKeys();
+      assert.strictEqual(previousKey.compare(keys), 0);
+      setTicketKeys(crypto.randomBytes(48));
+    } else if (counter === 2) {
+      setTicketKeys(previousKey);
+    } else if (counter === 3) {
+      // Use keys from counter=2
+    } else {
+      throw new Error('UNREACHABLE');
+    }
+  });
+
+  return server;
+}
+
+const naturalServers = [ createServer(), createServer(), createServer() ];
+
+// 3x servers
+const servers = naturalServers.concat(naturalServers).concat(naturalServers);
+
+// Create one TCP server and balance sockets to multiple TLS server instances
+const shared = net.createServer(function(c) {
+  servers.shift().emit('connection', c);
+}).listen(0, function() {
+  start(function() {
+    shared.close();
+  });
+});
+
+// 'session' events only occur for new sessions. The first connection is new.
+// After, for each set of 3 connections, the middle connection is made when the
+// server has random keys set, so the client's ticket is silently ignored, and a
+// new ticket is sent.
+const onNewSession = common.mustCall((s, session) => {
+  assert(session);
+  assert.strictEqual(session.compare(s.getSession()), 0);
+}, 4);
+
+function start(callback) {
+  let sess = null;
+  let left = servers.length;
+
+  function connect() {
+    s = tls.connect(shared.address().port, {
+      session: sess,
+      rejectUnauthorized: false
+    }, function() {
+      if (s.isSessionReused())
+        ticketLog.push(s.getTLSTicket().toString('hex'));
+    });
+    s.on('data', () => {
+      s.end();
+    });
+    s.on('close', function() {
+      if (--left === 0)
+        callback();
+      else
+        connect();
+    });
+    s.on('session', (session) => {
+      sess = sess || session;
+    });
+    s.once('session', (session) => onNewSession(s, session));
+    s.once('session', () => ticketLog.push(s.getTLSTicket().toString('hex')));
+  }
+
+  connect();
+}
+
+process.on('exit', function() {
+  assert.strictEqual(ticketLog.length, serverLog.length);
+  for (let i = 0; i < naturalServers.length - 1; i++) {
+    assert.notStrictEqual(serverLog[i], serverLog[i + 1]);
+    assert.strictEqual(ticketLog[i], ticketLog[i + 1]);
+
+    // 2nd connection should have different ticket
+    assert.notStrictEqual(ticketLog[i], ticketLog[i + naturalServers.length]);
+
+    // 3rd connection should have the same ticket
+    assert.strictEqual(ticketLog[i], ticketLog[i + naturalServers.length * 2]);
+  }
+});
diff --git a/test/known_issues/test-v8-serdes.js b/test/known_issues/test-v8-serdes.js
new file mode 100644
index 0000000..a992ba4
--- /dev/null
+++ b/test/known_issues/test-v8-serdes.js
@@ -0,0 +1,244 @@
+// Flags: --expose-internals
+
+'use strict';
+
+const common = require('../common');
+const fixtures = require('../common/fixtures');
+const { internalBinding } = require('internal/test/binding');
+const assert = require('assert');
+const v8 = require('v8');
+const os = require('os');
+
+const circular = {};
+circular.circular = circular;
+
+const wasmModule = new WebAssembly.Module(fixtures.readSync('simple.wasm'));
+
+const objects = [
+  { foo: 'bar' },
+  { bar: 'baz' },
+  new Uint8Array([1, 2, 3, 4]),
+  new Uint32Array([1, 2, 3, 4]),
+  Buffer.from([1, 2, 3, 4]),
+  undefined,
+  null,
+  42,
+  circular,
+  wasmModule
+];
+
+const hostObject = new (internalBinding('js_stream').JSStream)();
+
+const serializerTypeError =
+  /^TypeError: Class constructor Serializer cannot be invoked without 'new'$/;
+const deserializerTypeError =
+  /^TypeError: Class constructor Deserializer cannot be invoked without 'new'$/;
+
+{
+  const ser = new v8.DefaultSerializer();
+  ser.writeHeader();
+  for (const obj of objects) {
+    ser.writeValue(obj);
+  }
+
+  const des = new v8.DefaultDeserializer(ser.releaseBuffer());
+  des.readHeader();
+
+  for (const obj of objects) {
+    assert.deepStrictEqual(des.readValue(), obj);
+  }
+}
+
+{
+  for (const obj of objects) {
+    assert.deepStrictEqual(v8.deserialize(v8.serialize(obj)), obj);
+  }
+}
+
+{
+  const ser = new v8.DefaultSerializer();
+  ser._getDataCloneError = common.mustCall((message) => {
+    assert.strictEqual(message, '[object Object] could not be cloned.');
+    return new Error('foobar');
+  });
+
+  ser.writeHeader();
+
+  assert.throws(() => {
+    ser.writeValue(new Proxy({}, {}));
+  }, /foobar/);
+}
+
+{
+  const ser = new v8.DefaultSerializer();
+  ser._writeHostObject = common.mustCall((object) => {
+    assert.strictEqual(object, hostObject);
+    const buf = Buffer.from('hostObjectTag');
+
+    ser.writeUint32(buf.length);
+    ser.writeRawBytes(buf);
+
+    ser.writeUint64(1, 2);
+    ser.writeDouble(-0.25);
+  });
+
+  ser.writeHeader();
+  ser.writeValue({ val: hostObject });
+
+  const des = new v8.DefaultDeserializer(ser.releaseBuffer());
+  des._readHostObject = common.mustCall(() => {
+    const length = des.readUint32();
+    const buf = des.readRawBytes(length);
+
+    assert.strictEqual(buf.toString(), 'hostObjectTag');
+
+    assert.deepStrictEqual(des.readUint64(), [1, 2]);
+    assert.strictEqual(des.readDouble(), -0.25);
+    return hostObject;
+  });
+
+  des.readHeader();
+
+  assert.strictEqual(des.readValue().val, hostObject);
+}
+
+// This test ensures that `v8.Serializer.writeRawBytes()` support
+// `TypedArray` and `DataView`.
+{
+  const text = 'hostObjectTag';
+  const data = Buffer.from(text);
+  const arrayBufferViews = common.getArrayBufferViews(data);
+
+  // `buf` is one of `TypedArray` or `DataView`.
+  function testWriteRawBytes(buf) {
+    let writeHostObjectCalled = false;
+    const ser = new v8.DefaultSerializer();
+
+    ser._writeHostObject = common.mustCall((object) => {
+      writeHostObjectCalled = true;
+      ser.writeUint32(buf.byteLength);
+      ser.writeRawBytes(buf);
+    });
+
+    ser.writeHeader();
+    ser.writeValue({ val: hostObject });
+
+    const des = new v8.DefaultDeserializer(ser.releaseBuffer());
+    des._readHostObject = common.mustCall(() => {
+      assert.strictEqual(writeHostObjectCalled, true);
+      const length = des.readUint32();
+      const buf = des.readRawBytes(length);
+      assert.strictEqual(buf.toString(), text);
+
+      return hostObject;
+    });
+
+    des.readHeader();
+
+    assert.strictEqual(des.readValue().val, hostObject);
+  }
+
+  arrayBufferViews.forEach((buf) => {
+    testWriteRawBytes(buf);
+  });
+}
+
+{
+  const ser = new v8.DefaultSerializer();
+  ser._writeHostObject = common.mustCall((object) => {
+    throw new Error('foobar');
+  });
+
+  ser.writeHeader();
+  assert.throws(() => {
+    ser.writeValue({ val: hostObject });
+  }, /foobar/);
+}
+
+{
+  assert.throws(() => v8.serialize(hostObject), {
+    constructor: Error,
+    message: 'Unserializable host object: JSStream {}'
+  });
+}
+
+{
+  const buf = Buffer.from('ff0d6f2203666f6f5e007b01', 'hex');
+
+  const des = new v8.DefaultDeserializer(buf);
+  des.readHeader();
+
+  const ser = new v8.DefaultSerializer();
+  ser.writeHeader();
+
+  ser.writeValue(des.readValue());
+
+  assert.deepStrictEqual(buf, ser.releaseBuffer());
+  assert.strictEqual(des.getWireFormatVersion(), 0x0d);
+}
+
+{
+  // Unaligned Uint16Array read, with padding in the underlying array buffer.
+  let buf = Buffer.alloc(32 + 9);
+  buf.write('ff0d5c0404addeefbe', 32, 'hex');
+  buf = buf.slice(32);
+
+  const expectedResult = os.endianness() === 'LE' ?
+    new Uint16Array([0xdead, 0xbeef]) : new Uint16Array([0xadde, 0xefbe]);
+
+  assert.deepStrictEqual(v8.deserialize(buf), expectedResult);
+}
+
+{
+  assert.throws(v8.Serializer, serializerTypeError);
+  assert.throws(v8.Deserializer, deserializerTypeError);
+}
+
+
+// `v8.deserialize()` and `new v8.Deserializer()` should support both
+// `TypedArray` and `DataView`.
+{
+  for (const obj of objects) {
+    const buf = v8.serialize(obj);
+
+    for (const arrayBufferView of common.getArrayBufferViews(buf)) {
+      assert.deepStrictEqual(v8.deserialize(arrayBufferView), obj);
+    }
+
+    for (const arrayBufferView of common.getArrayBufferViews(buf)) {
+      const deserializer = new v8.DefaultDeserializer(arrayBufferView);
+      deserializer.readHeader();
+      const value = deserializer.readValue();
+      assert.deepStrictEqual(value, obj);
+
+      const serializer = new v8.DefaultSerializer();
+      serializer.writeHeader();
+      serializer.writeValue(value);
+      assert.deepStrictEqual(buf, serializer.releaseBuffer());
+    }
+  }
+}
+
+{
+  const INVALID_SOURCE = 'INVALID_SOURCE_TYPE';
+  const serializer = new v8.Serializer();
+  serializer.writeHeader();
+  assert.throws(
+    () => serializer.writeRawBytes(INVALID_SOURCE),
+    /^TypeError: source must be a TypedArray or a DataView$/,
+  );
+  assert.throws(
+    () => v8.deserialize(INVALID_SOURCE),
+    /^TypeError: buffer must be a TypedArray or a DataView$/,
+  );
+  assert.throws(
+    () => new v8.Deserializer(INVALID_SOURCE),
+    /^TypeError: buffer must be a TypedArray or a DataView$/,
+  );
+}
+
+{
+  const deserializedWasmModule = v8.deserialize(v8.serialize(wasmModule));
+  const instance = new WebAssembly.Instance(deserializedWasmModule);
+  assert.strictEqual(instance.exports.add(10, 20), 30);
+}
diff --git a/test/parallel/test-crypto-aes-wrap.js b/test/parallel/test-crypto-aes-wrap.js
deleted file mode 100644
index 6fe3525..0000000
--- a/test/parallel/test-crypto-aes-wrap.js
+++ /dev/null
@@ -1,62 +0,0 @@
-'use strict';
-const common = require('../common');
-if (!common.hasCrypto)
-  common.skip('missing crypto');
-
-const assert = require('assert');
-const crypto = require('crypto');
-
-const test = [
-  {
-    algorithm: 'aes128-wrap',
-    key: 'b26f309fbe57e9b3bb6ae5ef31d54450',
-    iv: '3fd838af4093d749',
-    text: '12345678123456781234567812345678'
-  },
-  {
-    algorithm: 'id-aes128-wrap-pad',
-    key: 'b26f309fbe57e9b3bb6ae5ef31d54450',
-    iv: '3fd838af',
-    text: '12345678123456781234567812345678123'
-  },
-  {
-    algorithm: 'aes192-wrap',
-    key: '40978085d68091f7dfca0d7dfc7a5ee76d2cc7f2f345a304',
-    iv: '3fd838af4093d749',
-    text: '12345678123456781234567812345678'
-  },
-  {
-    algorithm: 'id-aes192-wrap-pad',
-    key: '40978085d68091f7dfca0d7dfc7a5ee76d2cc7f2f345a304',
-    iv: '3fd838af',
-    text: '12345678123456781234567812345678123'
-  },
-  {
-    algorithm: 'aes256-wrap',
-    key: '29c9eab5ed5ad44134a1437fe2e673b4d88a5b7c72e68454fea08721392b7323',
-    iv: '3fd838af4093d749',
-    text: '12345678123456781234567812345678'
-  },
-  {
-    algorithm: 'id-aes256-wrap-pad',
-    key: '29c9eab5ed5ad44134a1437fe2e673b4d88a5b7c72e68454fea08721392b7323',
-    iv: '3fd838af',
-    text: '12345678123456781234567812345678123'
-  },
-];
-
-test.forEach((data) => {
-  const cipher = crypto.createCipheriv(
-    data.algorithm,
-    Buffer.from(data.key, 'hex'),
-    Buffer.from(data.iv, 'hex'));
-  const ciphertext = cipher.update(data.text, 'utf8');
-
-  const decipher = crypto.createDecipheriv(
-    data.algorithm,
-    Buffer.from(data.key, 'hex'),
-    Buffer.from(data.iv, 'hex'));
-  const msg = decipher.update(ciphertext, 'buffer', 'utf8');
-
-  assert.strictEqual(msg, data.text, `${data.algorithm} test case failed`);
-});
diff --git a/test/parallel/test-crypto-authenticated.js b/test/parallel/test-crypto-authenticated.js
index 8be7296..c9bf961 100644
--- a/test/parallel/test-crypto-authenticated.js
+++ b/test/parallel/test-crypto-authenticated.js
@@ -404,7 +404,7 @@ for (const test of TEST_CASES) {
 // Test that create(De|C)ipher(iv)? throws if the mode is CCM or OCB and no
 // authentication tag has been specified.
 {
-  for (const mode of ['ccm', 'ocb']) {
+  for (const mode of ['ccm']) {
     assert.throws(() => {
       crypto.createCipheriv(`aes-256-${mode}`,
                             'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',
@@ -564,7 +564,7 @@ for (const test of TEST_CASES) {
   const key = Buffer.from('0123456789abcdef', 'utf8');
   const iv = Buffer.from('0123456789ab', 'utf8');
 
-  for (const mode of ['gcm', 'ocb']) {
+  for (const mode of ['gcm']) {
     for (const authTagLength of mode === 'gcm' ? [undefined, 8] : [8]) {
       const cipher = crypto.createCipheriv(`aes-128-${mode}`, key, iv, {
         authTagLength
@@ -598,7 +598,7 @@ for (const test of TEST_CASES) {
   const iv = Buffer.from('0123456789ab', 'utf8');
   const opts = { authTagLength: 8 };
 
-  for (const mode of ['gcm', 'ccm', 'ocb']) {
+  for (const mode of ['gcm', 'ccm']) {
     const cipher = crypto.createCipheriv(`aes-128-${mode}`, key, iv, opts);
     const ciphertext = Buffer.concat([cipher.update(plain), cipher.final()]);
     const tag = cipher.getAuthTag();
@@ -616,51 +616,3 @@ for (const test of TEST_CASES) {
     assert(plain.equals(plaintext));
   }
 }
-
-
-// Test chacha20-poly1305 rejects invalid IV lengths of 13, 14, 15, and 16 (a
-// length of 17 or greater was already rejected).
-// - https://www.openssl.org/news/secadv/20190306.txt
-{
-  // Valid extracted from TEST_CASES, check that it detects IV tampering.
-  const valid = {
-    algo: 'chacha20-poly1305',
-    key: '808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f',
-    iv: '070000004041424344454647',
-    plain: '4c616469657320616e642047656e746c656d656e206f662074686520636c6173' +
-           '73206f66202739393a204966204920636f756c64206f6666657220796f75206f' +
-           '6e6c79206f6e652074697020666f7220746865206675747572652c2073756e73' +
-           '637265656e20776f756c642062652069742e',
-    plainIsHex: true,
-    aad: '50515253c0c1c2c3c4c5c6c7',
-    ct: 'd31a8d34648e60db7b86afbc53ef7ec2a4aded51296e08fea9e2b5' +
-        'a736ee62d63dbea45e8ca9671282fafb69da92728b1a71de0a9e06' +
-        '0b2905d6a5b67ecd3b3692ddbd7f2d778b8c9803aee328091b58fa' +
-        'b324e4fad675945585808b4831d7bc3ff4def08e4b7a9de576d265' +
-        '86cec64b6116',
-    tag: '1ae10b594f09e26a7e902ecbd0600691',
-    tampered: false,
-  };
-
-  // Invalid IV lengths should be detected:
-  // - 12 and below are valid.
-  // - 13-16 are not detected as invalid by some OpenSSL versions.
-  check(13);
-  check(14);
-  check(15);
-  check(16);
-  // - 17 and above were always detected as invalid by OpenSSL.
-  check(17);
-
-  function check(ivLength) {
-    const prefix = ivLength - valid.iv.length / 2;
-    assert.throws(() => crypto.createCipheriv(
-      valid.algo,
-      Buffer.from(valid.key, 'hex'),
-      Buffer.from(H(prefix) + valid.iv, 'hex'),
-      { authTagLength: valid.tag.length / 2 }
-    ), errMessages.length, `iv length ${ivLength} was not rejected`);
-
-    function H(length) { return '00'.repeat(length); }
-  }
-}
diff --git a/test/parallel/test-crypto-des3-wrap.js b/test/parallel/test-crypto-des3-wrap.js
deleted file mode 100644
index 75c8cd5..0000000
--- a/test/parallel/test-crypto-des3-wrap.js
+++ /dev/null
@@ -1,25 +0,0 @@
-'use strict';
-const common = require('../common');
-if (!common.hasCrypto)
-  common.skip('missing crypto');
-
-const assert = require('assert');
-const crypto = require('crypto');
-
-// Test case for des-ede3 wrap/unwrap. des3-wrap needs extra 2x blocksize
-// then plaintext to store ciphertext.
-const test = {
-  key: Buffer.from('3c08e25be22352910671cfe4ba3652b1220a8a7769b490ba', 'hex'),
-  iv: Buffer.alloc(0),
-  plaintext: '32|RmVZZkFUVmpRRkp0TmJaUm56ZU9qcnJkaXNNWVNpTTU*|iXmckfRWZBG' +
-    'WWELweCBsThSsfUHLeRe0KCsK8ooHgxie0zOINpXxfZi/oNG7uq9JWFVCk70gfzQH8ZU' +
-    'JjAfaFg**'
-};
-
-const cipher = crypto.createCipheriv('des3-wrap', test.key, test.iv);
-const ciphertext = cipher.update(test.plaintext, 'utf8');
-
-const decipher = crypto.createDecipheriv('des3-wrap', test.key, test.iv);
-const msg = decipher.update(ciphertext, 'buffer', 'utf8');
-
-assert.strictEqual(msg, test.plaintext);
diff --git a/test/parallel/test-crypto-hash-stream-pipe.js b/test/parallel/test-crypto-hash-stream-pipe.js
deleted file mode 100644
index d22281a..0000000
--- a/test/parallel/test-crypto-hash-stream-pipe.js
+++ /dev/null
@@ -1,46 +0,0 @@
-// Copyright Joyent, Inc. and other Node contributors.
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the
-// "Software"), to deal in the Software without restriction, including
-// without limitation the rights to use, copy, modify, merge, publish,
-// distribute, sublicense, and/or sell copies of the Software, and to permit
-// persons to whom the Software is furnished to do so, subject to the
-// following conditions:
-//
-// The above copyright notice and this permission notice shall be included
-// in all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-// USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-'use strict';
-const common = require('../common');
-
-if (!common.hasCrypto)
-  common.skip('missing crypto');
-
-const assert = require('assert');
-const crypto = require('crypto');
-
-const stream = require('stream');
-const s = new stream.PassThrough();
-const h = crypto.createHash('sha3-512');
-const expect = '36a38a2a35e698974d4e5791a3f05b05' +
-               '198235381e864f91a0e8cd6a26b677ec' +
-               'dcde8e2b069bd7355fabd68abd6fc801' +
-               '19659f25e92f8efc961ee3a7c815c758';
-
-s.pipe(h).on('data', common.mustCall(function(c) {
-  assert.strictEqual(c, expect);
-  // Calling digest() after piping into a stream with SHA3 should not cause
-  // a segmentation fault, see https://github.com/nodejs/node/issues/28245.
-  assert.strictEqual(h.digest('hex'), expect);
-})).setEncoding('hex');
-
-s.end('aoeu');
diff --git a/test/parallel/test-crypto-hash.js b/test/parallel/test-crypto-hash.js
index 0ccc300..996b885 100644
--- a/test/parallel/test-crypto-hash.js
+++ b/test/parallel/test-crypto-hash.js
@@ -182,87 +182,6 @@ common.expectsError(
                                    ' when called without `new`');
 }
 
-// Test XOF hash functions and the outputLength option.
-{
-  // Default outputLengths.
-  assert.strictEqual(crypto.createHash('shake128').digest('hex'),
-                     '7f9c2ba4e88f827d616045507605853e');
-  assert.strictEqual(crypto.createHash('shake128', null).digest('hex'),
-                     '7f9c2ba4e88f827d616045507605853e');
-  assert.strictEqual(crypto.createHash('shake256').digest('hex'),
-                     '46b9dd2b0ba88d13233b3feb743eeb24' +
-                     '3fcd52ea62b81b82b50c27646ed5762f');
-  assert.strictEqual(crypto.createHash('shake256', { outputLength: 0 })
-                           .copy()  // Default outputLength.
-                           .digest('hex'),
-                     '46b9dd2b0ba88d13233b3feb743eeb24' +
-                     '3fcd52ea62b81b82b50c27646ed5762f');
-
-  // Short outputLengths.
-  assert.strictEqual(crypto.createHash('shake128', { outputLength: 0 })
-                           .digest('hex'),
-                     '');
-  assert.strictEqual(crypto.createHash('shake128', { outputLength: 5 })
-                           .copy({ outputLength: 0 })
-                           .digest('hex'),
-                     '');
-  assert.strictEqual(crypto.createHash('shake128', { outputLength: 5 })
-                           .digest('hex'),
-                     '7f9c2ba4e8');
-  assert.strictEqual(crypto.createHash('shake128', { outputLength: 0 })
-                           .copy({ outputLength: 5 })
-                           .digest('hex'),
-                     '7f9c2ba4e8');
-  assert.strictEqual(crypto.createHash('shake128', { outputLength: 15 })
-                           .digest('hex'),
-                     '7f9c2ba4e88f827d61604550760585');
-  assert.strictEqual(crypto.createHash('shake256', { outputLength: 16 })
-                           .digest('hex'),
-                     '46b9dd2b0ba88d13233b3feb743eeb24');
-
-  // Large outputLengths.
-  assert.strictEqual(crypto.createHash('shake128', { outputLength: 128 })
-                           .digest('hex'),
-                     '7f9c2ba4e88f827d616045507605853e' +
-                     'd73b8093f6efbc88eb1a6eacfa66ef26' +
-                     '3cb1eea988004b93103cfb0aeefd2a68' +
-                     '6e01fa4a58e8a3639ca8a1e3f9ae57e2' +
-                     '35b8cc873c23dc62b8d260169afa2f75' +
-                     'ab916a58d974918835d25e6a435085b2' +
-                     'badfd6dfaac359a5efbb7bcc4b59d538' +
-                     'df9a04302e10c8bc1cbf1a0b3a5120ea');
-  const superLongHash = crypto.createHash('shake256', {
-    outputLength: 1024 * 1024
-  }).update('The message is shorter than the hash!')
-    .digest('hex');
-  assert.strictEqual(superLongHash.length, 2 * 1024 * 1024);
-  assert.ok(superLongHash.endsWith('193414035ddba77bf7bba97981e656ec'));
-  assert.ok(superLongHash.startsWith('a2a28dbc49cfd6e5d6ceea3d03e77748'));
-
-  // Non-XOF hash functions should accept valid outputLength options as well.
-  assert.strictEqual(crypto.createHash('sha224', { outputLength: 28 })
-                           .digest('hex'),
-                     'd14a028c2a3a2bc9476102bb288234c4' +
-                     '15a2b01f828ea62ac5b3e42f');
-
-  // Passing invalid sizes should throw during creation.
-  common.expectsError(() => {
-    crypto.createHash('sha256', { outputLength: 28 });
-  }, {
-    code: 'ERR_OSSL_EVP_NOT_XOF_OR_INVALID_LENGTH'
-  });
-
-  for (const outputLength of [null, {}, 'foo', false]) {
-    common.expectsError(() => crypto.createHash('sha256', { outputLength }),
-                        { code: 'ERR_INVALID_ARG_TYPE' });
-  }
-
-  for (const outputLength of [-1, .5, Infinity, 2 ** 90]) {
-    common.expectsError(() => crypto.createHash('sha256', { outputLength }),
-                        { code: 'ERR_OUT_OF_RANGE' });
-  }
-}
-
 {
   const h = crypto.createHash('sha512');
   h.digest();
diff --git a/test/parallel/test-crypto-key-objects.js b/test/parallel/test-crypto-key-objects.js
index c830343..be32895 100644
--- a/test/parallel/test-crypto-key-objects.js
+++ b/test/parallel/test-crypto-key-objects.js
@@ -241,42 +241,6 @@ const privateDsa = fixtures.readKey('dsa_private_encrypted_1025.pem',
   });
 }
 
-[
-  { private: fixtures.readKey('ed25519_private.pem', 'ascii'),
-    public: fixtures.readKey('ed25519_public.pem', 'ascii'),
-    keyType: 'ed25519' },
-  { private: fixtures.readKey('ed448_private.pem', 'ascii'),
-    public: fixtures.readKey('ed448_public.pem', 'ascii'),
-    keyType: 'ed448' },
-  { private: fixtures.readKey('x25519_private.pem', 'ascii'),
-    public: fixtures.readKey('x25519_public.pem', 'ascii'),
-    keyType: 'x25519' },
-  { private: fixtures.readKey('x448_private.pem', 'ascii'),
-    public: fixtures.readKey('x448_public.pem', 'ascii'),
-    keyType: 'x448' },
-].forEach((info) => {
-  const keyType = info.keyType;
-
-  {
-    const exportOptions = { type: 'pkcs8', format: 'pem' };
-    const key = createPrivateKey(info.private);
-    assert.strictEqual(key.type, 'private');
-    assert.strictEqual(key.asymmetricKeyType, keyType);
-    assert.strictEqual(key.symmetricKeySize, undefined);
-    assert.strictEqual(key.export(exportOptions), info.private);
-  }
-
-  {
-    const exportOptions = { type: 'spki', format: 'pem' };
-    [info.private, info.public].forEach((pem) => {
-      const key = createPublicKey(pem);
-      assert.strictEqual(key.type, 'public');
-      assert.strictEqual(key.asymmetricKeyType, keyType);
-      assert.strictEqual(key.symmetricKeySize, undefined);
-      assert.strictEqual(key.export(exportOptions), info.public);
-    });
-  }
-});
 
 {
   // Reading an encrypted key without a passphrase should fail.
@@ -324,145 +288,6 @@ const privateDsa = fixtures.readKey('dsa_private_encrypted_1025.pem',
 }
 
 {
-  // Test RSA-PSS.
-  {
-    // This key pair does not restrict the message digest algorithm or salt
-    // length.
-    const publicPem = fixtures.readKey('rsa_pss_public_2048.pem');
-    const privatePem = fixtures.readKey('rsa_pss_private_2048.pem');
-
-    const publicKey = createPublicKey(publicPem);
-    const privateKey = createPrivateKey(privatePem);
-
-    assert.strictEqual(publicKey.type, 'public');
-    assert.strictEqual(publicKey.asymmetricKeyType, 'rsa-pss');
-
-    assert.strictEqual(privateKey.type, 'private');
-    assert.strictEqual(privateKey.asymmetricKeyType, 'rsa-pss');
-
-    for (const key of [privatePem, privateKey]) {
-      // Any algorithm should work.
-      for (const algo of ['sha1', 'sha256']) {
-        // Any salt length should work.
-        for (const saltLength of [undefined, 8, 10, 12, 16, 18, 20]) {
-          const signature = createSign(algo)
-                            .update('foo')
-                            .sign({ key, saltLength });
-
-          for (const pkey of [key, publicKey, publicPem]) {
-            const okay = createVerify(algo)
-                         .update('foo')
-                         .verify({ key: pkey, saltLength }, signature);
-
-            assert.ok(okay);
-          }
-        }
-      }
-    }
-
-    // Exporting the key using PKCS#1 should not work since this would discard
-    // any algorithm restrictions.
-    common.expectsError(() => {
-      publicKey.export({ format: 'pem', type: 'pkcs1' });
-    }, {
-      code: 'ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS'
-    });
-  }
-
-  {
-    // This key pair enforces sha256 as the message digest and the MGF1
-    // message digest and a salt length of at least 16 bytes.
-    const publicPem =
-      fixtures.readKey('rsa_pss_public_2048_sha256_sha256_16.pem');
-    const privatePem =
-      fixtures.readKey('rsa_pss_private_2048_sha256_sha256_16.pem');
-
-    const publicKey = createPublicKey(publicPem);
-    const privateKey = createPrivateKey(privatePem);
-
-    assert.strictEqual(publicKey.type, 'public');
-    assert.strictEqual(publicKey.asymmetricKeyType, 'rsa-pss');
-
-    assert.strictEqual(privateKey.type, 'private');
-    assert.strictEqual(privateKey.asymmetricKeyType, 'rsa-pss');
-
-    for (const key of [privatePem, privateKey]) {
-      // Signing with anything other than sha256 should fail.
-      assert.throws(() => {
-        createSign('sha1').sign(key);
-      }, /digest not allowed/);
-
-      // Signing with salt lengths less than 16 bytes should fail.
-      for (const saltLength of [8, 10, 12]) {
-        assert.throws(() => {
-          createSign('sha1').sign({ key, saltLength });
-        }, /pss saltlen too small/);
-      }
-
-      // Signing with sha256 and appropriate salt lengths should work.
-      for (const saltLength of [undefined, 16, 18, 20]) {
-        const signature = createSign('sha256')
-                          .update('foo')
-                          .sign({ key, saltLength });
-
-        for (const pkey of [key, publicKey, publicPem]) {
-          const okay = createVerify('sha256')
-                       .update('foo')
-                       .verify({ key: pkey, saltLength }, signature);
-
-          assert.ok(okay);
-        }
-      }
-    }
-  }
-
-  {
-    // This key enforces sha512 as the message digest and sha256 as the MGF1
-    // message digest.
-    const publicPem =
-      fixtures.readKey('rsa_pss_public_2048_sha512_sha256_20.pem');
-    const privatePem =
-      fixtures.readKey('rsa_pss_private_2048_sha512_sha256_20.pem');
-
-    const publicKey = createPublicKey(publicPem);
-    const privateKey = createPrivateKey(privatePem);
-
-    assert.strictEqual(publicKey.type, 'public');
-    assert.strictEqual(publicKey.asymmetricKeyType, 'rsa-pss');
-
-    assert.strictEqual(privateKey.type, 'private');
-    assert.strictEqual(privateKey.asymmetricKeyType, 'rsa-pss');
-
-    // Node.js usually uses the same hash function for the message and for MGF1.
-    // However, when a different MGF1 message digest algorithm has been
-    // specified as part of the key, it should automatically switch to that.
-    // This behavior is required by sections 3.1 and 3.3 of RFC4055.
-    for (const key of [privatePem, privateKey]) {
-      // sha256 matches the MGF1 hash function and should be used internally,
-      // but it should not be permitted as the main message digest algorithm.
-      for (const algo of ['sha1', 'sha256']) {
-        assert.throws(() => {
-          createSign(algo).sign(key);
-        }, /digest not allowed/);
-      }
-
-      // sha512 should produce a valid signature.
-      const signature = createSign('sha512')
-                        .update('foo')
-                        .sign(key);
-
-      for (const pkey of [key, publicKey, publicPem]) {
-        const okay = createVerify('sha512')
-                     .update('foo')
-                     .verify(pkey, signature);
-
-        assert.ok(okay);
-      }
-    }
-  }
-}
-
-{
   // Exporting an encrypted private key requires a cipher
   const privateKey = createPrivateKey(privatePem);
   common.expectsError(() => {
diff --git a/test/parallel/test-crypto-keygen.js b/test/parallel/test-crypto-keygen.js
index 605a374..05a2d80 100644
--- a/test/parallel/test-crypto-keygen.js
+++ b/test/parallel/test-crypto-keygen.js
@@ -266,43 +266,6 @@ const sec1EncExp = (cipher) => getRegExpForPEM('EC PRIVATE KEY', cipher);
 }
 
 {
-  // Test RSA-PSS.
-  generateKeyPair('rsa-pss', {
-    modulusLength: 512,
-    saltLength: 16,
-    hash: 'sha256',
-    mgf1Hash: 'sha256'
-  }, common.mustCall((err, publicKey, privateKey) => {
-    assert.ifError(err);
-
-    assert.strictEqual(publicKey.type, 'public');
-    assert.strictEqual(publicKey.asymmetricKeyType, 'rsa-pss');
-
-    assert.strictEqual(privateKey.type, 'private');
-    assert.strictEqual(privateKey.asymmetricKeyType, 'rsa-pss');
-
-    // Unlike RSA, RSA-PSS does not allow encryption.
-    assert.throws(() => {
-      testEncryptDecrypt(publicKey, privateKey);
-    }, /operation not supported for this keytype/);
-
-    // RSA-PSS also does not permit signing with PKCS1 padding.
-    assert.throws(() => {
-      testSignVerify({
-        key: publicKey,
-        padding: constants.RSA_PKCS1_PADDING
-      }, {
-        key: privateKey,
-        padding: constants.RSA_PKCS1_PADDING
-      });
-    }, /illegal or unsupported padding mode/);
-
-    // The padding should correctly default to RSA_PKCS1_PSS_PADDING now.
-    testSignVerify(publicKey, privateKey);
-  }));
-}
-
-{
   const privateKeyEncoding = {
     type: 'pkcs8',
     format: 'der'
@@ -964,23 +927,6 @@ const sec1EncExp = (cipher) => getRegExpForPEM('EC PRIVATE KEY', cipher);
   }));
 }
 
-// Test EdDSA key generation.
-{
-  if (!/^1\.1\.0/.test(process.versions.openssl)) {
-    ['ed25519', 'ed448', 'x25519', 'x448'].forEach((keyType) => {
-      generateKeyPair(keyType, common.mustCall((err, publicKey, privateKey) => {
-        assert.ifError(err);
-
-        assert.strictEqual(publicKey.type, 'public');
-        assert.strictEqual(publicKey.asymmetricKeyType, keyType);
-
-        assert.strictEqual(privateKey.type, 'private');
-        assert.strictEqual(privateKey.asymmetricKeyType, keyType);
-      }));
-    });
-  }
-}
-
 // Test invalid key encoding types.
 {
   // Invalid public key type.
diff --git a/test/parallel/test-crypto-pbkdf2.js b/test/parallel/test-crypto-pbkdf2.js
index 5ab37ac..5ef4f1f 100644
--- a/test/parallel/test-crypto-pbkdf2.js
+++ b/test/parallel/test-crypto-pbkdf2.js
@@ -221,21 +221,3 @@ crypto.pbkdf2Sync(new Float32Array(10), 'salt', 8, 8, 'sha256');
 crypto.pbkdf2Sync('pass', new Float32Array(10), 8, 8, 'sha256');
 crypto.pbkdf2Sync(new Float64Array(10), 'salt', 8, 8, 'sha256');
 crypto.pbkdf2Sync('pass', new Float64Array(10), 8, 8, 'sha256');
-
-assert.throws(
-  () => crypto.pbkdf2('pass', 'salt', 8, 8, 'md55', common.mustNotCall()),
-  {
-    code: 'ERR_CRYPTO_INVALID_DIGEST',
-    name: 'TypeError',
-    message: 'Invalid digest: md55'
-  }
-);
-
-assert.throws(
-  () => crypto.pbkdf2Sync('pass', 'salt', 8, 8, 'md55'),
-  {
-    code: 'ERR_CRYPTO_INVALID_DIGEST',
-    name: 'TypeError',
-    message: 'Invalid digest: md55'
-  }
-);
diff --git a/test/parallel/test-crypto-sign-verify.js b/test/parallel/test-crypto-sign-verify.js
index b3861dd..1bd5f71 100644
--- a/test/parallel/test-crypto-sign-verify.js
+++ b/test/parallel/test-crypto-sign-verify.js
@@ -419,14 +419,6 @@ common.expectsError(
 }
 
 [
-  { private: fixtures.readKey('ed25519_private.pem', 'ascii'),
-    public: fixtures.readKey('ed25519_public.pem', 'ascii'),
-    algo: null,
-    sigLen: 64 },
-  { private: fixtures.readKey('ed448_private.pem', 'ascii'),
-    public: fixtures.readKey('ed448_public.pem', 'ascii'),
-    algo: null,
-    sigLen: 114 },
   { private: fixtures.readKey('rsa_private_2048.pem', 'ascii'),
     public: fixtures.readKey('rsa_public_2048.pem', 'ascii'),
     algo: 'sha1',
diff --git a/test/parallel/test-crypto.js b/test/parallel/test-crypto.js
index 9337621..ac1fcce 100644
--- a/test/parallel/test-crypto.js
+++ b/test/parallel/test-crypto.js
@@ -129,7 +129,7 @@ validateList(cryptoCiphers);
 // Assume that we have at least AES256-SHA.
 const tlsCiphers = tls.getCiphers();
 assert(tls.getCiphers().includes('aes256-sha'));
-assert(tls.getCiphers().includes('tls_aes_128_ccm_8_sha256'));
+//assert(tls.getCiphers().includes('tls_aes_128_ccm_8_sha256'));  // TLSv1.3
 // There should be no capital letters in any element.
 const noCapitals = /^[^A-Z]+$/;
 assert(tlsCiphers.every((value) => noCapitals.test(value)));
@@ -235,9 +235,9 @@ assert.throws(function() {
 }, (err) => {
   // Do the standard checks, but then do some custom checks afterwards.
   assert.throws(() => { throw err; }, {
-    message: 'error:0D0680A8:asn1 encoding routines:asn1_check_tlen:wrong tag',
+    message: 'error:0D0680A8:asn1 encoding routines:ASN1_CHECK_TLEN:wrong tag',
     library: 'asn1 encoding routines',
-    function: 'asn1_check_tlen',
+    function: 'ASN1_CHECK_TLEN',
     reason: 'wrong tag',
     code: 'ERR_OSSL_ASN1_WRONG_TAG',
   });
diff --git a/test/parallel/test-https-agent-session-eviction.js b/test/parallel/test-https-agent-session-eviction.js
index 3f5cd36..8e13b15 100644
--- a/test/parallel/test-https-agent-session-eviction.js
+++ b/test/parallel/test-https-agent-session-eviction.js
@@ -7,8 +7,10 @@ const { readKey } = require('../common/fixtures');
 if (!common.hasCrypto)
   common.skip('missing crypto');
 
+const assert = require('assert');
 const https = require('https');
-const { SSL_OP_NO_TICKET } = require('crypto').constants;
+const { OPENSSL_VERSION_NUMBER, SSL_OP_NO_TICKET } =
+    require('crypto').constants;
 
 const options = {
   key: readKey('agent1-key.pem'),
@@ -58,12 +60,38 @@ function second(server, session) {
     res.resume();
   });
 
-  // Although we have a TLS 1.2 session to offer to the TLS 1.0 server,
-  // connection to the TLS 1.0 server should work.
-  req.on('response', common.mustCall(function(res) {
-    // The test is now complete for OpenSSL 1.1.0.
-    server.close();
-  }));
+  if (OPENSSL_VERSION_NUMBER >= 0x10100000) {
+    // Although we have a TLS 1.2 session to offer to the TLS 1.0 server,
+    // connection to the TLS 1.0 server should work.
+    req.on('response', common.mustCall(function(res) {
+      // The test is now complete for OpenSSL 1.1.0.
+      server.close();
+    }));
+  } else {
+    // OpenSSL 1.0.x mistakenly locked versions based on the session it was
+    // offering. This causes this sequent request to fail. Let it fail, but
+    // test that this is mitigated on the next try by invalidating the session.
+    req.on('error', common.mustCall(function(err) {
+      assert(/wrong version number/.test(err.message));
+
+      req.on('close', function() {
+        third(server);
+      });
+    }));
+  }
+  req.end();
+}
 
+// Try one more time - session should be evicted!
+function third(server) {
+  const req = https.request({
+    port: server.address().port,
+    rejectUnauthorized: false
+  }, function(res) {
+    res.resume();
+    assert(!req.socket.isSessionReused());
+    server.close();
+  });
+  req.on('error', common.mustNotCall());
   req.end();
 }
diff --git a/test/parallel/test-tls-alert-handling.js b/test/parallel/test-tls-alert-handling.js
index f9f42e2..9dc4637 100644
--- a/test/parallel/test-tls-alert-handling.js
+++ b/test/parallel/test-tls-alert-handling.js
@@ -33,7 +33,7 @@ let iter = 0;
 const errorHandler = common.mustCall((err) => {
   assert.strictEqual(err.code, 'ERR_SSL_WRONG_VERSION_NUMBER');
   assert.strictEqual(err.library, 'SSL routines');
-  assert.strictEqual(err.function, 'ssl3_get_record');
+  assert.strictEqual(err.function, 'SSL3_GET_RECORD');
   assert.strictEqual(err.reason, 'wrong version number');
   errorReceived = true;
   if (canCloseServer())
diff --git a/test/parallel/test-tls-cli-max-version-1.3.js b/test/parallel/test-tls-cli-max-version-1.3.js
deleted file mode 100644
index c04354f..0000000
--- a/test/parallel/test-tls-cli-max-version-1.3.js
+++ /dev/null
@@ -1,15 +0,0 @@
-// Flags: --tls-max-v1.3
-'use strict';
-const common = require('../common');
-if (!common.hasCrypto) common.skip('missing crypto');
-
-// Check that node `--tls-max-v1.3` is supported.
-
-const assert = require('assert');
-const tls = require('tls');
-
-assert.strictEqual(tls.DEFAULT_MAX_VERSION, 'TLSv1.3');
-assert.strictEqual(tls.DEFAULT_MIN_VERSION, 'TLSv1.2');
-
-// Check the min-max version protocol versions against these CLI settings.
-require('./test-tls-min-max-version.js');
diff --git a/test/parallel/test-tls-cli-min-max-conflict.js b/test/parallel/test-tls-cli-min-max-conflict.js
deleted file mode 100644
index 68aae4c..0000000
--- a/test/parallel/test-tls-cli-min-max-conflict.js
+++ /dev/null
@@ -1,14 +0,0 @@
-'use strict';
-const common = require('../common');
-if (!common.hasCrypto) common.skip('missing crypto');
-
-// Check that conflicting TLS protocol versions are not allowed
-
-const assert = require('assert');
-const child_process = require('child_process');
-
-const args = ['--tls-min-v1.3', '--tls-max-v1.2', '-p', 'process.version'];
-child_process.execFile(process.argv[0], args, (err) => {
-  assert(err);
-  assert(/not both/.test(err.message));
-});
diff --git a/test/parallel/test-tls-cli-min-version-1.0.js b/test/parallel/test-tls-cli-min-version-1.0.js
index 5775627..0a227c0 100644
--- a/test/parallel/test-tls-cli-min-version-1.0.js
+++ b/test/parallel/test-tls-cli-min-version-1.0.js
@@ -8,7 +8,7 @@ if (!common.hasCrypto) common.skip('missing crypto');
 const assert = require('assert');
 const tls = require('tls');
 
-assert.strictEqual(tls.DEFAULT_MAX_VERSION, 'TLSv1.3');
+assert.strictEqual(tls.DEFAULT_MAX_VERSION, 'TLSv1.2');
 assert.strictEqual(tls.DEFAULT_MIN_VERSION, 'TLSv1');
 
 // Check the min-max version protocol versions against these CLI settings.
diff --git a/test/parallel/test-tls-cli-min-version-1.1.js b/test/parallel/test-tls-cli-min-version-1.1.js
index 3af2b39..1219c82 100644
--- a/test/parallel/test-tls-cli-min-version-1.1.js
+++ b/test/parallel/test-tls-cli-min-version-1.1.js
@@ -8,7 +8,7 @@ if (!common.hasCrypto) common.skip('missing crypto');
 const assert = require('assert');
 const tls = require('tls');
 
-assert.strictEqual(tls.DEFAULT_MAX_VERSION, 'TLSv1.3');
+assert.strictEqual(tls.DEFAULT_MAX_VERSION, 'TLSv1.2');
 assert.strictEqual(tls.DEFAULT_MIN_VERSION, 'TLSv1.1');
 
 // Check the min-max version protocol versions against these CLI settings.
diff --git a/test/parallel/test-tls-cli-min-version-1.2.js b/test/parallel/test-tls-cli-min-version-1.2.js
index 8385eab..058dc18 100644
--- a/test/parallel/test-tls-cli-min-version-1.2.js
+++ b/test/parallel/test-tls-cli-min-version-1.2.js
@@ -8,7 +8,7 @@ if (!common.hasCrypto) common.skip('missing crypto');
 const assert = require('assert');
 const tls = require('tls');
 
-assert.strictEqual(tls.DEFAULT_MAX_VERSION, 'TLSv1.3');
+assert.strictEqual(tls.DEFAULT_MAX_VERSION, 'TLSv1.2');
 assert.strictEqual(tls.DEFAULT_MIN_VERSION, 'TLSv1.2');
 
 // Check the min-max version protocol versions against these CLI settings.
diff --git a/test/parallel/test-tls-cli-min-version-1.3.js b/test/parallel/test-tls-cli-min-version-1.3.js
deleted file mode 100644
index 1bccc2f..0000000
--- a/test/parallel/test-tls-cli-min-version-1.3.js
+++ /dev/null
@@ -1,15 +0,0 @@
-// Flags: --tls-min-v1.3
-'use strict';
-const common = require('../common');
-if (!common.hasCrypto) common.skip('missing crypto');
-
-// Check that node `--tls-min-v1.3` is supported.
-
-const assert = require('assert');
-const tls = require('tls');
-
-assert.strictEqual(tls.DEFAULT_MAX_VERSION, 'TLSv1.3');
-assert.strictEqual(tls.DEFAULT_MIN_VERSION, 'TLSv1.3');
-
-// Check the min-max version protocol versions against these CLI settings.
-require('./test-tls-min-max-version.js');
diff --git a/test/parallel/test-tls-client-getephemeralkeyinfo.js b/test/parallel/test-tls-client-getephemeralkeyinfo.js
index 5993069..cdfe5de 100644
--- a/test/parallel/test-tls-client-getephemeralkeyinfo.js
+++ b/test/parallel/test-tls-client-getephemeralkeyinfo.js
@@ -59,5 +59,3 @@ test(1024, 'DH', undefined, 'DHE-RSA-AES128-GCM-SHA256');
 test(2048, 'DH', undefined, 'DHE-RSA-AES128-GCM-SHA256');
 test(256, 'ECDH', 'prime256v1', 'ECDHE-RSA-AES128-GCM-SHA256');
 test(521, 'ECDH', 'secp521r1', 'ECDHE-RSA-AES128-GCM-SHA256');
-test(253, 'ECDH', 'X25519', 'ECDHE-RSA-AES128-GCM-SHA256');
-test(448, 'ECDH', 'X448', 'ECDHE-RSA-AES128-GCM-SHA256');
diff --git a/test/parallel/test-tls-client-renegotiation-13.js b/test/parallel/test-tls-client-renegotiation-13.js
deleted file mode 100644
index 075eb70..0000000
--- a/test/parallel/test-tls-client-renegotiation-13.js
+++ /dev/null
@@ -1,41 +0,0 @@
-'use strict';
-
-const common = require('../common');
-const fixtures = require('../common/fixtures');
-
-// Confirm that for TLSv1.3, renegotiate() is disallowed.
-
-const {
-  assert, connect, keys
-} = require(fixtures.path('tls-connect'));
-
-const server = keys.agent10;
-
-connect({
-  client: {
-    ca: server.ca,
-    checkServerIdentity: common.mustCall(),
-  },
-  server: {
-    key: server.key,
-    cert: server.cert,
-  },
-}, function(err, pair, cleanup) {
-  assert.ifError(err);
-
-  const client = pair.client.conn;
-
-  assert.strictEqual(client.getProtocol(), 'TLSv1.3');
-
-  const ok = client.renegotiate({}, common.mustCall((err) => {
-    assert.throws(() => { throw err; }, {
-      message: 'error:1420410A:SSL routines:SSL_renegotiate:wrong ssl version',
-      code: 'ERR_SSL_WRONG_SSL_VERSION',
-      library: 'SSL routines',
-      reason: 'wrong ssl version',
-    });
-    cleanup();
-  }));
-
-  assert.strictEqual(ok, false);
-});
diff --git a/test/parallel/test-tls-destroy-stream.js b/test/parallel/test-tls-destroy-stream.js
index a49e985..1964f67 100644
--- a/test/parallel/test-tls-destroy-stream.js
+++ b/test/parallel/test-tls-destroy-stream.js
@@ -9,7 +9,7 @@ const net = require('net');
 const assert = require('assert');
 const tls = require('tls');
 
-tls.DEFAULT_MAX_VERSION = 'TLSv1.3';
+tls.DEFAULT_MAX_VERSION = 'TLSv1.2';
 
 // This test ensures that an instance of StreamWrap should emit "end" and
 // "close" when the socket on the other side call `destroy()` instead of
diff --git a/test/parallel/test-tls-getcipher.js b/test/parallel/test-tls-getcipher.js
index 624f8ef..93ad1f6 100644
--- a/test/parallel/test-tls-getcipher.js
+++ b/test/parallel/test-tls-getcipher.js
@@ -52,7 +52,7 @@ server.listen(0, '127.0.0.1', common.mustCall(function() {
   }, common.mustCall(function() {
     const cipher = this.getCipher();
     assert.strictEqual(cipher.name, 'AES128-SHA256');
-    assert.strictEqual(cipher.version, 'TLSv1.2');
+    assert.strictEqual(cipher.version, 'TLSv1/SSLv3');
     this.end();
   }));
 
@@ -65,28 +65,7 @@ server.listen(0, '127.0.0.1', common.mustCall(function() {
   }, common.mustCall(function() {
     const cipher = this.getCipher();
     assert.strictEqual(cipher.name, 'ECDHE-RSA-AES128-GCM-SHA256');
-    assert.strictEqual(cipher.version, 'TLSv1.2');
+    assert.strictEqual(cipher.version, 'TLSv1/SSLv3');
     this.end();
   }));
 }));
-
-tls.createServer({
-  key: fixtures.readKey('agent2-key.pem'),
-  cert: fixtures.readKey('agent2-cert.pem'),
-  ciphers: 'TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_CCM_8_SHA256',
-  maxVersion: 'TLSv1.3',
-}, common.mustCall(function() {
-  this.close();
-})).listen(0, common.mustCall(function() {
-  const client = tls.connect({
-    port: this.address().port,
-    ciphers: 'TLS_AES_128_CCM_8_SHA256',
-    maxVersion: 'TLSv1.3',
-    rejectUnauthorized: false
-  }, common.mustCall(() => {
-    const cipher = client.getCipher();
-    assert.strictEqual(cipher.name, 'TLS_AES_128_CCM_8_SHA256');
-    assert.strictEqual(cipher.version, 'TLSv1.3');
-    client.end();
-  }));
-}));
diff --git a/test/parallel/test-tls-keylog-tlsv13.js b/test/parallel/test-tls-keylog-tlsv13.js
deleted file mode 100644
index 0f65564..0000000
--- a/test/parallel/test-tls-keylog-tlsv13.js
+++ /dev/null
@@ -1,32 +0,0 @@
-'use strict';
-
-const common = require('../common');
-if (!common.hasCrypto)
-  common.skip('missing crypto');
-
-const assert = require('assert');
-const tls = require('tls');
-const fixtures = require('../common/fixtures');
-
-const server = tls.createServer({
-  key: fixtures.readKey('agent2-key.pem'),
-  cert: fixtures.readKey('agent2-cert.pem'),
-  // Amount of keylog events depends on negotiated protocol
-  // version, so force a specific one:
-  minVersion: 'TLSv1.3',
-  maxVersion: 'TLSv1.3',
-}).listen(() => {
-  const client = tls.connect({
-    port: server.address().port,
-    rejectUnauthorized: false,
-  });
-
-  const verifyBuffer = (line) => assert(Buffer.isBuffer(line));
-  server.on('keylog', common.mustCall(verifyBuffer, 5));
-  client.on('keylog', common.mustCall(verifyBuffer, 5));
-
-  client.once('secureConnect', () => {
-    server.close();
-    client.end();
-  });
-});
diff --git a/test/parallel/test-tls-min-max-version.js b/test/parallel/test-tls-min-max-version.js
index 179ae1f..8b5435b 100644
--- a/test/parallel/test-tls-min-max-version.js
+++ b/test/parallel/test-tls-min-max-version.js
@@ -126,9 +126,9 @@ if (DEFAULT_MIN_VERSION === 'TLSv1.3') {
 
 if (DEFAULT_MIN_VERSION === 'TLSv1.2') {
   test(U, U, 'TLSv1_1_method', U, U, 'SSLv23_method',
-       U, 'ECONNRESET', 'ERR_SSL_UNSUPPORTED_PROTOCOL');
+       U, 'ECONNRESET', 'ERR_SSL_UNKNOWN_PROTOCOL');
   test(U, U, 'TLSv1_method', U, U, 'SSLv23_method',
-       U, 'ECONNRESET', 'ERR_SSL_UNSUPPORTED_PROTOCOL');
+       U, 'ECONNRESET', 'ERR_SSL_UNKNOWN_PROTOCOL');
   test(U, U, 'SSLv23_method', U, U, 'TLSv1_1_method',
        U, 'ERR_SSL_UNSUPPORTED_PROTOCOL', 'ERR_SSL_WRONG_VERSION_NUMBER');
   test(U, U, 'SSLv23_method', U, U, 'TLSv1_method',
@@ -138,7 +138,7 @@ if (DEFAULT_MIN_VERSION === 'TLSv1.2') {
 if (DEFAULT_MIN_VERSION === 'TLSv1.1') {
   test(U, U, 'TLSv1_1_method', U, U, 'SSLv23_method', 'TLSv1.1');
   test(U, U, 'TLSv1_method', U, U, 'SSLv23_method',
-       U, 'ECONNRESET', 'ERR_SSL_UNSUPPORTED_PROTOCOL');
+       U, 'ECONNRESET', 'ERR_SSL_UNKNOWN_PROTOCOL');
   test(U, U, 'SSLv23_method', U, U, 'TLSv1_1_method', 'TLSv1.1');
   test(U, U, 'SSLv23_method', U, U, 'TLSv1_method',
        U, 'ERR_SSL_UNSUPPORTED_PROTOCOL', 'ERR_SSL_WRONG_VERSION_NUMBER');
@@ -160,9 +160,9 @@ test(U, U, 'TLSv1_method', U, U, 'TLSv1_method', 'TLSv1');
 // The default default.
 if (DEFAULT_MIN_VERSION === 'TLSv1.2') {
   test(U, U, 'TLSv1_1_method', U, U, U,
-       U, 'ECONNRESET', 'ERR_SSL_UNSUPPORTED_PROTOCOL');
+       U, 'ECONNRESET', 'ERR_SSL_UNKNOWN_PROTOCOL');
   test(U, U, 'TLSv1_method', U, U, U,
-       U, 'ECONNRESET', 'ERR_SSL_UNSUPPORTED_PROTOCOL');
+       U, 'ECONNRESET', 'ERR_SSL_UNKNOWN_PROTOCOL');
 
   if (DEFAULT_MAX_VERSION === 'TLSv1.2') {
     test(U, U, U, U, U, 'TLSv1_1_method',
@@ -182,7 +182,7 @@ if (DEFAULT_MIN_VERSION === 'TLSv1.2') {
 if (DEFAULT_MIN_VERSION === 'TLSv1.1') {
   test(U, U, 'TLSv1_1_method', U, U, U, 'TLSv1.1');
   test(U, U, 'TLSv1_method', U, U, U,
-       U, 'ECONNRESET', 'ERR_SSL_UNSUPPORTED_PROTOCOL');
+       U, 'ECONNRESET', 'ERR_SSL_UNKNOWN_PROTOCOL');
   test(U, U, U, U, U, 'TLSv1_1_method', 'TLSv1.1');
 
   if (DEFAULT_MAX_VERSION === 'TLSv1.2') {
@@ -213,26 +213,9 @@ test(U, U, 'TLSv1_method', 'TLSv1', 'TLSv1.2', U, 'TLSv1');
 test(U, U, 'TLSv1_1_method', 'TLSv1', 'TLSv1.2', U, 'TLSv1.1');
 test(U, U, 'TLSv1_2_method', 'TLSv1', 'TLSv1.2', U, 'TLSv1.2');
 
-test('TLSv1', 'TLSv1.1', U, 'TLSv1', 'TLSv1.3', U, 'TLSv1.1');
 test('TLSv1', 'TLSv1.1', U, 'TLSv1', 'TLSv1.2', U, 'TLSv1.1');
 test('TLSv1', 'TLSv1.2', U, 'TLSv1', 'TLSv1.1', U, 'TLSv1.1');
-test('TLSv1', 'TLSv1.3', U, 'TLSv1', 'TLSv1.1', U, 'TLSv1.1');
 test('TLSv1', 'TLSv1', U, 'TLSv1', 'TLSv1.1', U, 'TLSv1');
 test('TLSv1', 'TLSv1.2', U, 'TLSv1', 'TLSv1', U, 'TLSv1');
-test('TLSv1', 'TLSv1.3', U, 'TLSv1', 'TLSv1', U, 'TLSv1');
 test('TLSv1.1', 'TLSv1.1', U, 'TLSv1', 'TLSv1.2', U, 'TLSv1.1');
 test('TLSv1', 'TLSv1.2', U, 'TLSv1.1', 'TLSv1.1', U, 'TLSv1.1');
-test('TLSv1', 'TLSv1.2', U, 'TLSv1', 'TLSv1.3', U, 'TLSv1.2');
-
-// v-any client can connect to v-specific server
-test('TLSv1', 'TLSv1.3', U, 'TLSv1.3', 'TLSv1.3', U, 'TLSv1.3');
-test('TLSv1', 'TLSv1.3', U, 'TLSv1.2', 'TLSv1.3', U, 'TLSv1.3');
-test('TLSv1', 'TLSv1.3', U, 'TLSv1.2', 'TLSv1.2', U, 'TLSv1.2');
-test('TLSv1', 'TLSv1.3', U, 'TLSv1.1', 'TLSv1.1', U, 'TLSv1.1');
-test('TLSv1', 'TLSv1.3', U, 'TLSv1', 'TLSv1', U, 'TLSv1');
-
-// v-specific client can connect to v-any server
-test('TLSv1.3', 'TLSv1.3', U, 'TLSv1', 'TLSv1.3', U, 'TLSv1.3');
-test('TLSv1.2', 'TLSv1.2', U, 'TLSv1', 'TLSv1.3', U, 'TLSv1.2');
-test('TLSv1.1', 'TLSv1.1', U, 'TLSv1', 'TLSv1.3', U, 'TLSv1.1');
-test('TLSv1', 'TLSv1', U, 'TLSv1', 'TLSv1.3', U, 'TLSv1');
diff --git a/test/parallel/test-tls-multi-key.js b/test/parallel/test-tls-multi-key.js
index c5e66f3..de213f5 100644
--- a/test/parallel/test-tls-multi-key.js
+++ b/test/parallel/test-tls-multi-key.js
@@ -157,7 +157,7 @@ function test(options) {
     }, common.mustCall(function() {
       assert.deepStrictEqual(ecdsa.getCipher(), {
         name: 'ECDHE-ECDSA-AES256-GCM-SHA384',
-        version: 'TLSv1.2'
+        version: 'TLSv1/SSLv3'
       });
       assert.strictEqual(ecdsa.getPeerCertificate().subject.CN, eccCN);
       assert.strictEqual(ecdsa.getPeerCertificate().asn1Curve, 'prime256v1');
@@ -175,7 +175,7 @@ function test(options) {
     }, common.mustCall(function() {
       assert.deepStrictEqual(rsa.getCipher(), {
         name: 'ECDHE-RSA-AES256-GCM-SHA384',
-        version: 'TLSv1.2'
+        version: 'TLSv1/SSLv3'
       });
       assert.strictEqual(rsa.getPeerCertificate().subject.CN, rsaCN);
       assert(rsa.getPeerCertificate().exponent, 'cert for an RSA key');
diff --git a/test/parallel/test-tls-multi-pfx.js b/test/parallel/test-tls-multi-pfx.js
index 3b0c059..28cd945 100644
--- a/test/parallel/test-tls-multi-pfx.js
+++ b/test/parallel/test-tls-multi-pfx.js
@@ -42,9 +42,9 @@ const server = tls.createServer(options, function(conn) {
 process.on('exit', function() {
   assert.deepStrictEqual(ciphers, [{
     name: 'ECDHE-ECDSA-AES256-GCM-SHA384',
-    version: 'TLSv1.2'
+    version: 'TLSv1/SSLv3'
   }, {
     name: 'ECDHE-RSA-AES256-GCM-SHA384',
-    version: 'TLSv1.2'
+    version: 'TLSv1/SSLv3'
   }]);
 });
diff --git a/test/parallel/test-tls-no-sslv3.js b/test/parallel/test-tls-no-sslv3.js
deleted file mode 100644
index 1acb1f9..0000000
--- a/test/parallel/test-tls-no-sslv3.js
+++ /dev/null
@@ -1,49 +0,0 @@
-'use strict';
-const common = require('../common');
-if (!common.hasCrypto)
-  common.skip('missing crypto');
-
-if (common.opensslCli === false)
-  common.skip('node compiled without OpenSSL CLI.');
-
-const assert = require('assert');
-const tls = require('tls');
-const spawn = require('child_process').spawn;
-const fixtures = require('../common/fixtures');
-
-const cert = fixtures.readKey('rsa_cert.crt');
-const key = fixtures.readKey('rsa_private.pem');
-const server = tls.createServer({ cert, key }, common.mustNotCall());
-const errors = [];
-let stderr = '';
-
-server.listen(0, '127.0.0.1', function() {
-  const address = `${this.address().address}:${this.address().port}`;
-  const args = ['s_client',
-                '-ssl3',
-                '-connect', address];
-
-  const client = spawn(common.opensslCli, args, { stdio: 'pipe' });
-  client.stdout.pipe(process.stdout);
-  client.stderr.pipe(process.stderr);
-  client.stderr.setEncoding('utf8');
-  client.stderr.on('data', (data) => stderr += data);
-
-  client.once('exit', common.mustCall(function(exitCode) {
-    assert.strictEqual(exitCode, 1);
-    server.close();
-  }));
-});
-
-server.on('tlsClientError', (err) => errors.push(err));
-
-process.on('exit', function() {
-  if (/unknown option -ssl3/.test(stderr)) {
-    common.printSkipMessage('`openssl s_client -ssl3` not supported.');
-  } else {
-    assert.strictEqual(errors.length, 1);
-    // OpenSSL 1.0.x and 1.1.x report invalid client versions differently.
-    assert(/:wrong version number/.test(errors[0].message) ||
-           /:version too low/.test(errors[0].message));
-  }
-});
diff --git a/test/parallel/test-tls-passphrase.js b/test/parallel/test-tls-passphrase.js
index c3a99c3..4bbabb4 100644
--- a/test/parallel/test-tls-passphrase.js
+++ b/test/parallel/test-tls-passphrase.js
@@ -223,7 +223,7 @@ server.listen(0, common.mustCall(function() {
   }, onSecureConnect());
 })).unref();
 
-const errMessagePassword = /bad decrypt/;
+const errMessagePassword = /bad decrypt|bad password read/;
 
 // Missing passphrase
 assert.throws(function() {
diff --git a/test/parallel/test-tls-set-ciphers.js b/test/parallel/test-tls-set-ciphers.js
index fbca83b..79fb178 100644
--- a/test/parallel/test-tls-set-ciphers.js
+++ b/test/parallel/test-tls-set-ciphers.js
@@ -68,36 +68,11 @@ const U = undefined;
 test(U, 'AES256-SHA', 'AES256-SHA');
 test('AES256-SHA', U, 'AES256-SHA');
 
-test(U, 'TLS_AES_256_GCM_SHA384', 'TLS_AES_256_GCM_SHA384');
-test('TLS_AES_256_GCM_SHA384', U, 'TLS_AES_256_GCM_SHA384');
-
 // Do not have shared ciphers.
-test('TLS_AES_256_GCM_SHA384', 'TLS_CHACHA20_POLY1305_SHA256',
-     U, 'ECONNRESET', 'ERR_SSL_NO_SHARED_CIPHER');
-
-test('AES128-SHA', 'AES256-SHA', U, 'ECONNRESET', 'ERR_SSL_NO_SHARED_CIPHER');
-test('AES128-SHA:TLS_AES_256_GCM_SHA384',
-     'TLS_CHACHA20_POLY1305_SHA256:AES256-SHA',
-     U, 'ECONNRESET', 'ERR_SSL_NO_SHARED_CIPHER');
-
-// Cipher order ignored, TLS1.3 chosen before TLS1.2.
-test('AES256-SHA:TLS_AES_256_GCM_SHA384', U, 'TLS_AES_256_GCM_SHA384');
-test(U, 'AES256-SHA:TLS_AES_256_GCM_SHA384', 'TLS_AES_256_GCM_SHA384');
-
-// TLS_AES_128_CCM_8_SHA256 & TLS_AES_128_CCM_SHA256 are not enabled by
-// default, but work.
-test('TLS_AES_128_CCM_8_SHA256', U,
-     U, 'ECONNRESET', 'ERR_SSL_NO_SHARED_CIPHER');
-
-test('TLS_AES_128_CCM_8_SHA256', 'TLS_AES_128_CCM_8_SHA256',
-     'TLS_AES_128_CCM_8_SHA256');
+test('AES128-SHA', 'AES256-SHA', U, 'ERR_SSL_SSLV3_ALERT_HANDSHAKE_FAILURE', 'ERR_SSL_NO_SHARED_CIPHER');
 
 // Invalid cipher values
 test(9, 'AES256-SHA', U, 'ERR_INVALID_ARG_TYPE', U);
 test('AES256-SHA', 9, U, U, 'ERR_INVALID_ARG_TYPE');
 test(':', 'AES256-SHA', U, 'ERR_INVALID_OPT_VALUE', U);
 test('AES256-SHA', ':', U, U, 'ERR_INVALID_OPT_VALUE');
-
-// Using '' is synonymous for "use default ciphers"
-test('TLS_AES_256_GCM_SHA384', '', 'TLS_AES_256_GCM_SHA384');
-test('', 'TLS_AES_256_GCM_SHA384', 'TLS_AES_256_GCM_SHA384');
diff --git a/test/parallel/test-tls-ticket-12.js b/test/parallel/test-tls-ticket-12.js
deleted file mode 100644
index 600c571..0000000
--- a/test/parallel/test-tls-ticket-12.js
+++ /dev/null
@@ -1,12 +0,0 @@
-'use strict';
-const common = require('../common');
-if (!common.hasCrypto)
-  common.skip('missing crypto');
-
-// Run test-tls-ticket.js with TLS1.2
-
-const tls = require('tls');
-
-tls.DEFAULT_MAX_VERSION = 'TLSv1.2';
-
-require('./test-tls-ticket.js');
diff --git a/test/parallel/test-tls-ticket-cluster.js b/test/parallel/test-tls-ticket-cluster.js
deleted file mode 100644
index cc4f46e..0000000
--- a/test/parallel/test-tls-ticket-cluster.js
+++ /dev/null
@@ -1,135 +0,0 @@
-// Copyright Joyent, Inc. and other Node contributors.
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the
-// "Software"), to deal in the Software without restriction, including
-// without limitation the rights to use, copy, modify, merge, publish,
-// distribute, sublicense, and/or sell copies of the Software, and to permit
-// persons to whom the Software is furnished to do so, subject to the
-// following conditions:
-//
-// The above copyright notice and this permission notice shall be included
-// in all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-// USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-'use strict';
-const common = require('../common');
-if (!common.hasCrypto)
-  common.skip('missing crypto');
-
-const assert = require('assert');
-const tls = require('tls');
-const cluster = require('cluster');
-const fixtures = require('../common/fixtures');
-
-const workerCount = 4;
-const expectedReqCount = 16;
-
-if (cluster.isMaster) {
-  let reusedCount = 0;
-  let reqCount = 0;
-  let lastSession = null;
-  let shootOnce = false;
-  let workerPort = null;
-
-  function shoot() {
-    console.error('[master] connecting', workerPort, 'session?', !!lastSession);
-    const c = tls.connect(workerPort, {
-      session: lastSession,
-      rejectUnauthorized: false
-    }, () => {
-      c.end();
-    }).on('close', () => {
-      // Wait for close to shoot off another connection. We don't want to shoot
-      // until a new session is allocated, if one will be. The new session is
-      // not guaranteed on secureConnect (it depends on TLS1.2 vs TLS1.3), but
-      // it is guaranteed to happen before the connection is closed.
-      if (++reqCount === expectedReqCount) {
-        Object.keys(cluster.workers).forEach(function(id) {
-          cluster.workers[id].send('die');
-        });
-      } else {
-        shoot();
-      }
-    }).once('session', (session) => {
-      assert(!lastSession);
-      lastSession = session;
-    });
-
-    c.resume(); // See close_notify comment in server
-  }
-
-  function fork() {
-    const worker = cluster.fork();
-    worker.on('message', ({ msg, port }) => {
-      console.error('[master] got %j', msg);
-      if (msg === 'reused') {
-        ++reusedCount;
-      } else if (msg === 'listening' && !shootOnce) {
-        workerPort = port || workerPort;
-        shootOnce = true;
-        shoot();
-      }
-    });
-
-    worker.on('exit', () => {
-      console.error('[master] worker died');
-    });
-  }
-  for (let i = 0; i < workerCount; i++) {
-    fork();
-  }
-
-  process.on('exit', () => {
-    assert.strictEqual(reqCount, expectedReqCount);
-    assert.strictEqual(reusedCount + 1, reqCount);
-  });
-  return;
-}
-
-const key = fixtures.readKey('rsa_private.pem');
-const cert = fixtures.readKey('rsa_cert.crt');
-
-const options = { key, cert };
-
-const server = tls.createServer(options, (c) => {
-  console.error('[worker] connection reused?', c.isSessionReused());
-  if (c.isSessionReused()) {
-    process.send({ msg: 'reused' });
-  } else {
-    process.send({ msg: 'not-reused' });
-  }
-  // Used to just .end(), but that means client gets close_notify before
-  // NewSessionTicket. Send data until that problem is solved.
-  c.end('x');
-});
-
-server.listen(0, () => {
-  const { port } = server.address();
-  process.send({
-    msg: 'listening',
-    port,
-  });
-});
-
-process.on('message', function listener(msg) {
-  console.error('[worker] got %j', msg);
-  if (msg === 'die') {
-    server.close(() => {
-      console.error('[worker] server close');
-
-      process.exit();
-    });
-  }
-});
-
-process.on('exit', () => {
-  console.error('[worker] exit');
-});
diff --git a/test/parallel/test-tls-ticket.js b/test/parallel/test-tls-ticket.js
deleted file mode 100644
index 8d9cd8c..0000000
--- a/test/parallel/test-tls-ticket.js
+++ /dev/null
@@ -1,159 +0,0 @@
-// Copyright Joyent, Inc. and other Node contributors.
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the
-// "Software"), to deal in the Software without restriction, including
-// without limitation the rights to use, copy, modify, merge, publish,
-// distribute, sublicense, and/or sell copies of the Software, and to permit
-// persons to whom the Software is furnished to do so, subject to the
-// following conditions:
-//
-// The above copyright notice and this permission notice shall be included
-// in all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-// USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-'use strict';
-const common = require('../common');
-if (!common.hasCrypto)
-  common.skip('missing crypto');
-
-const assert = require('assert');
-const tls = require('tls');
-const net = require('net');
-const crypto = require('crypto');
-const fixtures = require('../common/fixtures');
-
-const keys = crypto.randomBytes(48);
-const serverLog = [];
-const ticketLog = [];
-
-let s;
-
-let serverCount = 0;
-function createServer() {
-  const id = serverCount++;
-
-  let counter = 0;
-  let previousKey = null;
-
-  const server = tls.createServer({
-    key: fixtures.readKey('agent1-key.pem'),
-    cert: fixtures.readKey('agent1-cert.pem'),
-    ticketKeys: keys
-  }, function(c) {
-    serverLog.push(id);
-    // TODO(@sam-github) Triggers close_notify before NewSessionTicket bug.
-    // c.end();
-    c.end('x');
-
-    counter++;
-
-    // Rotate ticket keys
-    //
-    // Take especial care to account for TLS1.2 and TLS1.3 differences around
-    // when ticket keys are encrypted. In TLS1.2, they are encrypted before the
-    // handshake complete callback, but in TLS1.3, they are encrypted after.
-    // There is no callback or way for us to know when they were sent, so hook
-    // the client's reception of the keys, and use it as proof that the current
-    // keys were used, and its safe to rotate them.
-    //
-    // Rotation can occur right away if the session was reused, the keys were
-    // already decrypted or we wouldn't have a reused session.
-    function setTicketKeys(keys) {
-      if (c.isSessionReused())
-        server.setTicketKeys(keys);
-      else
-        s.once('session', () => {
-          server.setTicketKeys(keys);
-        });
-    }
-    if (counter === 1) {
-      previousKey = server.getTicketKeys();
-      assert.strictEqual(previousKey.compare(keys), 0);
-      setTicketKeys(crypto.randomBytes(48));
-    } else if (counter === 2) {
-      setTicketKeys(previousKey);
-    } else if (counter === 3) {
-      // Use keys from counter=2
-    } else {
-      throw new Error('UNREACHABLE');
-    }
-  });
-
-  return server;
-}
-
-const naturalServers = [ createServer(), createServer(), createServer() ];
-
-// 3x servers
-const servers = naturalServers.concat(naturalServers).concat(naturalServers);
-
-// Create one TCP server and balance sockets to multiple TLS server instances
-const shared = net.createServer(function(c) {
-  servers.shift().emit('connection', c);
-}).listen(0, function() {
-  start(function() {
-    shared.close();
-  });
-});
-
-// 'session' events only occur for new sessions. The first connection is new.
-// After, for each set of 3 connections, the middle connection is made when the
-// server has random keys set, so the client's ticket is silently ignored, and a
-// new ticket is sent.
-const onNewSession = common.mustCall((s, session) => {
-  assert(session);
-  assert.strictEqual(session.compare(s.getSession()), 0);
-}, 4);
-
-function start(callback) {
-  let sess = null;
-  let left = servers.length;
-
-  function connect() {
-    s = tls.connect(shared.address().port, {
-      session: sess,
-      rejectUnauthorized: false
-    }, function() {
-      if (s.isSessionReused())
-        ticketLog.push(s.getTLSTicket().toString('hex'));
-    });
-    s.on('data', () => {
-      s.end();
-    });
-    s.on('close', function() {
-      if (--left === 0)
-        callback();
-      else
-        connect();
-    });
-    s.on('session', (session) => {
-      sess = sess || session;
-    });
-    s.once('session', (session) => onNewSession(s, session));
-    s.once('session', () => ticketLog.push(s.getTLSTicket().toString('hex')));
-  }
-
-  connect();
-}
-
-process.on('exit', function() {
-  assert.strictEqual(ticketLog.length, serverLog.length);
-  for (let i = 0; i < naturalServers.length - 1; i++) {
-    assert.notStrictEqual(serverLog[i], serverLog[i + 1]);
-    assert.strictEqual(ticketLog[i], ticketLog[i + 1]);
-
-    // 2nd connection should have different ticket
-    assert.notStrictEqual(ticketLog[i], ticketLog[i + naturalServers.length]);
-
-    // 3rd connection should have the same ticket
-    assert.strictEqual(ticketLog[i], ticketLog[i + naturalServers.length * 2]);
-  }
-});
diff --git a/test/parallel/test-v8-serdes.js b/test/parallel/test-v8-serdes.js
deleted file mode 100644
index a992ba4..0000000
--- a/test/parallel/test-v8-serdes.js
+++ /dev/null
@@ -1,244 +0,0 @@
-// Flags: --expose-internals
-
-'use strict';
-
-const common = require('../common');
-const fixtures = require('../common/fixtures');
-const { internalBinding } = require('internal/test/binding');
-const assert = require('assert');
-const v8 = require('v8');
-const os = require('os');
-
-const circular = {};
-circular.circular = circular;
-
-const wasmModule = new WebAssembly.Module(fixtures.readSync('simple.wasm'));
-
-const objects = [
-  { foo: 'bar' },
-  { bar: 'baz' },
-  new Uint8Array([1, 2, 3, 4]),
-  new Uint32Array([1, 2, 3, 4]),
-  Buffer.from([1, 2, 3, 4]),
-  undefined,
-  null,
-  42,
-  circular,
-  wasmModule
-];
-
-const hostObject = new (internalBinding('js_stream').JSStream)();
-
-const serializerTypeError =
-  /^TypeError: Class constructor Serializer cannot be invoked without 'new'$/;
-const deserializerTypeError =
-  /^TypeError: Class constructor Deserializer cannot be invoked without 'new'$/;
-
-{
-  const ser = new v8.DefaultSerializer();
-  ser.writeHeader();
-  for (const obj of objects) {
-    ser.writeValue(obj);
-  }
-
-  const des = new v8.DefaultDeserializer(ser.releaseBuffer());
-  des.readHeader();
-
-  for (const obj of objects) {
-    assert.deepStrictEqual(des.readValue(), obj);
-  }
-}
-
-{
-  for (const obj of objects) {
-    assert.deepStrictEqual(v8.deserialize(v8.serialize(obj)), obj);
-  }
-}
-
-{
-  const ser = new v8.DefaultSerializer();
-  ser._getDataCloneError = common.mustCall((message) => {
-    assert.strictEqual(message, '[object Object] could not be cloned.');
-    return new Error('foobar');
-  });
-
-  ser.writeHeader();
-
-  assert.throws(() => {
-    ser.writeValue(new Proxy({}, {}));
-  }, /foobar/);
-}
-
-{
-  const ser = new v8.DefaultSerializer();
-  ser._writeHostObject = common.mustCall((object) => {
-    assert.strictEqual(object, hostObject);
-    const buf = Buffer.from('hostObjectTag');
-
-    ser.writeUint32(buf.length);
-    ser.writeRawBytes(buf);
-
-    ser.writeUint64(1, 2);
-    ser.writeDouble(-0.25);
-  });
-
-  ser.writeHeader();
-  ser.writeValue({ val: hostObject });
-
-  const des = new v8.DefaultDeserializer(ser.releaseBuffer());
-  des._readHostObject = common.mustCall(() => {
-    const length = des.readUint32();
-    const buf = des.readRawBytes(length);
-
-    assert.strictEqual(buf.toString(), 'hostObjectTag');
-
-    assert.deepStrictEqual(des.readUint64(), [1, 2]);
-    assert.strictEqual(des.readDouble(), -0.25);
-    return hostObject;
-  });
-
-  des.readHeader();
-
-  assert.strictEqual(des.readValue().val, hostObject);
-}
-
-// This test ensures that `v8.Serializer.writeRawBytes()` support
-// `TypedArray` and `DataView`.
-{
-  const text = 'hostObjectTag';
-  const data = Buffer.from(text);
-  const arrayBufferViews = common.getArrayBufferViews(data);
-
-  // `buf` is one of `TypedArray` or `DataView`.
-  function testWriteRawBytes(buf) {
-    let writeHostObjectCalled = false;
-    const ser = new v8.DefaultSerializer();
-
-    ser._writeHostObject = common.mustCall((object) => {
-      writeHostObjectCalled = true;
-      ser.writeUint32(buf.byteLength);
-      ser.writeRawBytes(buf);
-    });
-
-    ser.writeHeader();
-    ser.writeValue({ val: hostObject });
-
-    const des = new v8.DefaultDeserializer(ser.releaseBuffer());
-    des._readHostObject = common.mustCall(() => {
-      assert.strictEqual(writeHostObjectCalled, true);
-      const length = des.readUint32();
-      const buf = des.readRawBytes(length);
-      assert.strictEqual(buf.toString(), text);
-
-      return hostObject;
-    });
-
-    des.readHeader();
-
-    assert.strictEqual(des.readValue().val, hostObject);
-  }
-
-  arrayBufferViews.forEach((buf) => {
-    testWriteRawBytes(buf);
-  });
-}
-
-{
-  const ser = new v8.DefaultSerializer();
-  ser._writeHostObject = common.mustCall((object) => {
-    throw new Error('foobar');
-  });
-
-  ser.writeHeader();
-  assert.throws(() => {
-    ser.writeValue({ val: hostObject });
-  }, /foobar/);
-}
-
-{
-  assert.throws(() => v8.serialize(hostObject), {
-    constructor: Error,
-    message: 'Unserializable host object: JSStream {}'
-  });
-}
-
-{
-  const buf = Buffer.from('ff0d6f2203666f6f5e007b01', 'hex');
-
-  const des = new v8.DefaultDeserializer(buf);
-  des.readHeader();
-
-  const ser = new v8.DefaultSerializer();
-  ser.writeHeader();
-
-  ser.writeValue(des.readValue());
-
-  assert.deepStrictEqual(buf, ser.releaseBuffer());
-  assert.strictEqual(des.getWireFormatVersion(), 0x0d);
-}
-
-{
-  // Unaligned Uint16Array read, with padding in the underlying array buffer.
-  let buf = Buffer.alloc(32 + 9);
-  buf.write('ff0d5c0404addeefbe', 32, 'hex');
-  buf = buf.slice(32);
-
-  const expectedResult = os.endianness() === 'LE' ?
-    new Uint16Array([0xdead, 0xbeef]) : new Uint16Array([0xadde, 0xefbe]);
-
-  assert.deepStrictEqual(v8.deserialize(buf), expectedResult);
-}
-
-{
-  assert.throws(v8.Serializer, serializerTypeError);
-  assert.throws(v8.Deserializer, deserializerTypeError);
-}
-
-
-// `v8.deserialize()` and `new v8.Deserializer()` should support both
-// `TypedArray` and `DataView`.
-{
-  for (const obj of objects) {
-    const buf = v8.serialize(obj);
-
-    for (const arrayBufferView of common.getArrayBufferViews(buf)) {
-      assert.deepStrictEqual(v8.deserialize(arrayBufferView), obj);
-    }
-
-    for (const arrayBufferView of common.getArrayBufferViews(buf)) {
-      const deserializer = new v8.DefaultDeserializer(arrayBufferView);
-      deserializer.readHeader();
-      const value = deserializer.readValue();
-      assert.deepStrictEqual(value, obj);
-
-      const serializer = new v8.DefaultSerializer();
-      serializer.writeHeader();
-      serializer.writeValue(value);
-      assert.deepStrictEqual(buf, serializer.releaseBuffer());
-    }
-  }
-}
-
-{
-  const INVALID_SOURCE = 'INVALID_SOURCE_TYPE';
-  const serializer = new v8.Serializer();
-  serializer.writeHeader();
-  assert.throws(
-    () => serializer.writeRawBytes(INVALID_SOURCE),
-    /^TypeError: source must be a TypedArray or a DataView$/,
-  );
-  assert.throws(
-    () => v8.deserialize(INVALID_SOURCE),
-    /^TypeError: buffer must be a TypedArray or a DataView$/,
-  );
-  assert.throws(
-    () => new v8.Deserializer(INVALID_SOURCE),
-    /^TypeError: buffer must be a TypedArray or a DataView$/,
-  );
-}
-
-{
-  const deserializedWasmModule = v8.deserialize(v8.serialize(wasmModule));
-  const instance = new WebAssembly.Instance(deserializedWasmModule);
-  assert.strictEqual(instance.exports.add(10, 20), 30);
-}
-- 
1.8.3.1

