#!/usr/bin/env ash

# Copyright (c) 2015, Laird
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.
#
# contact: ews-support@lairdtech.com

# ifrc - interface_run_config
# Auto-reconfigures an interface via netlink daemon with up/down event support.
#                                                            20120520/20160224

usage() {
  [ "${1:0:5}" == "error" ] \
  && { echo -e "${2:+  $2\n}${3:+\nUsage:\n# $3\n}#"; rv=1; pause 2; }
  cat <<-	\
	usage-info-block
	Configure and/or show interfaces.
	Use settings in '/etc/network/interfaces', or from the command-line.
	Works with a netlink daemon to maintain dhcp/static methods on-the-fly.

	Flags:
	  -q   be quiet, no stdout
	  -v   be more verbose...
	  -n   no logging to files
	  -m   monitor ifrc events
	  -#   inet family protocol
	  -x   run w/o netlink daemon

	Interface:           (ignored with:  /etc/default/ifrc.[iface.]disable)
	  must be kernel-resident, or exec the network-init-script to start
	  can be an alias defined in /e/n/i file

	Action:
	  stop|start|restart   - act on hw-phy init/driver (via: nis)
	  noauto|auto   - unset or set auto-starting an interface in /e/n/i
	  address   - check an interface and report its ip-address, w/ exit code
	  status   - check an interface hw-phy status (if supported by phy-init)
	  up|dn   - up or down the interface configuration (re-'up' to renew)
	  logs   - list or manage related files: {clean|show [<iface>]}
	  eni   - view stanza or edit file: /etc/network/interfaces
	  usage   - view file: /etc/network/networking.README

	Method:
	  dhcp [<param=value> ...]
	     - employ client to get/renew lease, info stored in leases file
	       requestip=x.x.x.x   - request an address (rip) from dhcp server
	       timeout=nn   - seconds to allow client to try/await response

	  static [ip=x.x.x.x[/b] <param=value> ...]
	     - use settings from /e/n/i file or those given on commandline
	       params:  address, netmask, broadcast, gateway  (ip,nm,bc,gw)

	  loopback [ip=x.x.x.x[/b]]
	     - use to set a specific localhost address

	  manual
	     - the interface will not be configured

	Usage:
	# ifrc [flags..] [<iface>] [<action>] [<method> [<param=value> ...]]
	#
	usage-info-block
  #
  exit ${rv:-0}
}

# internals
ifrc_Version=2.03
ifrc_Cmd=${0##*/}\ $@
ifrc_Via=''
ifrc_Lfp=/tmp/ifrc
ifrc_Log=${ifrc_Lfp}/msg

# latch settings
eval $ifrc_Settings
eval zz=\$$#
test "$zz" == '&' \
  && { exec $0 ${@%&}& exit; }

# check network-init-script
test -x ${nis:=/etc/init.d/S??network} \
  || nis="echo Cant exec: ${nis:-network-init-script}"

# ensure /e/n/i exists...
test -s ${eni:=/etc/network/interfaces} \
  || { test -s $eni~ && mv -f $eni~ $eni; } \
  || { rm -f $eni~ && gzip -fdc $eni~.gz >$eni; } \
  || { printf "# $eni - ifrc\n\nauto lo\niface lo inet loopback\n\n\n" >$eni; }

# check mii-diag utility (optional)
test -x ${mii:=/usr/sbin/mii-diag} \
  || mii=

# check resolv.conf configurator (optional)
test -x ${conf_resolv:=/usr/sbin/conf-resolv} \
  || conf_resolv=:\ $conf_resolv
$conf_resolv -c

# validate log-file-path
[ ${#ifrc_Lfp} -gt 5 ] || ifrc_Lfp=/tmp/ifrc
[ -d "$ifrc_Lfp" ] || mkdir -p ${ifrc_Lfp}

# exported module ifrcmp
test -s $ifrc_Lfp/ifrcmp \
  || sed '/^# ifrcmp - /,$!d' $0 > $ifrc_Lfp/ifrcmp

msg() {
  if [ "$1" == "@." ] && shift
  then # has a '@.' prefix
    if [ -n "$mm" ]
    then
      # log to the controlling pty in monitor-mode
      ${qm:+:} echo "$@" >$mm 2>/dev/null || mm=
      # and to syslog if verbose-mode
      ${vm:+logger -tifrc[$$] "$@"}
      return 0
    fi
  else
    # to stdout while not via_flag/quiet-mode
    [ -z "$ifrc_Via$qm" ] && echo "$@" || :
  fi
  # and log to file unless set to /dev/null
  echo "$@" >>${ifrc_Log:-/dev/null} || :
}\
  2>/dev/null

msg_x() {
  # set some message levels according to verbose-mode
  [ -n "${vm:2:1}" ] && alias msg3=msg || alias msg3=:
  [ -n "${vm:1:1}" ] && alias msg2=msg || alias msg2=:
  [ -n "${vm:0:1}" ] && alias msg1=msg || alias msg1=:
  [ -z "${qm:0:1}" ] && alias msg0=msg || alias msg0=:
}

parse_flag() {
  case $1 in
    -h|--help) ## show usage
      usage $2
      ;;
    --|--version) ## rst/report
      echo ifrc -- v$ifrc_Version
      rm -f $ifrc_Lfp/ifrcmp
      if [ ${#1} -eq 2 ]
      then
        x=$( sh -c "sed -n '1p;/^# ifrc/,\$p' $0 2>/dev/null" )
        printf "\t% 35s \b\b$0  ${#x}\n" "${x:+`echo -n "$x" |md5sum`}"
      fi
      exit 0
      ;;
    -q) ## quiet, no stdout
      qm=.
      ;;
    -v) ## add verbosity, multi-level
      vm=$vm' '
      ;;
    -n) ## do not use a log file
      ifrc_Log=/dev/null
      ;;
    -m*) ## monitor nl/ifrc events for iface
      test -z "${mm:=${1:2}}" && { mm=`tty` || mm=/dev/console; }; true
      ;;
    -[046]) ## intend link/inet4/inet6 protocol family
      alias ip=ip\ ${ipf:=$1}
      ;;
    -x) ## do not run netlink daemon
      ifnl_disable=.
      ;;
    -*) ## ignore
      msg \ \ ...ignoring: \[$1\]; return 0
      ;;
    *) ## break
      return 1
  esac \
    && fls=${fls:+$fls }$1
}
while :; do parse_flag $1 && shift || break; done; msg_x

# do not run ifrc if the 'disable' flag-file exists
test -f /etc/default/ifrc.disable \
  && { msg1 "  /etc/default/ifrc.disable exists..."; exit 0; }

# netlink support
ifnl=ifplugd

# set ifnl_s when called via netlink daemon
ifnl_s=${IFPLUGD_PREVIOUS}-\>${IFPLUGD_CURRENT}
ifnl_s=${ifnl_s//error/er}
ifnl_s=${ifnl_s//down/dn}
ifnl_s=${ifnl_s//dormant/dt}
[ "$ifnl_s" == "->" ] && ifnl_s=

# called invocation method
[ -n "$rcS_" ] && ifrc_Via=" <- rcS"
[ -n "$ifnl_s" ] && ifrc_Via=" <- $ifnl"

# support debug: -v -v -v -v -v
[ ${#vm} -ge 5 ] && set -x

# set family
case $ipf in
  '') inet='inet[ 46]*' ;;
  -4) inet='inet[^6]*' ;;
  -6) inet='inet[6]' ;;
  -0) inet='link' ;;
esac

pause() {
  # n[.nnn] sec -- a zero value means indefinite
  test -p ${ifrc_Lfp}/- || mkfifo ${ifrc_Lfp}/- 2>/dev/null
  read -rst${1:-1} <>${ifrc_Lfp}/- 2>/dev/null
  if test $? -eq 2
  then
    s="${1/.*}"
    us="000000"
    [ -z "${1/*.*}" ] && us="${1/*.}$us"
    usleep $s${us:0:6}
  fi
  return 0
}

gipa() {
  local inet=${inet/link/link\/ether}
  # report as true; assigned address(es)
  ip=`ip -o addr sho ${1:-\?} scope global 2>/dev/null |grep -o "$inet.[^ ]*"` \
  && echo ${ip//inet[ 46]}
}

sleuth_wl() {
  # try to find kernel-resident (wireless) interface: wl
  # in this case, it is not certain what the name is ahead of time
  for x in /sys/class/net/*/phy80211
  do
    x=${x##*net/}; x=${x%%/*}; [ "$x" != \* ] && { echo $x; break; }
  done
}

summarize_interface_status() {
  if is=inactive && grep -qs 'u[pn]' /sys/class/net/$dev/operstate
  then
    if is=active && read -r x </sys/class/net/$dev/carrier && ! let x+0
    then
      is="$is, no_carrier/cable/link"
    else
      [ ! -d /sys/class/net/$dev/phy80211 ] \
      && is="$is, linked" \
      || { iw dev $dev link |grep -q Connected && is="$is, associated"; }
    fi 2>/dev/null
  fi
  m=${mp_cdt//f?=} m=${m%% *}
  [ -d ${ifrc_Lfp}/${dev}.cfg ] && is=$is\ \(incomplete\)
  ps ax |grep -q "$ifnl[ ].*${dev}" && is="- $m/managed, $is" || is="- $m, $is"
}

show_interface_config_and_status() {
  fltr=';s/ mtu/\n\t&/;s/\( state [^ ]*\)\(.*\)/\2\1/'
  [ -n "${vm:1:1}" ] \
  || fltr=$fltr';s/ qdisc//;s/ pfi[^ ]*//;s/ master [^ ]\+//;s/ qlen [0-9]\+//'

  # report iface configurations
  ip addr show ${dev:+dev $dev} \
    |sed -e 's/^[0-9]\+: //;s/\([a-z].*:\) /\n\1\t/'"$fltr"';s/    /\t/' \
         -e 's/\(scope [^ ]\+\)[ ][^ ]\+/\1/;/_lft/d'

  # include association info for wireless dev
  wldev=${dev:-$( sleuth_wl )}
  if [ -d /sys/class/net/$wldev/phy80211 ]
  then
    echo -e "\nWiFi:\t`sed 's/up/active/' /sys/class/net/$wldev/operstate`"
    iw dev $wldev link 2>/dev/null \
      |sed 's/^Connec/Associa/;s/t connec.*/t associated (on '$wldev')/' \
      |sed '/[RT]X:/d;/^$/,$d;s/^\t/        /'
  fi
  true
}

ifrc_dhcp_client() {
  # action arg: stop, start, release, renew, term, check
  # extra args: [<param=value> ...]
  # only do if inet4
  test -z "${ipf/-4}" \
    || return 0
  export DHCP_PARAMS=log=$ifrc_Log${mpr:+ mpr=$mpr}${@#$1}

  client_s=$1
  v=${vm//?/ -v} v=${v:-${mm:+-v}}
  # call a <client.sh> wrapper script in /etc/dhcp/..
  # assume the busybox-udhcpc if client not specified
  /etc/dhcp/${client:-udhcpc}.sh $v ${qm:+-q} -i$dev $1; rv=$?
  rmdir ${ifrc_Lfp}/$dev.dhcp 2>/dev/null

  # interrupt link-beat check, while if in-progress
  rmdir ${ifrc_Lfp}/$dev.lbto 2>/dev/null
  return $rv
}

ifrc_netlink_daemon() {
  if [ -n "$ifnl_disable" ] \
  || [ "$1" == "stop" ]
  then
    prg="${ifnl##*/}"
    # find daemon instances for this interface
    for pid in \
    $( ps ax |sed -n "/${dev}/s/^[ ]*\([0-9]*\).*[\/ ]\(${prg}\) -.*/\1_\2 /p" )
    do
      kill ${pid%%_*} && msg1 "  $pid <- sigterm:0"
    done
  else
    mkdir ${ifrc_Lfp}/$dev.nld 2>/dev/null \
       || { msg1 "$ifnl start, ...already in progress"; return 0; }

    if ! { ps ax |grep -q "$ifnl[ ].*${dev}" && msg2 "  $ifnl is running"; }
    then
      # when not verbose, don't log to syslog
      [ -z "${vm:0:1}" ] && nsl=-s || nsl=
      #
      # allow auto API mode for all interfaces except wireless
      $phy80211 && api=-miff
      #
      # start the netlink daemon
      $ifnl -i$dev $api $nsl -fa -qMp -u0 -Ir$0 -x\&

      msg1 "  $ifnl started"
    fi
  fi
  rmdir ${ifrc_Lfp}/$dev.nld 2>/dev/null
}

# The 1st arg should be an interface dev name.
# However, some actionable exceptions can be handled before qualifing iface dev.
case ${1:-show} in
  stop|start|restart) ## call network-init-script w/action-&-method, no return
    ifrc_netlink_daemon stop
    [ -n "${vm:0:1}" ] && set -x
    exec $nis $1 $2
    ;;

  log|logs) ## ifrc files
    f=${3/[a-z][a-z]*/-}
    if [ "${2:0:4}" == "show" -a "$f" == - ]
    then
      less -Em~ ${ifrc_Lfp}/$3 2>/dev/null
    elif [ "${2:0:4}" == "clea" -a "$f" == - ]
    then
      for f in ${ifrc_Lfp}/${3:-*}*; do
        rm $f 2>/dev/null && let ++c && echo -n ${f##*/}' '
      done
      let c && echo ...removed from $ifrc_Lfp
    else
      for x in $ifrc_Lfp/*; do [ -f $x ] && printf "% 8d %s\n" `wc -c $x`; done
    fi
    exit $?
    ;;

  show) ## report any/all interfaces
    printf "Configuration for all interfaces:% 47s\n" "(try -h to see usage)"
    if show_interface_config_and_status
    then
      echo
      /etc/network/bridge.sh 2>/dev/null && echo
      # inet protocol family
      if [ "$ipf" != "-0" ]
      then
        echo "Routing:"
        ip route show ${vm:-scope global}
        if [ -n "$vm" ]
        then
          echo -e "\nRules.."
          ip rule show
        fi
        echo -e "\nDNS:\r\tresolv.conf"
        sed '/^#/d;/^$/d' /etc/resolv.conf 2>/dev/null
      fi
    fi
    exit 0
    ;;

  usage) ## view the readme file
    less -m~ /etc/network/networking.README
    exit $?
    ;;

  eni) ## edit the /e/n/i file
    cp -f $eni ${ifrc_Lfp}/${eni##*/}~
    if vi ${ifrc_Lfp}/${eni##*/}~ -c /^${2:+"iface $2.*"}$ \
    && ! cmp -s ${ifrc_Lfp}/${eni##*/}~ $eni
    then
      [ -s ${ifrc_Lfp}/${eni##*/}~ ] \
      && mv -f ${ifrc_Lfp}/${eni##*/}~ $eni \
      || echo "unable to copy edited $eni into place"
    fi
    exit $?
    ;;

  noauto|auto) ## report 'auto <iface>'s
    echo $1 interfaces: `sed -n "/^${1/no/#} [a-z]/s/^.* / /p" $eni |tr -d '\n'`
    echo "  ...usage: ${0##*/} <iface> {noauto|auto}"
    exit 0
    ;;

  flags|addr*|stat*|down|dn|up) ## require iface
    usage error: "...must specify an interface" "ifrc <iface> $1"
    ;;

  [a-z][a-z]*) ## accept an <iface> dev name starting with two letters
    dev=$1 && shift
    [ -f /etc/default/ifrc.$dev.disable ] \
    && { msg1 "  /etc/default/ifrc.$dev.disable exists..."; exit 1; }
    ;;

  *) ## error
    usage error: "...invalid interface name"
esac

read_ifrc_info() {
  if [ -f $ifrc_Lfp/$1 ] \
  && exec 3< $ifrc_Lfp/$1
  then
    x= # method-&-params, and cdt{ *cfg-do tasks ;}
    read -rs x <&3 \
      && [ "${x/mp_cdt:*/mp_cdt}" == mp_cdt ] \
      && mp_cdt=${x#*:}

    x= # crc32 of the iface stanza from /e/n/i file
    read -rs x <&3 \
      && [ "${x/eni_sk:*/eni_sk}" == eni_sk ] \
      && eni_sk=${x#*:}

    x= # iface rc info as alias=iface and any flags
    read -rs x <&3 \
      && [ "${x/ifrc_i:*/ifrc_i}" == ifrc_i ] \
      && ifrc_i=${x#*:}

    if [ -n "$ifrc_i" ]
    then
      #:alias=iface & settings
      ifrc_Settings=${ifrc_i#* }
      ifrc_i=${ifrc_i% $ifrc_Settings}
    : ${devalias:=${ifrc_i%=*}}
    : ${dev:=${ifrc_i#*=}}
    fi
    exec 3<&-
    if [ -n "$devalias" ]\
    && [ -n "$dev" ]
    then
      # re-eval appended settings
      eval ${ifrc_Settings##*;}
      return $?
    fi
  fi
  return 1
}

if ! read_ifrc_info $dev \
|| [ -n "${dev/$devalias}" ] \
|| [ -z "$mp_cdt" -o 0${eni_sk#* } -eq 0 ]
then
  # Generally, operations are on a specific interface.
  # It is possible that the $dev may initially be unknown.
  # A stanza uses '$dev' as a dev*alias or as dev*iface name.
  # Retry lookup if cache read fail or dev*iface != dev*alias.
  # For /e/n/i stanza lookups, we assume the use of dev*alias.
  msg3 "  checking /e/n/i file..."
  D='[a-z][a-z][a-z0-9]*'
  devalias=$( sed -n "/$dev/s/^[ \t]*alias \($D\)[ is]* \($D\)/\1 \2/p" $eni )
  if [ -n "$devalias" ]
  then
    if grep -q "^iface ${devalias%% *} inet" $eni
    then : \## matched dev*alias name via option alias
      ifacemsg="${devalias%% *} (alias)"
      dev=${devalias##* }
      devalias=${devalias%% *}
    elif grep -q "^iface ${devalias##* } inet" $eni
    then : \## matched dev*iface name via option alias
      ifacemsg="${devalias##* } (${devalias%% *} alias)"
      dev=${devalias##* }
      devalias=${devalias##* }
    else : \## assumed via option alias
      devalias=${devalias##* }
    fi
  elif grep -q "^iface $dev inet" $eni
  then : \## matched name as specified
    ifacemsg="$dev"
    devalias=$dev
  fi

  # dev*alias is used to further process settings for dev*iface in /e/n/i
  msg3 "  iface stanza: ${ifacemsg:-?}"
  test -n "$devalias" \
    || { msg "  unknown iface/alias: ${ifacemsg:-?}"; exit 1; }

  # check if multipath polcy routing is enabled
  grep -q "^allow-multipath" $eni && mpr=yes || mpr=

  # re-attempt lookup using dev*iface?
  [ -n "$eni_sk" ] || read_ifrc_info $dev

  # read ifrc-flags if not more than '-v' specified on cli - cummulative
  test -z "${fls//-v/}" \
    && fls=${fls//-v/} \
    && flags_eni=$( sed -n "/^iface $devalias/,/^$/\
                      s/^[ \t]\+[^#]ifrc-flags \(.*\)/\1/p" $eni )
  #
  # apply flags from iface stanza in /e/n/i
  for af in $flags_eni; do parse_flag $af || break; done; msg_x
fi
msg3 "  dev*alias/dev*iface: ${devalias:-?}/${dev:-?}"
test -n "$dev" \
  || { msg "iface?"; exit 1; }

# check if this is a wireless interface
test -d /sys/class/net/$dev/phy80211 && phy80211=true || phy80211=false

# Set logfile name for this iface.
ifrc_Log=${dev:+${ifrc_Lfp}/$dev}
{ read -rs us is < /proc/uptime; } 2>/dev/null

# A tmp file per iface is used for run-config and logging event/state/actions.
# Reserved lines are:
# 1.'mp_cdt' method-&-params, *cfg-do tasks -{ when run-config status is 'up' }
# 2.'eni_sk' stanza cksum from /e/n/i -{ when differs then not a re-'up' }
# 3.'ifrc_i' interface run-config info -{ invocation options for 'up' }
#
# Each successive <iface> event-state-action is time stamped.
# Limit the file size to about 100-blocks, by snipping twenty lines
# of content within the log, and while retaining twenty line header.
{ test ! -f $ifrc_Log && x="\n\n\n    -- v$ifrc_Version" || x=; }
{ test 0`wc -c < $ifrc_Log` -le 102400 \
    || sed '21,41d;42i<snip>' -i $ifrc_Log; } 2>/dev/null
printf "${x%  -}\n% 13.2f -- $$_${ifrc_Cmd}${ifrc_Via}\n" $us >>$ifrc_Log

fn() {
  # capture the passed in command and args with error context to logfile
  exec 3>&1; fn_x=$( $@ 2>&1 1>&3 ) && x=\+ || x=\?; exec 3>&-
  msg2 "$x $*${fn_x:+\n$fn_x}"
  test "$x" != \?
}

cdt() {
  # process *cfg-do tasks
  eval t=\$${1} d=$1 ${1}=
  if [ -n "${t}" ]
  then
    test -n "$vm" \
      && echo -E "  ${d//_/-}( $t )"
    ( $t ); x=$? t=${t%% *} c=${t##*/}
    echo \ \ ${d//_/-}: ${c#$t} $x
    return $x
  fi |tee -a $ifrc_Log 2>&1
}

ifrc_cache() {
  if [ "$1" != "save" ]
  then
    mp_cdt=${mp_cdt:+$mp_cdt }$1
    return
  fi
  ## save cache
  if [ "${methvia/*cfg*/cfg}" != "cfg" ]
  then
    if [ -n "$IFRC_SCRIPT" ]
    then
      # strip newlines and expand other escapes for sed
      IFRC_SCRIPT=${IFRC_SCRIPT//$'\n'/ }
      IFRC_SCRIPT=${IFRC_SCRIPT//\\/\\\\}
      set -- "$mp_cdt cdt{ $IFRC_SCRIPT\; }"
    else
      set -- "$mp_cdt"
    fi
    sed "1cmp_cdt:$@" -i $ifrc_Log
  fi
  ## show cache
  if [ -n "$vm" ]
  then
    if [ -n "$ip$nm$nw$wc$bc$gw$ns" ]
    then
      echo \ \ ip: $ip
      echo \ \ nm: $nm
      echo \ \ nw: $nw
      echo \ \ wc: $wc
      echo \ \ bc: $bc
      echo \ \ gw: $gw
      echo \ \ ns: $ns
    fi
    [ -n "$rip" ] && msg request-ip-address: $rip
    [ -n "$client" ] && msg dhcp client: $client
    [ -n "$metric" ] && msg metric is: $metric
    [ -n "$weight" ] && msg weight is: $weight
  fi
  true
}

msg3 -e "env:\n`env |sed -n 's/^IF[A-Z]*_.*/  &/p' |grep . || echo \ \ ...`\n"

# internal options - carried per instance
# appended items with semicolon are re-evaluated
export ifrc_Settings=fls=\"$fls\"\ mm=$mm\ vm=$vm\ qm=$qm\;\ mpr=$mpr

# external globals - carried per instance and can be used by *-do scripts
export IFRC_STATUS="${ifnl_s:-  ->  }"
export IFRC_DEVICE=$dev
export IFRC_ACTION
export IFRC_METHOD
#export IFRC_SCRIPT

# determine action to apply - assume 'show'
test -n "$1" \
  && { IFRC_ACTION=$1; shift; } \
  || { [ -z $ifnl_disable ] && IFRC_ACTION=show; }

# determine method, params and tasks to apply
if [ "$IFRC_ACTION" == "up" ]
then
  # get current iface stanza crc from /e/n/i  (stanza n/a when '4294967295 0')
  eni_sc=$( sed "/./{H;$!d;};x;/[#]*iface $devalias inet/!d;a\\" $eni |cksum )

  if [ -n "$ifnl_s" ]
  then
    # a re-'up' called by ifnl
    methvia="(ifnl: $dev.cfg)"
    IFRC_METHOD=${mp_cdt%% cdt{*}
    IFRC_SCRIPT=${mp_cdt/*cdt{/{}
  else
    if [ -n "$1" ]
    then
      # remaining args: method-&-params, cdt{ *cfg-do's
      methvia="(set via cli)"
      IFRC_METHOD=${@%% cdt{*}
      IFRC_SCRIPT=${@##* cdt{}
    else
      # re-'up' when iface stanza not changed in eni
      if [ -n "$mp_cdt" -a -z "${eni_sc/$eni_sk}" ]
      then
        # use cfg in lieu of change
        methvia="(via $dev.cfg)"
        IFRC_METHOD=${mp_cdt%% cdt{*}
        IFRC_SCRIPT=${mp_cdt/*cdt{/{}
      else
        # use eni settings
        methvia="(via /e/n/i)"
        # use first iface inet and its trailing options
        for ifm in $( sed -n "/^iface $devalias $inet/\
                             {s/.* \($inet\) \([a-z]*\)/\1_\2/p;}" $eni )
        do xfm=
          case $ifm in
            inet[^6]*) xfm=${ifm/*_/f4=} ;;
            inet[6]*) xfm=${ifm/*_/f6=} ;;
            link*) xfm=${ifm/*_/f0=} ;;
          esac
          set -- $xfm \
             $( sed "/^iface $devalias ${ifm/_/ }/,/^if/!d;/^$/q;\
                          /ifrc-/d;/alias/d;\
                            s/^[ \t]\+\([^#][a-z]*\)[ ]\(.*\)/\1=\2/p" -n $eni )

          IFRC_METHOD=${IFRC_METHOD}${IFRC_METHOD:+ }$@
        done
      fi
    fi

    # check /e/n/i stanza for ifrc-pre/post-d/cfg-do tasks
    # and only if not already set and not via nld
    # use tasks following matching iface inet
    if [ -z "$IFRC_SCRIPT" -a -z "$ifnl_s" ]
    then
      msg3 "parsing /e/n/i for $dev pre/post-d/cfg-do directives"
      set -- "$( sed "/^iface $devalias inet /,/^if/{/^$/q;\
         s/^[ \t]\+[^#]\(p[or][se][t]*\)-\([d]*cfg\)-do \(.*\)/\1_\2_do='\3'/p;\
         s/^[ \t]\+[^#]\(delay\)-\([d]*cfg\) \(.*\)/\1_\2='\3'/p;}" -n $eni 2>/dev/null )"
      INET_SCRIPT=${@//$'\n'/ }
      set -- "$( sed "/^iface $devalias inet6 /,/^if/{/^$/q;\
         s/^[ \t]\+[^#]\(p[or][se][t]*\)-\([d]*cfg6\)-do \(.*\)/\1_\2_do='\3'/p;\
         s/^[ \t]\+[^#]\(delay\)-\([d]*cfg6\) \(.*\)/\1_\2='\3'/p;}" -n $eni 2>/dev/null )"
      INET6_SCRIPT=${@//$'\n'/ }
      IFRC_SCRIPT="$INET_SCRIPT $INET6_SCRIPT"
    fi
  fi
  shift $#

  # assume method if none
  if [ -z "$IFRC_METHOD" ]
  then
    methvia="(assumed)"
    IFRC_METHOD="dhcp"
  fi
  IFRC_SCRIPT=${IFRC_SCRIPT#$IFRC_METHOD}
elif \
   [ "$IFRC_ACTION" == "dn" ] \
|| [ "$IFRC_ACTION" == "down" ]
then
  if [ "${mp_cdt/*cdt{*/cdt}" == "cdt" ]
  then
    IFRC_SCRIPT=${mp_cdt/*cdt{/{}
  fi
fi
eval $IFRC_SCRIPT 2>/dev/null \
  || msg "**cfg-do-task error - $IFRC_SCRIPT"

#
# Determine netlink event rule to apply via the reported iface status.
# The action may be overridden depending on the following event rules.
#
if [ -n "$ifnl_s" ]
then
  ifnl_event_action() {
    [ -n "${1/--}" ] && IFRC_ACTION=$1
    ${ifnl_event_action_notify:=true} \
     && ifnl_event_action_notify=false \
     && msg @. \ $IFRC_STATUS $IFRC_DEVICE ${IFRC_ACTION:-??} ${IFRC_METHOD%% *}
    ${2:+msg @. "    ${@#$1}"}
  }
  shift $#

  ## configuration already in progress
  #test -d ${ifrc_Lfp}/$dev.cfg && exit 0

  ## nl event rules for status '  ->dn'
  while [ "${IFRC_STATUS##*->}" == "dn" ]
  do
    ## handle a temporarily lost interface
    if [ ! -f /sys/class/net/$dev/carrier ]
    then
      ifnl_event_action -- iface\?
      msg1 $dev is gone, waiting 2s
      pause 2
      if [ ! -f /sys/class/net/$dev/carrier ]
      then
        msg1 $dev is gone, allowing deconfigure
      else
        ifnl_event_action xx
        msg1 ignoring dn event - iface is back
      fi
      break
    fi

    ## option no/wait ip-dcfg
    if [ -n "$delay_dcfg" ]
    then
      let delay_dcfg || { ifnl_event_action xx; break; }
      # when 'delay_dcfg' is zero then no deconfigure
      # otherwise, wait 'delay_dcfg' before deconfigure
      # an 'up' event will cancel any pending deconfigure
      #
      echo "$$: $0 $@" >${ifrc_Lfp}/$dev.dd \
        && ifnl_event_action -- delay_dcfg \
        && pause $delay_dcfg

      if [ -f ${ifrc_Lfp}/$dev.dd ]
      then
        rm -f ${ifrc_Lfp}/$dev.dd
      else
        ifnl_event_action xx
        break
      fi
    fi

    if [ "${IFRC_METHOD/*f6=dhcp*/dhcp}" == "dhcp" ] || [ "${IFRC_METHOD/*f6=auto*/auto}" == "auto" ]
    then
      ## handle dhcpv6 ip-dcfg
      /usr/sbin/dhclient6.sh release $dev
    fi

    ## handle dhcp ip-dcfg
    if [ "${IFRC_METHOD/*f4=dhcp*/dhcp}" == "dhcp" ]
    then
      ifnl_event_action xx
      if [ ! -d ${ifrc_Lfp}/$dev.dhcp ]
      then
        ifrc_dhcp_client release
      else
        msg1 "dhcp client lock exists, no act"
      fi
      break
    fi

    ## handle static ip-dcfg
    ip -4 addr flush dev $dev 2>/dev/null

    ## otherwise ignore down event via ifnl
    ifnl_event_action xx
    break
  done

  ## nl event rules for status '  ->up'
  while [ "${IFRC_STATUS##*->}" == "up" ]
  do
    ifnl_event_action

    if $phy80211 \
    && [ "${IFRC_STATUS}" == "dt->up" ]
    then
      msg @. "  probable roam, was dormant"
    fi

    ## option ip-dcfg cancelled
    { read -r zz < ${ifrc_Lfp}/$dev.dd; } 2>/dev/null \
    && { kill ${zz%%:*}; rm -f ${ifrc_Lfp}/$dev.dd ]; }

    if [ "${IFRC_METHOD/*f6=dhcp*/dhcp}" == "dhcp" ] || [ "${IFRC_METHOD/*f6=auto*/auto}" == "auto" ]
    then
      if $phy80211
      then
        # this is likely a 'reconnect' or 'roam' related event
        # if for AP with same SSID, then try dhcp-esa: refresh
	usr/sbin/dhclient6.sh release $dev
      fi
	# renew failure is handled via re-up config...
	usr/sbin/dhclient6.sh renew $dev
    fi

    ## handle dhcp ip-cfg renew/refresh
    if [ "${IFRC_METHOD/f4=dhcp/dhcp}" == "dhcp" ]
    then
      if mkdir ${ifrc_Lfp}/$dev.dhcp 2>/dev/null
      then
        if $phy80211
        then
          # this is likely a 'reconnect' or 'roam' related event
          # if for AP with same SSID, then try dhcp-esa: refresh
          ifrc_dhcp_client refresh
        fi
        # renew failure is handled via re-up config...
        ifrc_dhcp_client renew && IFRC_ACTION=xx
      else
        msg1 "dhcp client lock exists, no act"
        IFRC_ACTION=xx
      fi
      break
    fi
    break
  done
else #!via ifnl
  case $IFRC_ACTION in
    up|dn|down)
      ## option ip-dcfg cancelled
      { read -r zz < ${ifrc_Lfp}/$dev.dd; } 2>/dev/null \
      && { kill ${zz%%:*}; rm -f ${ifrc_Lfp}/$dev.dd ]; }
      ;;
  esac
fi

# rt_tables support...
if [ "$mpr" == "yes" ] \
&& { ip rule >/dev/null 2>&1; } \
&& [ -f /etc/iproute2/rt_tables ] \
&& { read i < /sys/class/net/$dev/ifindex; } 2>/dev/null
then
  tn=t.$dev
  grep -q "$tn" /etc/iproute2/rt_tables \
    || { let i+=100; printf "$i\t$tn\n" >>/etc/iproute2/rt_tables; }
fi

#
# The hw-phy/init scripts are responsible for creating/removing an iface.
# This script uses down/up with respect to interface (de)configuration only!
#
case $IFRC_ACTION in
  address|addr) ## check if iface is configured and show its ip-address
    # affirm configured <iface>: ip-address [...status]:0/1
    # returns true if the iface is configured with an ip-address
    is=; ip=$( gipa $dev ); rv=$?
    [ -n "${vm:0:1}" ] && { ip=${ip:-0.0.0.0}; summarize_interface_status; }
    [ -n "$ip$is" ] && msg $ip $is
    exit $rv
    ;;

  status) ## call on phy-init for status, no return
    [ -n "${vm:0:1}" ] && set -x
    exec $nis $dev $IFRC_ACTION ${IFRC_METHOD%% *}
    ;;

  show) ## show info/status for an iface
    test -f /sys/class/net/$dev/uevent \
    || { echo \ \ ...not available, not a kernel-resident interface; exit 1; }
    summarize_interface_status
    echo Configuration for interface: ${ifacemsg:-$dev} $is
    if grep -qs Generic /sys/class/net/$dev/*/uevent
    then
      echo Using 'Generic PHY' driver
      [ -n "$mii" ] && $mii $dev |sed -n '/Yo/,$d;/media type/,$p'
    fi
    show_interface_config_and_status
    if [ "${dev:0:2}" == "br" ]
    then
      echo
      /etc/network/bridge.sh 2>/dev/null
    else
      if [ "$dev" == "lo" ]
      then
        echo -e "\nRouting: (local)"
        ip route show table local dev $dev \
        |sed 's/^/  /;s/broad/b/;s/  pr/\t pr/'
      else
        echo -e "\nRouting: "
        ip route show ${tn:+table t.$dev} dev $dev 2>/dev/null \
        || { msg "  note - $tn not in rt_tables"; ip route show dev $dev; }
        echo -e "\nARP:     \n  ...\c"
        ip neigh show dev $dev \
          |sed '1s/^./\r&/;s/lladdr/at/'
      fi
    fi
    if [ -n "${vm:0}" ]
    then
      echo -e "\nProcesses:"
      ps ax -opid,stat,args |grep "[ .iI]$dev[ .]" || echo \ \ ...
    fi
    echo
    ;;

  flags) ## (re)set ifrc-flags for an iface
    msg "not implemented"
    ;;

  eni) ## report interface stanza
    sed '/./{H;$!d;};x;/[#]*iface '"$devalias inet"'/!d;a\\' $eni
    ;;

  noauto|auto) ## unset or set auto-starting an interface
    auto=${IFRC_ACTION/no/#}
    if grep -q "auto $devalias$" $eni
    then
      ## edit the #auto|auto iface, for the interface stanza
      sed "/^[#]*auto $devalias$/s/^.*/$auto $devalias/" $eni >$eni~
    else
      if grep -q "^iface $devalias inet" $eni
      then
        ## insert a #auto|auto iface, for the interface stanza
        sed "/^iface $devalias inet/i$auto $devalias" $eni >$eni~
      else
        echo "$devalias stanza not found in $eni"
        exit 1
      fi
    fi
    [ -s $eni~ ] && mv -f $eni~ $eni
    ;;

  stop|start|restart) ## act on phy-init/driver, does not return
    ifrc_netlink_daemon stop
    [ -n "${vm:0:1}" ] && set -x
    exec $nis $dev $IFRC_ACTION ${IFRC_METHOD%% *}
    ;;

  down|dn) ## assume down action ->deconfigure
    msg1 "deconfiguring $dev"
    ifrc_netlink_daemon stop

    cdt pre_dcfg6_do
    cdt pre_dcfg_do

    /usr/sbin/dhclient6.sh stop
    ifrc_dhcp_client stop

    sed '1cmp_cdt:' -i $ifrc_Log

    # remove all relative entries from the routing table
    # the iface is still up and accessible to the IP layer
    fn ip addr flush dev $dev

    # remove any applicable policy rules for the iface
    while ip rule del table $tn 2>/dev/null; do :;done

    fn ip ${vm:+-s} route flush cache
    #fn ip link set dev $dev down

    cdt post_dcfg6_do
    cdt post_dcfg_do &

    rmdir ${ifrc_Lfp}/$dev.* 2>/dev/null || :
    ;;

  up) ## assume up action ->reconfigure
    if [ ! -f /sys/class/net/$dev/uevent ]
    then
      # interface does not exist yet, must start
      if mkdir ${ifrc_Lfp}/$dev.nis 2>/dev/null
      then
        sed '1cmp_cdt:' -i $ifrc_Log
        unset IFRC_SCRIPT IFRC_STATUS
        msg "interface is not kernel-resident, trying to start ..."
        [ -n "${vm:0:1}" ] && set -x
        exec $nis $dev start ${IFRC_METHOD%% *}
      else
        msg "interface is not kernel-resident, try:  ifrc $dev start"
        exit 1
      fi
    fi
    rmdir ${ifrc_Lfp}/$dev.nis 2>/dev/null

    # assume inet protocol family to use
    test "${IFRC_METHOD/f?=*/fx}" != "fx" \
      && { x=${ipf:1:1}; IFRC_METHOD=f${x:-4}=${IFRC_METHOD}; }

    fm=
    for x in $IFRC_METHOD
    do
      test "${x/f?=*/fm}" == "fm" \
        && fm=${fm}${fm:+/}${x/=/_}
    done

    # affirm if this is a re-'up' as a 're-'conf
    test "${methvia/*cfg*/cfg}" == "cfg" && re=re || re=

    msg1 "${re}configuring $dev with ${fm:--?-} ${methvia:-(-?-)}"
    mkdir ${ifrc_Lfp}/$dev.cfg 2>/dev/null \
      || { msg0 "  ...$dev.cfg already in progress"; exit 0; }

    if [ -n "$re" ]
    then : \## reconfig 'up'
      test -z "$ifnl_s" \
        && ifrc_netlink_daemon stop

    else : \## new conf 'up'
      mp_cdt=
      sed -e "1cmp_cdt:$mp_cdt" \
          -e "2ceni_sk:$eni_sc" \
          -e "3cifrc_i:$devalias=$dev $ifrc_Settings" \
          -i $ifrc_Log

    fi

    if [ "${methvia/*cfg*/cfg}" != "cfg" -a ! -n "$re" ]
    then
      cdt pre_cfg6_do
      cdt pre_cfg_do &
    fi

    # Ensure that iface is up and the netlink daemon is active.
    fn ip link set dev $dev up
    if [ -z "$ifnl_s" ]
    then
      [ "${IFRC_METHOD%% *}" == "manual" ] && ifnl_disable=.
      [ "$dev" == "lo" ] && ifnl_disable=.
      ifrc_netlink_daemon
    fi

    # This script can exit with a zero value, even if configuration is deferred,
    # which is considered a valid state.  A subsequent link 'up' event captured
    # by the netlink daemon, will cause configuration to be re-attempted for:
    # 1. wifi is not associated yet (handled by supplicant)
    # 2. cable/link not present yet
    #
    . $ifrc_Lfp/ifrcmp || { rv=$?; msg "ifrcmp error: $dev"; exit $rv; }

    if [ "${methvia/*cfg*/cfg}" != "cfg" -a ! -n "$re" ]
    then
      cdt post_cfg6_do
      cdt post_cfg_do &
    fi
    rmdir ${ifrc_Lfp}/$dev.cfg 2>/dev/null || :
    ;;

  \.\.) ## refresh cached configuration
    eni_sc=$( sed "/./{H;$!d;};x;/[#]*iface $devalias inet/!d;a\\" $eni |cksum )
    if [ -d ${ifrc_Lfp}/$dev.cfg ]
    then
      msg1 \ \ ...$dev.cfg exists, no refresh
    else
      sed -e "2ceni_sk:$eni_sc" \
          -e "3cifrc_i:$devalias=$dev $ifrc_Settings" \
          -i $ifrc_Log
    fi
    ;;

  '') ## no action unless disable nl for interface
    [ -n "$ifnl_disable" ] && ifrc_netlink_daemon stop
    ;;

  er|dt|xx|\.*) ## no action
    msg2 \ \ ...no action on $dev
    ;;

  *) ## usage/error
    usage error: "...invalid action specified"
esac
exit $? \
  || : << '$ifrc_Lfp/ifrcmp'

# ifrcmp - interface_run_config_method_params
# the following code is exported as $ifrc_Lfp/ifrcmp as necessary
# it will be sourced by ifrc to apply iface network configuration

ifrcmp_validate_manual() {
  for x in $fmp
  do
    case ${x%%=*} in
      f?|manual) ## method
        x=${fm%=*}=${x##*=}
        ;;
      *)
        msg3 "ignoring param: [$x]"
        continue
    esac
    ifrc_cache $x
  done
  ifrc_cache save
}

ifrcmp_validate_loopback() {
  for x in $fmp
  do
    case ${x%%=*} in
      f?|loopback) ## method
        x=${fm%=*}=${x##*=}
        ;;
      ip|address)
        ip=${x##*=}
        x=ip=$ip
        ;;
      nm|netmask)
        ##
        ;;
      *)
        msg3 "ignoring param: [$x]"
        continue
    esac
    ifrc_cache $x
  done
  ifrc_cache save
}

ifrcmp_validate_f6static() {
  for x in $fmp
  do
    case ${x%%=*} in
      f6|static) ## method
        x=f6=${x##*=}
        ;;
      ip|address)
        ip=${x##*=} ip=${ip%/*}
        test ${ip//[0-9a-f:]/0} -eq 0 2>/dev/null \
          || { msg "invalid f6 address: $ip"; return 2; }
        test -z "$nm" \
          && nm=${x#*$ip/} nm=${nm#*$ip}
        x=ip=$ip${nm:+ nm=$nm}
        ;;
      nm|netmask)
        nm=${x##*=}
        x=nm=$nm
        ;;
      gw|gateway)
        gw=${x##*=}
        test ${gw//[0-9a-f:]/0} -eq 0 2>/dev/null \
          || { msg "invalid f6 gateway: $gw"; return 2; }
        x=gw=$gw
        ;;
      scope)
        case ${x##*=} in global|site|link|host) scope=${x##*=} ;; esac
        ;;
      *)
        msg3 "ignoring param: [$x]"
        continue
    esac
    ifrc_cache $x
  done
  : ${ip:=::}
  test ${nm:=0} -ge 0 -a ${nm} -le 128 2>/dev/null \
    || { msg "invalid f6 netmask: $nm"; return 2; }
  ifrc_cache save
}

ifrcmp_validate_f4static() {
  for x in $fmp
  do
    case ${x%%=*} in
      f4|static) ## method
        x=f4=${x##*=}
        ;;
      ip|address)
        ifrcmp_cidr_to_ip_nm ${x##*=}
        x=ip=$ip${nm:+ nm=$nm}
        ;;
      nm|netmask)
        nm=${x##*=}
        x=nm=$nm
        ;;
      gw|gateway)
        gw=${gw:+$gw }${x##*=}
        x=gw=$gw
        ;;
      bc|broadcast)
        bc=${x##*=}
        x=bc=$bc
        ;;
      ns|nameserver)
        ns=${ns:+$ns }${x##*=}
        ;;
      metric)
        metric=${x##*=}
        ;;
      weight)
        weight=${x##*=}
        ;;
      *)
        msg3 "ignoring param: [$x]"
        continue
    esac
    ifrc_cache $x
  done
  ifrcmp_calc_nw_wc_bc ${ip:=0.0.0.0} ${nm:=255.255.255.255} || :
  ifrc_cache save
}

ifrcmp_validate_f6auto() {
  for x in $fmp
  do
    case ${x%%=*} in
      f6|auto) ## method
        x=f6=${x##*=}
        ;;
      *)
        msg3 "ignoring param: [$x]"
        continue
    esac
    ifrc_cache $x
  done
  ifrc_cache save
}

ifrcmp_validate_f6dhcp() {
  for x in $fmp
  do
    case ${x%%=*} in
      f6|dhcp) ## method
        x=f6=${x##*=}
        ;;
      client) ## preferred client
        client=${x##*=}
        ;;
      *)
        msg3 "ignoring param: [$x]"
        continue
    esac
    ifrc_cache $x
  done
  ifrc_cache save
}

ifrcmp_validate_f4dhcp() {
  for x in $fmp
  do
    case ${x%%=*} in
      f4|dhcp) ## method
        x=f4=${x##*=}
        ;;
      rip|requestip) ## specify ip to request from server (if supported)
        rip=${x##*=}
        ;;
      metric) ## apply a hop metric for default router
        metric=${x##*=}
        ;;
      weight) ## apply a nexthop weight for router
        weight=${x##*=}
        ;;
      to|timeout) ## specify a minimum timeout of 4s
        to=${x##*=}; [ 4 -le $to ] || let to=4
        ;;
      client) ## specify a preferred client
        client=${x##*=}
        ;;
      *)
        msg3 "ignoring param: [$x]"
        continue
    esac
    ifrc_cache $x
  done
  ifrc_cache save
}

ifrcmp_await_f6dad() {
  local idad_timer=50
  while let --idad_timer ## deciseconds
  do
    [ -n "$( ip -6 -o addr list dev $dev | grep "link/ether" )" ] \
    && [ -z "$( ip -6 -o addr list dev $dev | grep "scope global tentative" )" ] \
    && [ -z "$( ip -6 -o addr list dev $dev | grep "scope link tentative" )" ] \
    && break
    usleep 87654
  done
}

ifrcmp_await_f4dhcp() {
  if [ -n "$to" ]
  then
    msg3 "awaiting dhcp offer.."
    # exit non-zero of timeout waiting for ip-address
    # there will not be any automatic restart nor netlink event
    while let to--; do pause 1; gipa $dev && { to=0; break; }; done
    if [ $to -lt 0 ]
    then
      ifrc_dhcp_client stop
      msg "dhcp timeout"
      false
    fi
  fi
}

ifrcmp_calc_nw_wc_bc() {
  if [ "${ip/[0-9]*.[0-9]*.[0-9]*.[0-9]*/dqa}" == "dqa" ] \
  && [ "${nm/[0-9]*.[0-9]*.[0-9]*.[0-9]*/dqa}" == "dqa" ]
  then
    local n x1 x2 x3 x4 a1 a2 a3 a4 m1 m2 m3 m4
    # load octets for ip-address and netmask
    set -- ${ip//./ }; a1=$1 a2=$2 a3=$3 a4=$4
    set -- ${nm//./ }; m1=$1 m2=$2 m3=$3 m4=$4

    for n in 1 2 3 4; do eval 'let x$n="a$n & m$n"'; done
  : ${nw:=$x1.$x2.$x3.$x4}

    for n in 1 2 3 4; do eval 'let x$n="255 -(x$n | m$n)"'; done
  : ${wc:=$x1.$x2.$x3.$x4}

    for n in 1 2 3 4; do eval 'let x$n="x$n +(a$n & m$n)"'; done
  : ${bc:=$x1.$x2.$x3.$x4}

    unset n x1 x2 x3 x4 a1 a2 a3 a4 m1 m2 m3 m4
  else
    msg "Error: invalid address (ip) and/or netmask (nm) specified."
    return 1
  fi
} #2>/dev/null

ifrcmp_cidr_to_ip_nm() {
  if ip=${1%/*} && [ ${1%/[0-9]*} != ${1} ]
  then
    local px maskpat=255\ 255\ 255\ 255
    local mx maskdgt=254\ 252\ 248\ 240\ 224\ 192\ 128
    let px=${1#*/}/8 px*=4 mx=7-${1#*/}%8 mx*=4
    set -- ${maskpat:0:$px}${maskdgt:$mx:3}
  : ${nm:=${1:-0}.${2:-0}.${3:-0}.${4:-0}}
    unset px maskpat mx maskdgt
  fi
}

ifrcmp_check_if_link() {
  test -n "$ifnl_s" && return
  mkdir ${ifrc_Lfp}/$dev.lbto

  # await link-beat-time-out of 4s or 20s
  $phy80211 && lbto=4000 || lbto=20000
  let n=0
  while [ $n -lt $lbto -a -d ${ifrc_Lfp}/$dev.lbto ]
  do
    if $phy80211
    then
      grep -qs up /sys/class/net/${dev}/operstate && break
    else
      grep -qs 1 /sys/class/net/${dev}/carrier && break
    fi
    let n+=200 && pause 0.2
  done
  [ $n -gt 0 ] && msg @. "  waited ${n}ms for ${dev} link"

  rmdir ${ifrc_Lfp}/$dev.lbto 2>/dev/null

  if $phy80211
  then
    grep -qs up /sys/class/net/${dev}/operstate \
    || { msg @. "  ...not associated, deferring"; ifrcmp_exit 0; }
  else
    grep -qs 1 /sys/class/net/${dev}/carrier \
    || { msg @. "  ...no cable/link, deferring"; ifrcmp_exit 0; }
  fi
}

## This sub-script handles configuration of an interface, when sourced via ifrc.
## And will exit with a non-zero value whenever a permanent condition prevents
## configuration of the interface, such as:
## 1. invalid method specified
## 2. no hw-phy detectable
## 3. timeout was used
## 4. other errors

ifrcmp_exit() {
  mp_x=$1; printf "${2:+${2}\n}" >&2
  rmdir ${ifrc_Lfp:+$ifrc_Lfp/$dev.cfg}
  return $1
}\
  2>/dev/null

{ read -r rc < /proc/$$/cmdline; mp_x=; } 2>/dev/null

test -z "${rc##ash*/ifrc*}" -a -h "/sys/class/net/$dev" \
  || ifrcmp_exit 2 "try: ifrc -h"

# Note that only the primary ip-address and its basic options are handled here.
# Additional configuration may be handled by any *cfg-do tasks or *.conf files.
#
method=${IFRC_METHOD}
while [ m/p -a ${#method} -gt 0 -a -z "$mp_x" ]
do unset ip nm nw wc bc ns gw to rip client scope metric weight
  # process each f/m/p
  method=${method# }
  fmp=${method%% f?=*}
  method=${method#$fmp}
  fm=${fmp%% *}
  case ${fm%%=*} in
    f6) ## family inet6
      test -z "$ipf" -o "${ipf/-/f}" == "${fm%=*}" \
        && msg1 "  +++ ${fm/=/_} method/params" \
        || continue

      test -d /proc/sys/net/ipv6 \
        || { modprobe ipv6 && msg "  IPv6 support enabled"; }

      case ${fm#*=} in
        auto) ## inet6 - StateLess Address AutoConfiguration
          ifrcmp_validate_f6auto
          # auto-configured on phy state change down->up and (re)enabled ipv6
          # scope link-local (using mac) address/mask is: fe80::/10
          echo 1 > /proc/sys/net/ipv6/conf/$dev/disable_ipv6
          echo 0 > /proc/sys/net/ipv6/conf/$dev/disable_ipv6
	  echo 1 > /proc/sys/net/ipv6/conf/$dev/accept_ra
	  ifrcmp_await_f6dad || exec $0 -6 $dev dn
	  /usr/sbin/dhclient6.sh start $dev
	  ;;

	dhcp) ## inet6 - Dynamic Host Configuration Protocol v6
	  echo 1 > /proc/sys/net/ipv6/conf/$dev/disable_ipv6
	  echo 0 > /proc/sys/net/ipv6/conf/$dev/disable_ipv6
	  echo 0 > /proc/sys/net/ipv6/conf/$dev/accept_ra
	  ifrcmp_await_f6dad || exec $0 -6 $dev dn
	  /usr/sbin/dhclient6.sh start $dev
	  ;;

	static) ## inet6 - Static method + optional params
	  ifrcmp_validate_f6static
	  echo 1 > /proc/sys/net/ipv6/conf/$dev/disable_ipv6
	  echo 0 > /proc/sys/net/ipv6/conf/$dev/disable_ipv6
	  echo 0 > /proc/sys/net/ipv6/conf/$dev/accept_ra
	  # ip-addr-modify IP/NM
	  xip=$( ip -6 -o addr show dev $dev scope global primary \
               |grep -om1 '[0-9a-f:]*/[0-9]*' )

	  test -n "$xip" \
            && fn ip -6 addr del $xip dev $dev
          : && fn ip -6 addr add $ip/$nm ${scope:+scope $scope} dev $dev

          # default route
          if [ -n "$gw" ]
          then
            fn ip -6 route repl default via $gw dev $dev
          fi
          ifrcmp_await_f6dad || exec $0 -6 $dev dn
          ;;

        loopback) ## inet6 method + optional params
          ifrcmp_validate_loopback
          # operstate can be down or unknown(up)
          # one address is reserved for the loopback
          # default reserved address is auto-configured
          : ${ip:=::1/128}
          xip=$( ip -6 -o addr show dev $dev primary \
                       |grep -om1 '[0-9a-f:]*/[0-9]*' )
          if [ "$xip" != "$ip/${nm:+/$nm}" ]
          then
            fn ip addr add $ip${nm:+/$nm} dev $dev
          fi
          ;;

        manual) ## inet6 method ...no params
          ifrcmp_validate_manual
          # do nothing, configuration is to be handled manually
          # the unspecified address is all zeros: '::/0'
          true
          ;;

        *) x=${fm#*=} # error
          msg "  ...unhandled inet6 configuration method: ${x:-?}"
          msg "  methods: manual, loopback, static, dhcp, auto"
          msg "  more info, try: ifrc -h"
          ifrcmp_exit 1 || break
          ;;
      esac
      ;;

    f4) ## family inet4
      test -z "$ipf" -o "${ipf/-/f}" == "${fm%=*}" \
        && msg1 "  +++ ${fm/=/_} method/params" \
        || continue

      if [ -z "$re" ]
      then
        # prepare for a new config
        test "${fm#*=}" != "dhcp" \
          && ifrc_dhcp_client stop \
          || fn ip -4 addr flush dev $dev
      fi
      case ${fm#*=} in
        auto) ## inet4 method for ad-hoc networks
          # maybe use avahi-autoipd to provide IPv4LL
          # scope link-local address/mask is: 169.254.0.0/16
          #fn ip route add 169.254.0.0/16 dev $dev metric 99
          #fn ip route add default dev $dev metric 99
          msg "IPv4LL config support n/a"
          ;;

        dhcp) ## inet4 method and optional params
          test -d ${ifrc_Lfp}/$dev.dhcp \
            && { msg1 "  client startup ...already in progress"; continue; }

          ifrcmp_validate_f4dhcp

          # (re)start client if necessary
          test "$client_s" != "stop" \
            && ifrc_dhcp_client renew && continue

          ifrcmp_check_if_link
          $conf_resolv -c &

          mkdir ${ifrc_Lfp}/$dev.dhcp 2>/dev/null \
             && { msg1 "  client ${re}start"; } \
             || { msg1 "  client startup ...already in progress"; continue; }

          ifrc_dhcp_client start \
            ns=$ns\ rip=$rip\ metric=$metric\ weight=$weight
            # starting dhcp client w/shared options/settings

          ifrcmp_await_f4dhcp
          ;;

        static) ## inet4 method + optional params
          ifrcmp_validate_f4static

          # ip-addr-modify IP/NM and BC
          xip=$( ip -4 -o addr show dev $dev scope global primary \
               |grep -om1 '[0-9]*\.[0-9]*\.[0-9]*\.[0-9/]*/[0-9]*' )

          test -n "$xip" \
            && fn ip addr add $ip/32 ${bc:+broadcast $bc} dev $dev \
            && fn ip addr del $xip dev $dev
          : && fn ip addr add $ip${nm:+/$nm} ${bc:+broadcast $bc} dev $dev
          test -n "$xip" \
            && fn ip addr del $ip/32 dev $dev

          # default route
          if [ -n "$gw" ]
          then
            { read -r ifindex < /sys/class/net/$dev/ifindex; } 2>/dev/null

            # preserve other-default-route/nexthops for multipath
            odr=$( ip route show scope global |grep -v $dev )

            # mpr/rt_tables
            if [ -n "$tn" ]
            then
              # determine a weight for this interface
              weight=weight\ ${weight:-${ifindex:-1}}
              nexthop=nexthop
            else
              weight=
              nexthop=
              odr=
            fi
            default=default
            metric=${metric:+metric\ $metric}

            for ra in $gw
            do
              fn ip route repl $default \
                $nexthop via $ra dev $dev $weight \
                  ${odr//default/$nexthop} ;

              # only the first router-addr can be default
              [ -n "$nexthop" ] || default=
            done

            # add rt_tables
            if [ -n "$tn" ]
            then
              # add network and gateway routes to table
              fn ip route repl $nw/$nm src $ip dev $dev $metric table $tn
              fn ip route repl default via $ra dev $dev $metric table $tn
              # rewrite policy rules in the lookup table
              while ip rule del table $tn 2>/dev/null; do :;done
              fn ip rule add from ${ip}/32 lookup $tn  ### outgoing ##
              fn ip rule add to ${ip}/32 lookup $tn  ### incoming ##
            fi
            fn ip route flush cache
          fi

          # update w/validated nameserver
          $conf_resolv -a $dev nameserver $ns &
          ;;

        loopback) ## inet4 method + optional params
          ifrcmp_validate_loopback
          # operstate can be down or unknown(up)
          # an entire network is reserved for loopback
          # an 'ip link set up' may auto-config the default
          : ${ip:=127.0.0.1/8}
          xip=$( ip -4 -o addr show dev $dev primary \
               |grep -om1 '[0-9]*\.[0-9]*\.[0-9]*\.[0-9/]*/[0-9]*' )
          if [ "$xip" != "$ip${nm:+/$nm}" ]
          then
            fn ip addr add $ip${nm:+/$nm} dev $dev
          fi
          ;;

        manual) ## inet4 method ...no params
         ifrcmp_validate_manual
          # do nothing, configuration is to be handled manually
          # the unspecified address is all zeros: '0.0.0.0/0'
          true
          ;;

        *) x=${fm#*=} # error
          msg "  ...unhandled inet4 configuration method: ${x:-?}"
          msg "  methods: manual, loopback, static, dhcp"
          msg "  more info, try: ifrc -h"
          ifrcmp_exit 1 || break
          ;;
      esac
      ;;

    f0) ## family link
      test -z "$ipf" -o "${ipf/-/f}" == "${fm%=*}" \
        && msg1 "  +++ ${fm/=/_} method/params" \
        || continue
      case ${fm#*=} in
        none) ## link method - handled in main
          ;;

        *) x=${fm#*=} # error
          msg "  ...unhandled link configuration method: ${x:-?}"
          msg "  methods: none"
          msg "  try: ifrc -h"
          ifrcmp_exit 1 || break
          ;;
      esac
      ;;

  esac
done
return ${mp_x:-0}
