From f35fa4748346d4bfb6ca65991914a8474978db26 Mon Sep 17 00:00:00 2001
From: Steve deRosier <Steve.Derosier@lairdtech.com>
Date: Wed, 24 Jun 2015 10:54:46 -0700
Subject: [PATCH] laird: ath6kl: Move reset GPIO into init

Originally in probe, the reset GPIO would only be grabbed if the chip were
already out of reset and communicating on the SDIO bus. If not the case, the
GPIO wouldn't be grabbed by the driver to pull the chip out of reset. This
moves it to init and exit so that we actually do this properly and the
driver can pull the chip out of reset.

Additionally ensures we do a reset on bring up, and also forces it back into
reset when we unload the driver.

Bug: 7799
---
 drivers/net/wireless/ath/ath6kl/sdio.c | 41 +++++++++++++++++++++++++++-------
 1 file changed, 33 insertions(+), 8 deletions(-)

diff --git a/drivers/net/wireless/ath/ath6kl/sdio.c b/drivers/net/wireless/ath/ath6kl/sdio.c
index bf17a49..bceaeca 100644
--- a/drivers/net/wireless/ath/ath6kl/sdio.c
+++ b/drivers/net/wireless/ath/ath6kl/sdio.c
@@ -1389,12 +1389,6 @@ static int ath6kl_sdio_probe(struct sdio_func *func,
 
 	ath6kl_sdio_set_mbox_info(ar);
 
-	if( ret = gpio_request_one(PWR_RESET_GPIO, GPIOF_OUT_INIT_HIGH|GPIOF_EXPORT_DIR_FIXED, "WIFI_RESET") ) {
-		ath6kl_err("Unable to get WIFI power gpio: %d\n", ret);
-	} else {
-		ath6kl_dbg(ATH6KL_DBG_SUSPEND, "Setup wifi gpio #%d\n", PWR_RESET_GPIO);
-	}
-
 	ret = ath6kl_sdio_config(ar);
 	if (ret) {
 		ath6kl_err("Failed to config sdio: %d\n", ret);
@@ -1437,7 +1431,6 @@ static void ath6kl_sdio_remove(struct sdio_func *func)
 
 	kfree(ar_sdio->dma_buffer);
 	kfree(ar_sdio);
-	gpio_free(PWR_RESET_GPIO);
 }
 
 static const struct sdio_device_id ath6kl_sdio_devices[] = {
@@ -1463,9 +1456,32 @@ static int __init ath6kl_sdio_init(void)
 {
 	int ret;
 
+	/* Request the reset GPIO, and assert it to make sure we get a 100% clean boot */
+	if(gpio_request_one(PWR_RESET_GPIO, GPIOF_OUT_INIT_LOW|GPIOF_EXPORT_DIR_FIXED, "WIFI_RESET") ) {
+		ath6kl_err("Unable to get WIFI power gpio: %d\n", ret);
+	} else {
+		ath6kl_dbg(ATH6KL_DBG_SUSPEND, "Setup wifi gpio #%d\n", PWR_RESET_GPIO);
+		udelay(10); /* Pin must be asserted at least 5 usec, this usually takes longer, but let's be sure */
+		gpio_set_value(PWR_RESET_GPIO, 1); /* De-assert the pin for normal operation */
+	}
+
+	/* Delay hack to avoid the mmc driver calling the probe on the prior notice of the chip,
+	 * which we just killed. If this is missing, it results in a spurious warning:
+	 * "ath6kl_sdio: probe of mmc0:0001:1 failed with error -110"
+	 */
+	mdelay(150);
+
 	ret = sdio_register_driver(&ath6kl_sdio_driver);
-	if (ret)
+	if (ret) {
 		ath6kl_err("sdio driver registration failed: %d\n", ret);
+		goto err_gpio;
+	}
+
+	return ret;
+
+err_gpio:
+	gpio_set_value(PWR_RESET_GPIO, 0);
+	gpio_free(PWR_RESET_GPIO); /* doesn't need a guard */
 
 	return ret;
 }
@@ -1473,6 +1489,15 @@ static int __init ath6kl_sdio_init(void)
 static void __exit ath6kl_sdio_exit(void)
 {
 	sdio_unregister_driver(&ath6kl_sdio_driver);
+
+	/* Delay hack to avoid pulling the plug on the chip when an irq is pending and then getting
+	 * a spurious message "ath6kl: failed to get pending recv messages: -125"
+	 */
+	mdelay(1000);
+
+	/* Be sure we leave the chip in reset when we unload and also release the GPIO */
+	gpio_set_value(PWR_RESET_GPIO, 0);
+	gpio_free(PWR_RESET_GPIO);
 }
 
 module_init(ath6kl_sdio_init);
-- 
1.9.1

