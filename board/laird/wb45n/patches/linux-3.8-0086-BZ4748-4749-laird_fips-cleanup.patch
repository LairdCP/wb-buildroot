From e83783faea40efe20ba1f082f9bb3cba88d5cc9b Mon Sep 17 00:00:00 2001
From: Doug Smith <Doug.Smith@lairdtech.com>
Date: Sat, 22 Nov 2014 10:34:17 -0500
Subject: [PATCH] BZ4748/4749: laird_fips cleanup

Cleanup of debug.
Remove unneeded include files.
Split <mod2urw.c>; functions used by <ath6kl_laird.ko>
moved to <mod2ufn.c>.

Bug: 4748
Bug: 4749
---
 drivers/net/wireless/laird_fips/Makefile   |   2 +-
 drivers/net/wireless/laird_fips/laird.c    |  77 +++++-----
 drivers/net/wireless/laird_fips/mod2ufn.c  | 180 ++++++++++++++++++++++
 drivers/net/wireless/laird_fips/mod2ufn.h  |  30 ++++
 drivers/net/wireless/laird_fips/mod2urw.c  | 238 +----------------------------
 drivers/net/wireless/laird_fips/moddebug.c |  19 +--
 drivers/net/wireless/laird_fips/moddebug.h |  16 +-
 7 files changed, 257 insertions(+), 305 deletions(-)
 create mode 100644 drivers/net/wireless/laird_fips/mod2ufn.c
 create mode 100644 drivers/net/wireless/laird_fips/mod2ufn.h

diff --git a/drivers/net/wireless/laird_fips/Makefile b/drivers/net/wireless/laird_fips/Makefile
index 870b99e..5b117ba 100644
--- a/drivers/net/wireless/laird_fips/Makefile
+++ b/drivers/net/wireless/laird_fips/Makefile
@@ -1,5 +1,5 @@
 obj-$(CONFIG_LAIRD_FIPS) += sdc2u.o
-sdc2u-y := mod2urw.o moddebug.o
+sdc2u-y := mod2urw.o mod2ufn.o moddebug.o
 
 obj-$(CONFIG_LAIRD_FIPS) += ath6kl_laird.o
 ath6kl_laird-y := laird.o laird_mod.o moddebug.o
diff --git a/drivers/net/wireless/laird_fips/laird.c b/drivers/net/wireless/laird_fips/laird.c
index 1e6c5ec..e1b391b 100644
--- a/drivers/net/wireless/laird_fips/laird.c
+++ b/drivers/net/wireless/laird_fips/laird.c
@@ -4,10 +4,11 @@
  */
 
 #include <linux/moduleparam.h>
-#include <linux/stat.h>
+#include <linux/interrupt.h>
 #include "laird_i.h"
 #include "moddebug.h"
 #include "touser.h"
+#include "mod2urw.h"
 
 #define ETHTYPE_IP     0x0800
 
@@ -38,15 +39,17 @@ FIPS_STAT_DEF(tx_encrypt_fail);
 FIPS_STAT_DEF(tx_encrypt_no_key);
 FIPS_STAT_DEF(tx_unspecified_error);
 
-#if 0
-#define DEBUG_IDX(p,res) \
-	printk(KERN_ALERT "%s: index %d, line %d, status=%d\n", \
-	       __FUNCTION__, laird_skb_idx((p)), __LINE__, res);
-#define DEBUG_DUMP(skb) \
-	_printkhexs(__FUNCTION__, "skb", skb->data, skb->len);
+#ifdef LAIRD_DEBUG
+static void debug_skb_trace(const char *fn, int line,
+							struct sk_buff *skb, int status);
+#define DEBUG_SKB_TRACE(skb,res) \
+	debug_skb_trace(__FUNCTION__, __LINE__, skb, res)
+static void debug_skb_dump(const char *fn, struct sk_buff *skb);
+#define DEBUG_SKB_DUMP(skb) \
+	debug_skb_dump(__FUNCTION__, skb);
 #else
-#define DEBUG_IDX(p,res)
-#define DEBUG_DUMP(skb)
+#define DEBUG_SKB_TRACE(skb,res)
+#define DEBUG_SKB_DUMP(skb)
 #endif
 
 typedef unsigned long long lrd_seq_t;
@@ -132,8 +135,6 @@ static void error_stat_tx(int res)
 	*perr += 1;
 }
 
-#include "mod2urw.h"
-
 static struct {
 	struct sk_buff_head skbq_tx;
 	struct sk_buff_head skbq_rx;
@@ -172,7 +173,6 @@ static laird_skb_priv_t *laird_skb_priv_set(struct sk_buff *skb,
 					    struct net_device *dev, int up)
 {
 	laird_skb_priv_t *pd = (void *)skb->cb;
-	DEBUG_TRACE;
 	pd->res = -1;
 	pd->done = 0;
 	pd->fn.pfn = pfn;
@@ -198,7 +198,6 @@ static inline int laird_skb_idx(struct sk_buff *skb)
 static inline int __crypqs_empty(void)
 {
 	int res = 1;
-	DEBUG_TRACE;
 	spin_lock_bh(&skbq_tx_lock);
 	if (!skb_queue_empty(&__glob.skbq_tx))
 		res = 0;
@@ -215,7 +214,6 @@ static inline int __crypqs_empty(void)
  */
 static int __cryp_wait_txrx_completed(void)
 {
-	DEBUG_TRACE;
 	mutex_lock(&mutex_stopping_txrx);
 	__glob.stopping_txrx = 1;
 	if (!__crypqs_empty()) {
@@ -235,7 +233,6 @@ static int __cryp_wait_txrx_completed(void)
 /* if we are stopping txrx and queues are empty signal */
 static void inline __cryp_signal_if_txrx_completed(void)
 {
-	DEBUG_TRACE;
 	if (!__glob.stopping_txrx)
 		return;
 	if (!__crypqs_empty())
@@ -246,7 +243,6 @@ static void inline __cryp_signal_if_txrx_completed(void)
 	}
 }
 
-#include "linux/interrupt.h"
 /* multiprocessor system can execute multiple tasklets simultaneously
  * so only use one tasklet for both rx/tx processing
  * tasklet for post-crypto operation processing
@@ -265,18 +261,17 @@ int laird_skb_rx_prep(struct sk_buff *skb, pfn_laird_skb_rx_continue pfn)
 	int res;
 	sdclkm_cb_t cbd;
 
-	DEBUG_TRACE;
 	if (__glob.stopping_txrx) {
 		return -1;
 	}
 	laird_skb_priv_set(skb, pfn, NULL, 0);
-	DEBUG_IDX(skb, 0);
-	DEBUG_DUMP(skb);
+	DEBUG_SKB_TRACE(skb, 0);
+	DEBUG_SKB_DUMP(skb);
 	cbd.pfn = __callback_rx;
 	cbd.pdata = skb;
 	res = sdclkm_skb_receive(&cbd, skb);
 	if (res != 0) {
-		DEBUG_IDX(skb, res);
+		DEBUG_SKB_TRACE(skb, res);
 		error_stat_rx(res);
 		return res;
 	}
@@ -296,8 +291,8 @@ static void __callback_rx(void *din, int res)
 {
 	struct sk_buff *skb = din;
 	laird_skb_priv_t *pd = laird_skb_priv_get(skb);
-	DEBUG_IDX(skb, res);
-	DEBUG_DUMP(skb);
+	DEBUG_SKB_TRACE(skb, res);
+	DEBUG_SKB_DUMP(skb);
 	pd->res = res;
 	pd->done = 1;
 	tasklet_schedule(&__tasklet);
@@ -372,12 +367,11 @@ int laird_skb_tx_prep(struct sk_buff *skbin, struct net_device *dev, int wmm,
 	}
 
 	pd = laird_skb_priv_set(skb, pfn, dev, laird_skb_up(skb, wmm));
-	DEBUG_IDX(skb, 0);
-	DEBUG_DUMP(skb);
+	DEBUG_SKB_TRACE(skb, 0);
+	DEBUG_SKB_DUMP(skb);
 	cbd.pfn = __callback_tx;
 	cbd.pdata = skb;
 	res = sdclkm_skb_transmit(&cbd, skb, &pd->up);
-	DEBUG_TRACE;
 	if (res != 0) {
 		goto fail;
 	}
@@ -390,7 +384,7 @@ int laird_skb_tx_prep(struct sk_buff *skbin, struct net_device *dev, int wmm,
 	res = 0; /* success */
 fail:
 	if (res) {
-		DEBUG_IDX(skb, res);
+		DEBUG_SKB_TRACE(skb, res);
 	}
 	if (skb != skbin) {
 		/* if we made a copy of the skb...
@@ -410,8 +404,8 @@ static void __callback_tx(void *din, int res)
 {
 	struct sk_buff *skb = din;
 	laird_skb_priv_t *pd = laird_skb_priv_get(skb);
-	DEBUG_IDX(skb, res);
-	DEBUG_DUMP(skb);
+	DEBUG_SKB_TRACE(skb, res);
+	DEBUG_SKB_DUMP(skb);
 	pd->res = res;
 	pd->done = 1;
 	tasklet_schedule(&__tasklet);
@@ -427,7 +421,6 @@ static void __tasklet_exec(unsigned long unused)
 	struct sk_buff *skb;
 	laird_skb_priv_t *pd;
 
-	DEBUG_TRACE;
 	spin_lock_bh(&skbq_tx_lock);
 	while (1) {
 		if (__glob.tx_stop_tasklet) {
@@ -441,7 +434,7 @@ static void __tasklet_exec(unsigned long unused)
 		if (!pd->done)
 			break;
 		(void)skb_dequeue(&__glob.skbq_tx);
-		DEBUG_IDX(skb, pd->res);
+		DEBUG_SKB_TRACE(skb, pd->res);
 		error_stat_tx(pd->res);
 		spin_unlock_bh(&skbq_tx_lock);
 		(*(pd->fn.txcontinue)) (skb, pd->dev, pd->res < 0 ? -1 : 1);
@@ -458,7 +451,7 @@ static void __tasklet_exec(unsigned long unused)
 		if (!pd->done)
 			break;
 		(void)skb_dequeue(&__glob.skbq_rx);
-		DEBUG_IDX(skb, pd->res);
+		DEBUG_SKB_TRACE(skb, pd->res);
 		error_stat_rx(pd->res);
 		spin_unlock_bh(&skbq_rx_lock);
 		(*(pd->fn.rxcontinue)) (skb, pd->res < 0 ? -1 : 1);
@@ -475,7 +468,6 @@ static void __tasklet_exec(unsigned long unused)
 static DEFINE_SPINLOCK(tx_stop_tasklet_lock);
 void laird_stop_queue(struct net_device *dev)
 {
-	DEBUG_TRACE;
 	spin_lock_bh(&tx_stop_tasklet_lock);
 	__glob.tx_stop_tasklet = 1;
 	spin_unlock_bh(&tx_stop_tasklet_lock);
@@ -485,14 +477,12 @@ void laird_stop_queue(struct net_device *dev)
 void laird_wake_queue(struct net_device *dev)
 {
 	int val;
-	DEBUG_TRACE;
 	spin_lock_bh(&tx_stop_tasklet_lock);
 	val = __glob.tx_stop_tasklet;
 	__glob.tx_stop_tasklet = 0;
 	spin_unlock_bh(&tx_stop_tasklet_lock);
 	if (val) {
 		/* transmit was unblocked */
-		DEBUG_TRACE;
 		tasklet_schedule(&__tasklet);
 	}
 }
@@ -500,7 +490,6 @@ void laird_wake_queue(struct net_device *dev)
 /* callback called at process level when crypto operation completes */
 static void __callback_del_data(void *din, int res)
 {
-	DEBUG_TRACE;
 	kfree(din);
 	(void)res;
 }
@@ -521,7 +510,6 @@ void laird_addkey(struct net_device *ndev,
 		u8 seq[8];
 	} *p;
 
-	DEBUG_TRACE;
 
 	if (key_index >= 4)
 		return;
@@ -555,7 +543,6 @@ void laird_addkey(struct net_device *ndev,
 
 void laird_delkey(struct net_device *ndev, u8 key_index)
 {
-	DEBUG_TRACE;
 	laird_addkey(ndev, key_index, 0, NULL, NULL, 0, NULL, 0);
 }
 
@@ -567,7 +554,6 @@ void laird_setbssid(const u8 * bssid)
 		u8 bssid[6];
 	} *p;
 
-	DEBUG_TRACE;
 	_printkhexs(__FUNCTION__, "bssid", bssid, bssid ? 6 : 0);
 
 	/* store data in allocated memory */
@@ -592,7 +578,6 @@ void laird_setbssid(const u8 * bssid)
 int laird_stop_txrx(void)
 {
 	int res;
-	DEBUG_TRACE;
 	res = __cryp_wait_txrx_completed();
 	return res;
 }
@@ -604,6 +589,20 @@ int laird_txrx_init(void)
 	return 0;
 }
 
+#ifdef LAIRD_DEBUG
+static void debug_skb_trace(const char *fn, int line,
+							struct sk_buff *skb, int status)
+{
+	printk(KERN_ALERT "%s: index %d, line %d, status=%d\n",
+		   fn, laird_skb_idx(skb), line, status);
+}
+
+static void debug_skb_dump(const char *fn, struct sk_buff *skb)
+{
+	_printkhexs(fn, "skb", skb->data, skb->len);
+}
+#endif
+
 const laird_register_data_t register_data = {
 	.pfn_rx_prep = &laird_skb_rx_prep,
 	.pfn_tx_prep = &laird_skb_tx_prep,
diff --git a/drivers/net/wireless/laird_fips/mod2ufn.c b/drivers/net/wireless/laird_fips/mod2ufn.c
new file mode 100644
index 0000000..d172b74
--- /dev/null
+++ b/drivers/net/wireless/laird_fips/mod2ufn.c
@@ -0,0 +1,180 @@
+/*
+ * Copyright (c) 2013 Laird, Inc.
+ * Licensed under GPLv2.
+ */
+#include <linux/module.h>
+#include "touser.h"
+#include "mod2urw.h"
+#include "mod2ufn.h"
+
+static const cmd_def_t def_ecb = {
+	SDCCMD_ECB_ENCRYPT, 2,
+	{
+	 ITEM_TO_HOST,			/* key */
+	 ITEM_TO_HOST | ITEM_FROM_HOST,	/* data */
+	 0}
+};
+
+int sdclkm_fnecbencrypt(sdclkm_cb_t * cbd,
+			fips_ccm_key_t * pkey, void *text, int len)
+{
+	item_ptr_t it[2];
+	it[0].p = pkey;
+	it[0].len = sizeof(*pkey);
+	it[1].p = text;
+	it[1].len = len;
+	return sdclkm_command(cbd, &def_ecb, it);
+}
+
+static const cmd_def_t def_ccmencrypt = {
+	SDCCMD_CCM_ENCRYPT, 5,
+	{
+	 ITEM_TO_HOST,			/* key */
+	 ITEM_TO_HOST,			/* n */
+	 ITEM_TO_HOST,			/* a */
+	 ITEM_TO_HOST | ITEM_FROM_HOST,	/* m */
+	 ITEM_FROM_HOST,		/* t */
+	 0}
+};
+
+int sdclkm_fnccmencrypt_ex(sdclkm_cb_t * cbd,
+			   fips_ccm_key_t * pkey,
+			   void *n, int ln,
+			   void *a, int la, void *m, int lm, void *t, int lt)
+{
+	item_ptr_t it[5];
+	it[0].p = pkey;
+	it[0].len = sizeof(*pkey);
+	it[1].p = n;
+	it[1].len = ln;
+	it[2].p = a;
+	it[2].len = la;
+	it[3].p = m;
+	it[3].len = lm;
+	it[4].p = t;
+	it[4].len = lt;
+	return sdclkm_command(cbd, &def_ccmencrypt, it);
+}
+
+static const cmd_def_t def_ccmdecrypt = {
+	SDCCMD_CCM_DECRYPT, 5,
+	{
+	 ITEM_TO_HOST,			/* key */
+	 ITEM_TO_HOST,			/* n */
+	 ITEM_TO_HOST,			/* a */
+	 ITEM_TO_HOST | ITEM_FROM_HOST,	/* m */
+	 ITEM_TO_HOST,			/* t */
+	 0}
+};
+
+int sdclkm_fnccmdecrypt_ex(sdclkm_cb_t * cbd,
+			   fips_ccm_key_t * pkey,
+			   void *n, int ln,
+			   void *a, int la, void *m, int lm, void *t, int lt)
+{
+	item_ptr_t it[5];
+	it[0].p = pkey;
+	it[0].len = sizeof(*pkey);
+	it[1].p = n;
+	it[1].len = ln;
+	it[2].p = a;
+	it[2].len = la;
+	it[3].p = m;
+	it[3].len = lm;
+	it[4].p = t;
+	it[4].len = lt;
+	return sdclkm_command(cbd, &def_ccmdecrypt, it);
+}
+
+EXPORT_SYMBOL(sdclkm_fnecbencrypt);
+EXPORT_SYMBOL(sdclkm_fnccmencrypt_ex);
+EXPORT_SYMBOL(sdclkm_fnccmdecrypt_ex);
+
+/*======================================================================*/
+#define DVR_HEADROOM 64
+static const cmd_def_t def_skb_receive = {
+	SDCCMD_DVR_RECEIVE, 2,
+	{
+	 0,			/* socket buffer wrapper (with head/tail) */
+	 ITEM_TO_HOST | ITEM_FROM_HOST | ITEM_SKB,	/* socket buffer data */
+	 0}
+};
+
+int sdclkm_skb_receive(sdclkm_cb_t * cbd, struct sk_buff *skb)
+{
+	item_ptr_t it[2];
+	int headroom;
+	headroom = (skb_headroom(skb) & 3) + DVR_HEADROOM;
+	it[0].p = skb->data - headroom;
+	it[0].len = 2048;
+	it[1].p = skb->data;
+	it[1].len = skb->len;
+	it[1].skb = skb;
+	return sdclkm_command(cbd, &def_skb_receive, it);
+}
+
+static const cmd_def_t def_skb_transmit = {
+	SDCCMD_DVR_TRANSMIT, 3,
+	{
+	 0,			/* socket buffer wrapper (with head/tail) */
+	 ITEM_TO_HOST | ITEM_FROM_HOST | ITEM_SKB,	/* socket buffer data */
+	 ITEM_TO_HOST,		/* up (user priority) */
+	 0}
+};
+
+int sdclkm_skb_transmit(sdclkm_cb_t * cbd, struct sk_buff *skb, int *up)
+{
+	item_ptr_t it[3];
+	int headroom;
+	headroom = (skb_headroom(skb) & 3) + DVR_HEADROOM;
+	it[0].p = skb->data - headroom;
+	it[0].len = 2048;
+	it[1].p = skb->data;
+	it[1].len = skb->len;
+	it[1].skb = skb;
+	it[2].p = up;
+	it[2].len = sizeof(*up);
+	return sdclkm_command(cbd, &def_skb_transmit, it);
+}
+
+static const cmd_def_t def_addkey = {
+	SDCCMD_DVR_ADDKEY, 3,
+	{
+	 ITEM_TO_HOST,		/* key_index, pairwise */
+	 ITEM_TO_HOST,		/* key */
+	 ITEM_TO_HOST,		/* seq */
+	 0}
+};
+
+int sdclkm_addkey(sdclkm_cb_t * cbd,
+		  u32 * key_index, u8 * key, int keylen, u8 * seq, int seqlen)
+{
+	item_ptr_t it[3];
+	it[0].p = key_index;
+	it[0].len = sizeof(*key_index);
+	it[1].p = key;
+	it[1].len = keylen;
+	it[2].p = seq;
+	it[2].len = seqlen;
+	return sdclkm_command(cbd, &def_addkey, it);
+}
+
+static const cmd_def_t def_setbssid = {
+	SDCCMD_DVR_SETBSSID, 1,
+	{
+	 ITEM_TO_HOST,		/* bssid */
+	 0}
+};
+
+int sdclkm_setbssid(sdclkm_cb_t * cbd, u8 * bssid, int bssidlen)
+{
+	item_ptr_t it[1];
+	it[0].p = bssid;
+	it[0].len = bssidlen;
+	return sdclkm_command(cbd, &def_setbssid, it);
+}
+
+EXPORT_SYMBOL(sdclkm_skb_receive);
+EXPORT_SYMBOL(sdclkm_skb_transmit);
+EXPORT_SYMBOL(sdclkm_addkey);
+EXPORT_SYMBOL(sdclkm_setbssid);
diff --git a/drivers/net/wireless/laird_fips/mod2ufn.h b/drivers/net/wireless/laird_fips/mod2ufn.h
new file mode 100644
index 0000000..1893b86
--- /dev/null
+++ b/drivers/net/wireless/laird_fips/mod2ufn.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2013 Laird, Inc.
+ * Licensed under GPLv2.
+ */
+
+#ifndef _MOD2UFN_H_
+#define _MOD2UFN_H_
+
+/* defines the cmd -- number of parameters and handling for each
+ * this will be constant for a given command
+ */
+typedef struct {		/* command control handling */
+	int cmd;
+	int numit;
+	int flags[MAXIT];
+#define ITEM_TO_HOST 1
+#define ITEM_FROM_HOST 2
+#define ITEM_SKB 4
+} cmd_def_t;
+
+typedef struct {
+	void *p;		/* pointer to item */
+	int len;		/* length of item */
+	void *skb;		/* for socket buffers passed to/from user space */
+} item_ptr_t;
+
+extern int sdclkm_command(sdclkm_cb_t * cbd,
+						  const cmd_def_t * def, item_ptr_t * itp);
+
+#endif
diff --git a/drivers/net/wireless/laird_fips/mod2urw.c b/drivers/net/wireless/laird_fips/mod2urw.c
index 5f75512..823f95f 100644
--- a/drivers/net/wireless/laird_fips/mod2urw.c
+++ b/drivers/net/wireless/laird_fips/mod2urw.c
@@ -6,24 +6,13 @@
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
-
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/fs.h>
-#include <linux/errno.h>	/* error codes */
-#include <linux/types.h>	/* size_t */
-#include <linux/proc_fs.h>
-#include <linux/fcntl.h>	/* O_ACCMODE */
-#include <linux/seq_file.h>
 #include <linux/cdev.h>
-#include <linux/sched.h>
-#include <linux/spinlock.h>
-
-#include <asm/system.h>		/* cli(), *_flags */
-#include <asm/uaccess.h>	/* copy_*_user */
 
 #include "laird_i.h"
 #include "moddebug.h"
+#include "touser.h"
+#include "mod2urw.h"
+#include "mod2ufn.h"
 
 static int cmd_to_host(char __user * buf, size_t count);
 static int cmd_from_host(const char __user * buf, size_t count);
@@ -48,7 +37,6 @@ static unsigned short mod2urw_read_ready;
 
 static void __mod2urw_read_wake(void)
 {
-	DEBUG_TRACE;
 	mod2urw_read_ready = 1;
 	wake_up_interruptible(&wq_read);	/* update poll status */
 }
@@ -58,7 +46,6 @@ static ssize_t mod2urw_read(struct file *filp, char __user * buf, size_t count,
 {
 	int res;
 	/* TBD: device mutex ? */
-	DEBUG_TRACE;
 	while (1) {
 		mod2urw_read_ready = 0;
 		res = cmd_to_host(buf, count);
@@ -75,7 +62,6 @@ static ssize_t mod2urw_read(struct file *filp, char __user * buf, size_t count,
 static ssize_t mod2urw_write(struct file *filp, const char __user * buf,
 			size_t count, loff_t * f_pos)
 {
-	DEBUG_TRACE;
 	cmd_from_host(buf, count);
 	return count;
 }
@@ -107,7 +93,6 @@ void mod2urw_cleanup_module(void)
 	int i;
 	dev_t devno = MKDEV(mod2urw_major, mod2urw_minor);
 
-	DEBUG_TRACE;
 	/* Get rid of our char dev entries */
 	if (mod2urw_devices) {
 		for (i = 0; i < mod2urw_nr_devs; i++) {
@@ -127,7 +112,6 @@ static void mod2urw_setup_cdev(struct mod2urw_dev *dev, int index)
 {
 	int err, devno = MKDEV(mod2urw_major, mod2urw_minor + index);
 
-	DEBUG_TRACE;
 	cdev_init(&dev->cdev, &mod2urw_fops);
 	dev->cdev.owner = THIS_MODULE;
 	dev->cdev.ops = &mod2urw_fops;
@@ -141,7 +125,6 @@ static int mod2urw_init_module(void)
 {
 	int result, i;
 	dev_t dev = 0;
-	DEBUG_TRACE;
 
 	/*
 	 * Get a range of minor numbers to work with, asking for a dynamic
@@ -184,15 +167,11 @@ fail:
 }
 
 /* driver register data -- pointer to functions */
-#include "touser.h"
-#include "mod2urw.h"
-
 #define VERSION_STRING "1.0"
 
 /* initialization */
 static int __init sdclkm_init(void)
 {
-	DEBUG_TRACE;
 	printk(KERN_INFO "%s.ko: version %s\n", MYDEVSTR, VERSION_STRING);
 	if (mod2urw_init_module() < 0)
 		goto failure;
@@ -204,7 +183,6 @@ failure:
 /* cleanup and exit */
 static void __exit sdclkm_exit(void)
 {
-	DEBUG_TRACE;
 	mod2urw_cleanup_module();
 }
 
@@ -219,24 +197,6 @@ MODULE_VERSION(VERSION_STRING);
 /*======================================================================*/
 /*======================================================================*/
 
-/* defines the cmd -- number of parameters and handling for each
- * this will be constant for a given command
- */
-typedef struct {		/* command control handling */
-	int cmd;
-	int numit;
-	int flags[MAXIT];
-#define ITEM_TO_HOST 1
-#define ITEM_FROM_HOST 2
-#define ITEM_SKB 4
-} cmd_def_t;
-
-typedef struct {
-	void *p;		/* pointer to item */
-	int len;		/* length of item */
-	void *skb;		/* for socket buffers passed to/from user space */
-} item_ptr_t;
-
 /* command control */
 typedef struct cmd_ctl_s {
 	cmd_hdr_t hdr;		/* command header to pass to user space */
@@ -275,7 +235,6 @@ static inline void cmd_ctl_free(cmd_ctl_t * ctl)
  */
 static int cmd_ctl_submit(cmd_ctl_t * ctl)
 {
-	DEBUG_TRACE;
 	ctl->next = NULL;
 	spin_lock_bh(&cmdq_lock);
 	if (!cmd_glob.enabled) {
@@ -299,7 +258,6 @@ static int cmd_ctl_submit(cmd_ctl_t * ctl)
 static cmd_ctl_t *cmd_ctl_get_next(void)
 {
 	cmd_ctl_t *ctl;
-	DEBUG_TRACE;
 	spin_lock_bh(&cmdq_lock);
 	ctl = cmd_glob.first;
 	if (ctl) {
@@ -316,14 +274,12 @@ static cmd_ctl_t *cmd_ctl_get_next(void)
 /* called only at process level in write */
 static cmd_ctl_t *cmd_ctl_get_active(void)
 {
-	DEBUG_TRACE;
 	/* don't need spinlock here */
 	return cmd_glob.active;
 }
 
 static void cmd_ctl_free_active(void)
 {
-	DEBUG_TRACE;
 	if (cmd_glob.active) {
 		cmd_ctl_free(cmd_glob.active);
 		cmd_glob.active = NULL;
@@ -341,7 +297,6 @@ static int cmd_to_host(char __user * buf, size_t count)
 	int i;
 	int err = 0;
 
-	DEBUG_TRACE;
 	ctl = cmd_ctl_get_next();
 	if (!ctl) {
 		return 0;	/* no command to pass to user space */
@@ -380,7 +335,6 @@ static inline int __skb_from_user(struct sk_buff *skb,
 	headchg = oldoff - newoff;
 	tailchg = newlen - skb->len - headchg;
 
-	DEBUG_TRACE;
 	headroom = skb_headroom(skb);
 	tailroom = skb_tailroom(skb);
 	if (headroom < headchg) {
@@ -417,7 +371,6 @@ static int cmd_from_host(const char __user * buf, size_t count)
 	int res;
 	int err = 0;
 
-	DEBUG_TRACE;
 	ctl = cmd_ctl_get_active();
 	if (!ctl) {
 		printk(KERN_ALERT "%s: ERROR!! unsolicited cmd\n",
@@ -472,7 +425,6 @@ static int cmd_from_host(const char __user * buf, size_t count)
 static void cmd_fail_all(void)
 {
 	cmd_ctl_t *ctl;
-	DEBUG_TRACE;
 	do {
 		ctl = cmd_ctl_get_active();
 		if (!ctl)
@@ -491,7 +443,6 @@ static void cmd_fail_all(void)
 /* set enabled when user-space processing is available */
 static void cmd_set_state(int enabled)
 {
-	DEBUG_TRACE;
 	spin_lock_bh(&cmdq_lock);
 	cmd_glob.enabled = enabled;
 	spin_unlock_bh(&cmdq_lock);
@@ -512,7 +463,6 @@ typedef struct {
 static void callback_wait(void *din, int res)
 {
 	defcb_data *data = (defcb_data *) din;
-	DEBUG_TRACE;
 	/* save result */
 	data->res = res;
 	/* signal the waiting thread */
@@ -527,7 +477,6 @@ static int cmd_ctl_submit_and_wait(cmd_ctl_t * ctl)
 	defcb_data *data;
 	int res;
 
-	DEBUG_TRACE;
 	data = kmalloc(sizeof(*data), GFP_ATOMIC);
 	if (!data) {
 		printk(KERN_ALERT "%s: alloc failed\n", __FUNCTION__);
@@ -571,7 +520,7 @@ static int cmd_ctl_submit_and_wait(cmd_ctl_t * ctl)
  * input: itp - data items (pointer, length)
  * output: command is enqueued for transfer to user space
  */
-static int sdclkm_command(sdclkm_cb_t * cbd,
+int sdclkm_command(sdclkm_cb_t * cbd,
 			  const cmd_def_t * def, item_ptr_t * itp)
 {
 	cmd_ctl_t *ctl;		/* command control */
@@ -579,7 +528,6 @@ static int sdclkm_command(sdclkm_cb_t * cbd,
 	int i;
 	int offset;
 
-	DEBUG_TRACE;
 
 	ctl = cmd_ctl_alloc();
 	if (!ctl) {
@@ -622,181 +570,3 @@ static int sdclkm_command(sdclkm_cb_t * cbd,
 	return cmd_ctl_submit_and_wait(ctl);
 }
 
-static const cmd_def_t def_ecb = {
-	SDCCMD_ECB_ENCRYPT, 2,
-	{
-	 ITEM_TO_HOST,			/* key */
-	 ITEM_TO_HOST | ITEM_FROM_HOST,	/* data */
-	 0}
-};
-
-int sdclkm_fnecbencrypt(sdclkm_cb_t * cbd,
-			fips_ccm_key_t * pkey, void *text, int len)
-{
-	item_ptr_t it[2];
-	DEBUG_TRACE;
-	it[0].p = pkey;
-	it[0].len = sizeof(*pkey);
-	it[1].p = text;
-	it[1].len = len;
-	return sdclkm_command(cbd, &def_ecb, it);
-}
-
-static const cmd_def_t def_ccmencrypt = {
-	SDCCMD_CCM_ENCRYPT, 5,
-	{
-	 ITEM_TO_HOST,			/* key */
-	 ITEM_TO_HOST,			/* n */
-	 ITEM_TO_HOST,			/* a */
-	 ITEM_TO_HOST | ITEM_FROM_HOST,	/* m */
-	 ITEM_FROM_HOST,		/* t */
-	 0}
-};
-
-int sdclkm_fnccmencrypt_ex(sdclkm_cb_t * cbd,
-			   fips_ccm_key_t * pkey,
-			   void *n, int ln,
-			   void *a, int la, void *m, int lm, void *t, int lt)
-{
-	item_ptr_t it[5];
-	DEBUG_TRACE;
-	it[0].p = pkey;
-	it[0].len = sizeof(*pkey);
-	it[1].p = n;
-	it[1].len = ln;
-	it[2].p = a;
-	it[2].len = la;
-	it[3].p = m;
-	it[3].len = lm;
-	it[4].p = t;
-	it[4].len = lt;
-	return sdclkm_command(cbd, &def_ccmencrypt, it);
-}
-
-static const cmd_def_t def_ccmdecrypt = {
-	SDCCMD_CCM_DECRYPT, 5,
-	{
-	 ITEM_TO_HOST,			/* key */
-	 ITEM_TO_HOST,			/* n */
-	 ITEM_TO_HOST,			/* a */
-	 ITEM_TO_HOST | ITEM_FROM_HOST,	/* m */
-	 ITEM_TO_HOST,			/* t */
-	 0}
-};
-
-int sdclkm_fnccmdecrypt_ex(sdclkm_cb_t * cbd,
-			   fips_ccm_key_t * pkey,
-			   void *n, int ln,
-			   void *a, int la, void *m, int lm, void *t, int lt)
-{
-	item_ptr_t it[5];
-	DEBUG_TRACE;
-	it[0].p = pkey;
-	it[0].len = sizeof(*pkey);
-	it[1].p = n;
-	it[1].len = ln;
-	it[2].p = a;
-	it[2].len = la;
-	it[3].p = m;
-	it[3].len = lm;
-	it[4].p = t;
-	it[4].len = lt;
-	return sdclkm_command(cbd, &def_ccmdecrypt, it);
-}
-
-EXPORT_SYMBOL(sdclkm_fnecbencrypt);
-EXPORT_SYMBOL(sdclkm_fnccmencrypt_ex);
-EXPORT_SYMBOL(sdclkm_fnccmdecrypt_ex);
-
-/*======================================================================*/
-#define DVR_HEADROOM 64
-static const cmd_def_t def_skb_receive = {
-	SDCCMD_DVR_RECEIVE, 2,
-	{
-	 0,			/* socket buffer wrapper (with head/tail) */
-	 ITEM_TO_HOST | ITEM_FROM_HOST | ITEM_SKB,	/* socket buffer data */
-	 0}
-};
-
-int sdclkm_skb_receive(sdclkm_cb_t * cbd, struct sk_buff *skb)
-{
-	item_ptr_t it[2];
-	int headroom;
-	DEBUG_TRACE;
-	headroom = (skb_headroom(skb) & 3) + DVR_HEADROOM;
-	it[0].p = skb->data - headroom;
-	it[0].len = 2048;
-	it[1].p = skb->data;
-	it[1].len = skb->len;
-	it[1].skb = skb;
-	return sdclkm_command(cbd, &def_skb_receive, it);
-}
-
-static const cmd_def_t def_skb_transmit = {
-	SDCCMD_DVR_TRANSMIT, 3,
-	{
-	 0,			/* socket buffer wrapper (with head/tail) */
-	 ITEM_TO_HOST | ITEM_FROM_HOST | ITEM_SKB,	/* socket buffer data */
-	 ITEM_TO_HOST,		/* up (user priority) */
-	 0}
-};
-
-int sdclkm_skb_transmit(sdclkm_cb_t * cbd, struct sk_buff *skb, int *up)
-{
-	item_ptr_t it[3];
-	int headroom;
-	DEBUG_TRACE;
-	headroom = (skb_headroom(skb) & 3) + DVR_HEADROOM;
-	it[0].p = skb->data - headroom;
-	it[0].len = 2048;
-	it[1].p = skb->data;
-	it[1].len = skb->len;
-	it[1].skb = skb;
-	it[2].p = up;
-	it[2].len = sizeof(*up);
-	return sdclkm_command(cbd, &def_skb_transmit, it);
-}
-
-static const cmd_def_t def_addkey = {
-	SDCCMD_DVR_ADDKEY, 3,
-	{
-	 ITEM_TO_HOST,		/* key_index, pairwise */
-	 ITEM_TO_HOST,		/* key */
-	 ITEM_TO_HOST,		/* seq */
-	 0}
-};
-
-int sdclkm_addkey(sdclkm_cb_t * cbd,
-		  u32 * key_index, u8 * key, int keylen, u8 * seq, int seqlen)
-{
-	item_ptr_t it[3];
-	DEBUG_TRACE;
-	it[0].p = key_index;
-	it[0].len = sizeof(*key_index);
-	it[1].p = key;
-	it[1].len = keylen;
-	it[2].p = seq;
-	it[2].len = seqlen;
-	return sdclkm_command(cbd, &def_addkey, it);
-}
-
-static const cmd_def_t def_setbssid = {
-	SDCCMD_DVR_SETBSSID, 1,
-	{
-	 ITEM_TO_HOST,		/* bssid */
-	 0}
-};
-
-int sdclkm_setbssid(sdclkm_cb_t * cbd, u8 * bssid, int bssidlen)
-{
-	item_ptr_t it[1];
-	DEBUG_TRACE;
-	it[0].p = bssid;
-	it[0].len = bssidlen;
-	return sdclkm_command(cbd, &def_setbssid, it);
-}
-
-EXPORT_SYMBOL(sdclkm_skb_receive);
-EXPORT_SYMBOL(sdclkm_skb_transmit);
-EXPORT_SYMBOL(sdclkm_addkey);
-EXPORT_SYMBOL(sdclkm_setbssid);
diff --git a/drivers/net/wireless/laird_fips/moddebug.c b/drivers/net/wireless/laird_fips/moddebug.c
index 9957aef..ddb77f4 100644
--- a/drivers/net/wireless/laird_fips/moddebug.c
+++ b/drivers/net/wireless/laird_fips/moddebug.c
@@ -3,27 +3,10 @@
  * Licensed under GPLv2.
  */
 
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-
 #include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/fs.h>
-#include <linux/errno.h>	/* error codes */
-#include <linux/types.h>	/* size_t */
-#include <linux/proc_fs.h>
-#include <linux/fcntl.h>	/* O_ACCMODE */
-#include <linux/seq_file.h>
-#include <linux/cdev.h>
-#include <linux/sched.h>
-#include <linux/spinlock.h>
-
-#include <asm/uaccess.h>	/* copy_*_user */
-
 #include "moddebug.h"
 
-#ifndef _printkhexs
+#ifdef LAIRD_DEBUG
 static char _dnib2hex(int x)
 {
 	if (x < 10)
diff --git a/drivers/net/wireless/laird_fips/moddebug.h b/drivers/net/wireless/laird_fips/moddebug.h
index 0bdafea..9adc153 100644
--- a/drivers/net/wireless/laird_fips/moddebug.h
+++ b/drivers/net/wireless/laird_fips/moddebug.h
@@ -6,21 +6,11 @@
 #ifndef _MODDEBUG_H_
 #define _MODDEBUG_H_
 
-#define DEBUG_TRACE0
-#define DEBUG_TRACE1 \
-	printk(KERN_ALERT "%s: line %d\n", __FUNCTION__, __LINE__);
-
-/* debug output disabled */
-#define _printkhexs(psz,pfx,buf,len)
-#define DEBUG_TRACE DEBUG_TRACE0
-
-#ifndef _printkhexs
+#ifdef LAIRD_DEBUG
 extern void _printkhexs(const char *psz, const char *pfx,
 			const void *buf, int len);
-#endif
-
-#ifndef DEBUG_TRACE
-#define DEBUG_TRACE DEBUG_TRACE1
+#else
+#define _printkhexs(psz,pfx,buf,len)
 #endif
 
 #endif
-- 
1.8.3.2

