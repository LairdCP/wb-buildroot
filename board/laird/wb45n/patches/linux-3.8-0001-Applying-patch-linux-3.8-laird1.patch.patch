From bae76797f44c8a7af07b00c39b151abea9450b9c Mon Sep 17 00:00:00 2001
From: Dimitrios Siganos <dimitris@siganos.org>
Date: Tue, 2 Jul 2013 14:35:38 -0400
Subject: [PATCH] Applying patch linux-3.8-laird1.patch

---
 .../devicetree/bindings/usb/atmel-usb.txt          |   85 +++
 Makefile                                           |    2 +-
 arch/arm/boot/dts/at91sam9x5.dtsi                  |   64 ++
 arch/arm/boot/dts/at91sam9x5cm.dtsi                |   65 +-
 arch/arm/boot/dts/at91sam9x5ek.dtsi                |   27 +-
 arch/arm/configs/wb45n_defconfig                   |  273 ++++++++
 arch/arm/mach-at91/at91sam9x5.c                    |    2 +
 arch/arm/mach-at91/board-dt.c                      |    2 +-
 drivers/mmc/host/atmel-mci.c                       |    7 +
 drivers/mtd/nand/atmel_nand.c                      |    6 +-
 drivers/net/wireless/ath/ath6kl/init.c             |    2 +-
 drivers/usb/gadget/Kconfig                         |    2 +-
 drivers/usb/gadget/atmel_usba_udc.c                |  211 +++++--
 drivers/usb/gadget/atmel_usba_udc.h                |    1 +
 include/uapi/linux/netfilter_bridge/ebt_nat.h      |    1 +
 net/bridge/br_fdb.c                                |    1 +
 net/bridge/netfilter/Kconfig                       |   10 +
 net/bridge/netfilter/Makefile                      |    1 +
 net/bridge/netfilter/ebt_arpnat.c                  |  650 ++++++++++++++++++++
 net/wireless/core.c                                |    3 +-
 net/wireless/nl80211.c                             |    2 -
 net/wireless/util.c                                |    6 +-
 22 files changed, 1335 insertions(+), 88 deletions(-)
 create mode 100644 arch/arm/configs/wb45n_defconfig
 create mode 100644 net/bridge/netfilter/ebt_arpnat.c

diff --git a/Documentation/devicetree/bindings/usb/atmel-usb.txt b/Documentation/devicetree/bindings/usb/atmel-usb.txt
index 60bd215..24bfbff 100644
--- a/Documentation/devicetree/bindings/usb/atmel-usb.txt
+++ b/Documentation/devicetree/bindings/usb/atmel-usb.txt
@@ -47,3 +47,88 @@ usb1: gadget@fffa4000 {
 	interrupts = <10 4>;
 	atmel,vbus-gpio = <&pioC 5 0>;
 };
+
+Atmel High-Speed USB device controller
+
+Required properties:
+ - compatible: Should be "atmel,at91sam9rl-udc"
+ - reg: Address and length of the register set for the device
+ - interrupts: Should contain macb interrupt
+ - ep childnode: To specifiy the number of endpoints and their properties.
+
+Optional properties:
+ - atmel,vbus-gpio: If present, specifies a gpio that needs to be
+   activated for the bus to be powered.
+
+Required child node properties:
+ - name: Name of the endpoint.
+ - reg: Num of the endpoint.
+ - atmel,fifo-size: Size of the fifo.
+ - atmel,nb-banks: Number of banks.
+ - atmel,can-dma: Boolean to specify if the endpoint support DMA.
+ - atmel,can-isoc: Boolean to specify if the endpoint support ISOC.
+
+usb2: gadget at fff78000 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	compatible = "atmel,at91sam9rl-udc";
+	reg = <0x00600000 0x80000
+	       0xfff78000 0x400>;
+	interrupts = <27 4>;
+	atmel,vbus-gpio = <&pioB 19 0>;
+
+	ep0 {
+		reg = <0>;
+		atmel,fifo-size = <64>;
+		atmel,nb-banks = <1>;
+	};
+
+	ep1 {
+		reg = <1>;
+		atmel,fifo-size = <1024>;
+		atmel,nb-banks = <2>;
+		atmel,can-dma;
+		atmel,can-isoc;
+	};
+
+	ep2 {
+		reg = <2>;
+		atmel,fifo-size = <1024>;
+		atmel,nb-banks = <2>;
+		atmel,can-dma;
+		atmel,can-isoc;
+	};
+
+	ep3 {
+		reg = <3>;
+		atmel,fifo-size = <1024>;
+		atmel,nb-banks = <3>;
+		atmel,can-dma;
+	};
+
+	ep4 {
+		reg = <4>;
+		atmel,fifo-size = <1024>;
+		atmel,nb-banks = <3>;
+		atmel,can-dma;
+	};
+
+	ep5 {
+		reg = <5>;
+		atmel,fifo-size = <1024>;
+		atmel,nb-banks = <3>;
+		atmel,can-dma;
+		atmel,can-isoc;
+	};
+
+	ep6 {
+		reg = <6>;
+		atmel,fifo-size = <1024>;
+		atmel,nb-banks = <3>;
+		atmel,can-dma;
+		atmel,can-isoc;
+	};
+
+	... ...
+
+};
diff --git a/Makefile b/Makefile
index d69266c..c204b89 100644
--- a/Makefile
+++ b/Makefile
@@ -1,7 +1,7 @@
 VERSION = 3
 PATCHLEVEL = 8
 SUBLEVEL = 0
-EXTRAVERSION =
+EXTRAVERSION = -laird1
 NAME = Unicycling Gorilla
 
 # *DOCUMENTATION*
diff --git a/arch/arm/boot/dts/at91sam9x5.dtsi b/arch/arm/boot/dts/at91sam9x5.dtsi
index 8ecca69..af0419d 100644
--- a/arch/arm/boot/dts/at91sam9x5.dtsi
+++ b/arch/arm/boot/dts/at91sam9x5.dtsi
@@ -518,6 +518,9 @@
 			#address-cells = <1>;
 			#size-cells = <1>;
 			reg = <0x40000000 0x10000000
+				0xffffe000 0x600
+				0xffffe600 0x200
+				0x00100000 0x100000
 			      >;
 			atmel,nand-addr-offset = <21>;
 			atmel,nand-cmd-offset = <22>;
@@ -543,6 +546,67 @@
 			interrupts = <22 4 2>;
 			status = "disabled";
 		};
+
+		usb2: gadget@f803c000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "atmel,at91sam9rl-udc";
+			reg = <0x00500000 0x100000
+			       0xf803c000 0x4000>;
+			interrupts = <23 4 2>;
+
+			ep0 {
+				reg = <0>;
+				atmel,fifo-size = <64>;
+				atmel,nb-banks = <1>;
+			};
+
+			ep1 {
+				reg = <1>;
+				atmel,fifo-size = <1024>;
+				atmel,nb-banks = <2>;
+				atmel,can-dma;
+				atmel,can-isoc;
+			};
+
+			ep2 {
+				reg = <2>;
+				atmel,fifo-size = <1024>;
+				atmel,nb-banks = <2>;
+				atmel,can-dma;
+				atmel,can-isoc;
+			};
+
+			ep3 {
+				reg = <3>;
+				atmel,fifo-size = <1024>;
+				atmel,nb-banks = <3>;
+				atmel,can-dma;
+			};
+
+			ep4 {
+				reg = <4>;
+				atmel,fifo-size = <1024>;
+				atmel,nb-banks = <3>;
+				atmel,can-dma;
+			};
+
+			ep5 {
+				reg = <5>;
+				atmel,fifo-size = <1024>;
+				atmel,nb-banks = <3>;
+				atmel,can-dma;
+				atmel,can-isoc;
+			};
+
+			ep6 {
+				reg = <6>;
+				atmel,fifo-size = <1024>;
+				atmel,nb-banks = <3>;
+				atmel,can-dma;
+				atmel,can-isoc;
+			};
+		};
 	};
 
 	i2c@0 {
diff --git a/arch/arm/boot/dts/at91sam9x5cm.dtsi b/arch/arm/boot/dts/at91sam9x5cm.dtsi
index 31e7be2..623d19c 100644
--- a/arch/arm/boot/dts/at91sam9x5cm.dtsi
+++ b/arch/arm/boot/dts/at91sam9x5cm.dtsi
@@ -26,33 +26,62 @@
 	ahb {
 		nand0: nand@40000000 {
 			nand-bus-width = <8>;
-			nand-ecc-mode = "soft";
+			nand-ecc-mode = "hw";
+			atmel,has-pmecc;	/* enable PMECC */
+			atmel,pmecc-cap = <4>;
+			atmel,pmecc-sector-size = <512>;
+			atmel,pmecc-lookup-table-offset = <0x8000 0x10000>;
 			nand-on-flash-bbt;
 			status = "okay";
 
 			at91bootstrap@0 {
 				label = "at91bootstrap";
-				reg = <0x0 0x40000>;
+				reg = <0x0 0x20000>;
 			};
 
-			uboot@40000 {
+			uboot@20000 {
 				label = "u-boot";
-				reg = <0x40000 0x80000>;
+				reg = <0x20000 0x80000>;
 			};
 
-			ubootenv@c0000 {
+			ubootenv@a0000 {
 				label = "U-Boot Env";
-				reg = <0xc0000 0x140000>;
+				reg = <0xa0000 0x20000>;
+			};
+
+			ubootenv@c0000 {
+				label = "U-Boot Redund Env";
+				reg = <0xc0000 0x20000>;
+			};
+
+			kernel-a@e0000 {
+				label = "kernel-a";
+				reg = <0xe0000 0x280000>;
+			};
+
+			kernel-b@360000 {
+				label = "kernel-b";
+				reg = <0x360000 0x280000>;
+			};
+
+			rootfs-a@5e0000 {
+				label = "rootfs-a";
+				reg = <0x5e0000 0x2600000>;
+			};
+
+			rootfs-b@2be0000 {
+				label = "rootfs-b";
+				reg = <0x2be0000 0x2600000>;
 			};
 
-			kernel@200000 {
-				label = "kernel";
-				reg = <0x200000 0x600000>;
+			user@51e0000 {
+				label = "user";
+				reg = <0x51e0000 0x2dc0000>;
 			};
 
-			rootfs@800000 {
-				label = "rootfs";
-				reg = <0x800000 0x1f800000>;
+			logs@7fa0000 {
+				label = "logs";
+				reg = <0x7fa0000 0x60000>;
 			};
 		};
 	};
@@ -60,15 +89,15 @@
 	leds {
 		compatible = "gpio-leds";
 
-		pb18 {
-			label = "pb18";
-			gpios = <&pioB 18 1>;
+		pc8 {
+			label = "pc8";
+			gpios = <&pioC 8 1>;
 			linux,default-trigger = "heartbeat";
 		};
 
-		pd21 {
-			label = "pd21";
-			gpios = <&pioD 21 0>;
+		pc14 {
+			label = "pc14";
+			gpios = <&pioC 14 0>;
 		};
 	};
 };
diff --git a/arch/arm/boot/dts/at91sam9x5ek.dtsi b/arch/arm/boot/dts/at91sam9x5ek.dtsi
index 8a7cf1d..b09e0c8 100644
--- a/arch/arm/boot/dts/at91sam9x5ek.dtsi
+++ b/arch/arm/boot/dts/at91sam9x5ek.dtsi
@@ -27,7 +27,7 @@
 				slot@0 {
 					reg = <0>;
 					bus-width = <4>;
-					cd-gpios = <&pioD 15 0>;
+					/* cd-gpios = <&pioD 15 0>; */
 				};
 			};
 
@@ -40,7 +40,7 @@
 				slot@0 {
 					reg = <0>;
 					bus-width = <4>;
-					cd-gpios = <&pioD 14 0>;
+					/* cd-gpios = <&pioD 14 0>; */
 				};
 			};
 
@@ -52,6 +52,14 @@
 				status = "okay";
 			};
 
+			usart1: serial@f8020000 {
+				status = "okay";
+			};
+
+			usart2: serial@f8024000 {
+				status = "okay";
+			};
+
 			macb0: ethernet@f802c000 {
 				phy-mode = "rmii";
 				status = "okay";
@@ -89,13 +97,22 @@
 		usb0: ohci@00600000 {
 			status = "okay";
 			num-ports = <2>;
-			atmel,vbus-gpio = <&pioD 19 1
-					   &pioD 20 1
-					  >;
+			atmel,vbus-gpio = <&pioB 12 0 &pioA 31 0>;
+			atmel,oc-gpio = <&pioB 13 1>;
 		};
 
 		usb1: ehci@00700000 {
 			status = "okay";
 		};
+
+		usb2: gadget@f803c000 {
+			atmel,vbus-gpio = <&pioB 11 0>;
+			status = "okay";
+		};
 	};
+
+	atheros {
+		compatible = "atheros,ath6kl";
+		atheros,board-id = "SD32";
+ 	};
 };
diff --git a/arch/arm/configs/wb45n_defconfig b/arch/arm/configs/wb45n_defconfig
new file mode 100644
index 0000000..da121e0
--- /dev/null
+++ b/arch/arm/configs/wb45n_defconfig
@@ -0,0 +1,273 @@
+CONFIG_EXPERIMENTAL=y
+CONFIG_CROSS_COMPILE="arm-sdc-linux-gnueabi-"
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_IRQ_DOMAIN_DEBUG=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_EMBEDDED=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_LBDAF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_ARCH_AT91=y
+CONFIG_SOC_AT91SAM9X5=y
+CONFIG_MACH_AT91SAM_DT=y
+CONFIG_AT91_PROGRAMMABLE_CLOCKS=y
+CONFIG_AT91_TIMER_HZ=128
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_COMPACTION is not set
+CONFIG_CLEANCACHE=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_ARM_APPENDED_DTB=y
+CONFIG_ARM_ATAG_DTB_COMPAT=y
+CONFIG_CMDLINE="mem=64M console=ttyS0,115200"
+CONFIG_AUTO_ZRELADDR=y
+CONFIG_CPU_IDLE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_RUNTIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+CONFIG_IPV6_SIT_6RD=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=m
+# CONFIG_NF_CONNTRACK_PROCFS is not set
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_NF_NAT_IPV4=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_BRIDGE_EBT_IP6=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_BRIDGE_EBT_ARPNAT=m
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_BRIDGE_EBT_NFLOG=m
+CONFIG_BRIDGE=m
+CONFIG_NET_PKTGEN=m
+CONFIG_CAN=m
+CONFIG_CAN_RAW=m
+CONFIG_CAN_BCM=m
+CONFIG_CAN_GW=m
+CONFIG_BT=m
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=m
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=m
+CONFIG_BT_HCIBTUSB=m
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_DEVELOPER_WARNINGS=y
+CONFIG_CFG80211_CERTIFICATION_ONUS=y
+CONFIG_CFG80211_DEBUGFS=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_ATMEL=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_GLUEBI=y
+CONFIG_PROC_DEVICETREE=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=4
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_ATMEL_PWM=y
+CONFIG_ATMEL_TCLIB=y
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_TUN=m
+CONFIG_MACB=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_ICPLUS_PHY=y
+CONFIG_PPP=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_ASYNC=m
+CONFIG_ATH_CARDS=m
+CONFIG_ATH6KL=m
+CONFIG_ATH6KL_SDIO=m
+CONFIG_ATH6KL_DEBUG=y
+CONFIG_ATH6KL_REGDOMAIN=y
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+CONFIG_LEGACY_PTY_COUNT=4
+CONFIG_SERIAL_ATMEL=y
+CONFIG_SERIAL_ATMEL_CONSOLE=y
+CONFIG_HW_RANDOM=y
+CONFIG_I2C=m
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=m
+CONFIG_I2C_AT91=m
+CONFIG_SPI=y
+CONFIG_SPI_ATMEL=m
+CONFIG_SPI_SPIDEV=m
+CONFIG_GPIO_SYSFS=y
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+CONFIG_AT91SAM9X_WATCHDOG=y
+CONFIG_HID=m
+CONFIG_USB_HID=m
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_DYNAMIC_MINORS=y
+CONFIG_USB_MON=m
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_OHCI_HCD=m
+CONFIG_USB_ACM=m
+CONFIG_USB_STORAGE=m
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_GADGET=m
+CONFIG_USB_ATMEL_USBA=m
+CONFIG_USB_ETH=m
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_USB_G_MULTI=m
+CONFIG_USB_G_MULTI_CDC=y
+CONFIG_USB_G_HID=m
+CONFIG_MMC=y
+CONFIG_MMC_ATMELMCI=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_LEDS_TRIGGER_TRANSIENT=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_AT91SAM9=y
+CONFIG_DMADEVICES=y
+CONFIG_NET_DMA=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_IIO=y
+CONFIG_AT91_ADC=y
+CONFIG_PWM=y
+# CONFIG_DNOTIFY is not set
+CONFIG_FANOTIFY=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_UBIFS_FS=y
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=7
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_FTRACE is not set
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_USER=y
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_CRYPTO_DEV_ATMEL_AES=y
+CONFIG_CRYPTO_DEV_ATMEL_TDES=y
+CONFIG_CRYPTO_DEV_ATMEL_SHA=y
diff --git a/arch/arm/mach-at91/at91sam9x5.c b/arch/arm/mach-at91/at91sam9x5.c
index 44a9a62..48815d4 100644
--- a/arch/arm/mach-at91/at91sam9x5.c
+++ b/arch/arm/mach-at91/at91sam9x5.c
@@ -244,6 +244,8 @@ static struct clk_lookup periph_clocks_lookups[] = {
 	/* additional fake clock for macb_hclk */
 	CLKDEV_CON_DEV_ID("hclk", "f802c000.ethernet", &macb0_clk),
 	CLKDEV_CON_DEV_ID("hclk", "f8030000.ethernet", &macb1_clk),
+	CLKDEV_CON_DEV_ID("hclk", "500000.gadget", &udphs_clk),
+	CLKDEV_CON_DEV_ID("pclk", "500000.gadget", &utmi_clk),
 	CLKDEV_CON_DEV_ID("hclk", "600000.ohci", &uhphs_clk),
 	CLKDEV_CON_DEV_ID("ohci_clk", "600000.ohci", &uhphs_clk),
 	CLKDEV_CON_DEV_ID("ehci_clk", "700000.ehci", &uhphs_clk),
diff --git a/arch/arm/mach-at91/board-dt.c b/arch/arm/mach-at91/board-dt.c
index 881170c..9be2e25 100644
--- a/arch/arm/mach-at91/board-dt.c
+++ b/arch/arm/mach-at91/board-dt.c
@@ -47,7 +47,7 @@ static const char *at91_dt_board_compat[] __initdata = {
 	NULL
 };
 
-DT_MACHINE_START(at91sam_dt, "Atmel AT91SAM (Device Tree)")
+DT_MACHINE_START(at91sam_dt, "Workgroup Bridge 45N - Atmel AT91SAM (dt)")
 	/* Maintainer: Atmel */
 	.timer		= &at91sam926x_timer,
 	.map_io		= at91_map_io,
diff --git a/drivers/mmc/host/atmel-mci.c b/drivers/mmc/host/atmel-mci.c
index 722af1d..38e2d5d 100644
--- a/drivers/mmc/host/atmel-mci.c
+++ b/drivers/mmc/host/atmel-mci.c
@@ -2350,6 +2350,13 @@ static int __init atmci_probe(struct platform_device *pdev)
 		}
 	}
 
+	at91_set_A_periph(AT91_PIN_PA15, 1); /* MCI0_DA0 */
+	at91_set_A_periph(AT91_PIN_PA16, 1); /* MCI0_CMD */
+	at91_set_A_periph(AT91_PIN_PA17, 0); /* MCI0_CLK */
+	at91_set_A_periph(AT91_PIN_PA18, 1); /* MCI0_DA1 */
+	at91_set_A_periph(AT91_PIN_PA19, 1); /* MCI0_DA2 */
+	at91_set_A_periph(AT91_PIN_PA20, 1); /* MCI0_DA3 */
+
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
 		return irq;
diff --git a/drivers/mtd/nand/atmel_nand.c b/drivers/mtd/nand/atmel_nand.c
index c516a94..0310ad5 100644
--- a/drivers/mtd/nand/atmel_nand.c
+++ b/drivers/mtd/nand/atmel_nand.c
@@ -65,10 +65,10 @@ module_param(on_flash_bbt, int, 0);
  * several NAND_CMD_RNDOUT during read
  */
 static struct nand_ecclayout atmel_oobinfo_large = {
-	.eccbytes = 4,
-	.eccpos = {60, 61, 62, 63},
+	.eccbytes = 28,
+	.eccpos = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29},
 	.oobfree = {
-		{2, 58}
+		{30, 34}
 	},
 };
 
diff --git a/drivers/net/wireless/ath/ath6kl/init.c b/drivers/net/wireless/ath/ath6kl/init.c
index f21fa32..aac973a 100644
--- a/drivers/net/wireless/ath/ath6kl/init.c
+++ b/drivers/net/wireless/ath/ath6kl/init.c
@@ -1432,7 +1432,7 @@ static int ath6kl_init_upload(struct ath6kl *ar)
 
 	/* WAR to avoid SDIO CRC err */
 	if (ar->hw.flags & ATH6KL_HW_SDIO_CRC_ERROR_WAR) {
-		ath6kl_err("temporary war to avoid sdio crc error\n");
+		/* ath6kl_err("temporary war to avoid sdio crc error\n"); */
 
 		param = 0x28;
 		address = GPIO_BASE_ADDRESS + GPIO_PIN9_ADDRESS;
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 14625fd..6008cd0 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -154,7 +154,7 @@ config USB_LPC32XX
 
 config USB_ATMEL_USBA
 	tristate "Atmel USBA"
-	depends on AVR32 || ARCH_AT91SAM9RL || ARCH_AT91SAM9G45
+	depends on AVR32 || ARCH_AT91
 	help
 	  USBA is the integrated high-speed USB Device controller on
 	  the AT32AP700x, some AT91SAM9 and AT91CAP9 processors from Atmel.
diff --git a/drivers/usb/gadget/atmel_usba_udc.c b/drivers/usb/gadget/atmel_usba_udc.c
index a7aed84..bd01a20 100644
--- a/drivers/usb/gadget/atmel_usba_udc.c
+++ b/drivers/usb/gadget/atmel_usba_udc.c
@@ -22,6 +22,8 @@
 #include <linux/usb/atmel_usba_udc.h>
 #include <linux/delay.h>
 #include <linux/platform_data/atmel.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
 
 #include <asm/gpio.h>
 
@@ -1852,9 +1854,145 @@ static int atmel_usba_stop(struct usb_gadget *gadget,
 	return 0;
 }
 
-static int __init usba_udc_probe(struct platform_device *pdev)
+#ifdef CONFIG_OF
+static struct usba_ep *atmel_udc_of_init(struct platform_device *pdev,
+		struct usba_udc *udc)
+{
+	u32 val;
+	const char *name;
+	enum of_gpio_flags flags;
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *pp;
+	int i, ret;
+	struct usba_ep *eps, *ep;
+
+	udc->num_ep = 0;
+
+	udc->vbus_pin = of_get_named_gpio_flags(np, "atmel,vbus-gpio", 0,
+						&flags);
+	udc->vbus_pin_inverted = (flags & OF_GPIO_ACTIVE_LOW) ? 1 : 0;
+
+	pp = NULL;
+	while ((pp = of_get_next_child(np, pp)))
+		udc->num_ep++;
+
+	eps = devm_kzalloc(&pdev->dev, sizeof(struct usba_ep) * udc->num_ep,
+			   GFP_KERNEL);
+	if (!eps)
+		return ERR_PTR(-ENOMEM);
+
+	udc->gadget.ep0 = &eps[0].ep;
+
+	INIT_LIST_HEAD(&eps[0].ep.ep_list);
+
+	pp = NULL;
+	i = 0;
+	while ((pp = of_get_next_child(np, pp))) {
+		ep = &eps[i];
+
+		ret = of_property_read_u32(pp, "reg", &val);
+		if (ret) {
+			dev_err(&pdev->dev, "of_probe: reg error(%d)\n", ret);
+			goto err;
+		}
+		ep->index = val;
+
+		ret = of_property_read_u32(pp, "atmel,fifo-size", &val);
+		if (ret) {
+			dev_err(&pdev->dev, "of_probe: fifo-size error(%d)\n",
+					ret);
+			goto err;
+		}
+		ep->fifo_size = val;
+
+		ret = of_property_read_u32(pp, "atmel,nb-banks", &val);
+		if (ret) {
+			dev_err(&pdev->dev, "of_probe: nb-banks error(%d)\n",
+					ret);
+			goto err;
+		}
+		ep->nr_banks = val;
+
+		ep->can_dma = of_property_read_bool(pp, "atmel,can-dma");
+		ep->can_isoc = of_property_read_bool(pp, "atmel,can-isoc");
+
+		ret = of_property_read_string(pp, "name", &name);
+		ep->ep.name = name;
+
+		ep->ep_regs = udc->regs + USBA_EPT_BASE(i);
+		ep->dma_regs = udc->regs + USBA_DMA_BASE(i);
+		ep->fifo = udc->fifo + USBA_FIFO_BASE(i);
+		ep->ep.ops = &usba_ep_ops;
+		ep->ep.maxpacket = ep->fifo_size;
+		ep->udc = udc;
+		INIT_LIST_HEAD(&ep->queue);
+
+		if (i)
+			list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
+
+		i++;
+	}
+
+	return eps;
+err:
+	return ERR_PTR(ret);
+}
+#else
+static struct usba_ep *atmel_udc_of_init(struct platform_device *pdev,
+		struct usba_udc *udc)
+{
+	return ERR_PTR(-ENOSYS);
+}
+#endif
+
+static struct usba_ep *usba_udc_pdata(struct platform_device *pdev,
+						 struct usba_udc *udc)
 {
 	struct usba_platform_data *pdata = pdev->dev.platform_data;
+	struct usba_ep *eps;
+	int i;
+
+	if (!pdata)
+		return ERR_PTR(-ENXIO);
+
+	eps = devm_kzalloc(&pdev->dev, sizeof(struct usba_ep) * pdata->num_ep,
+			   GFP_KERNEL);
+	if (!eps)
+		return ERR_PTR(-ENOMEM);
+
+	udc->gadget.ep0 = &eps[0].ep;
+
+	udc->vbus_pin = pdata->vbus_pin;
+	udc->vbus_pin_inverted = pdata->vbus_pin_inverted;
+	udc->num_ep = pdata->num_ep;
+
+	INIT_LIST_HEAD(&eps[0].ep.ep_list);
+
+	for (i = 0; i < pdata->num_ep; i++) {
+		struct usba_ep *ep = &eps[i];
+
+		ep->ep_regs = udc->regs + USBA_EPT_BASE(i);
+		ep->dma_regs = udc->regs + USBA_DMA_BASE(i);
+		ep->fifo = udc->fifo + USBA_FIFO_BASE(i);
+		ep->ep.ops = &usba_ep_ops;
+		ep->ep.name = pdata->ep[i].name;
+		ep->fifo_size = ep->ep.maxpacket = pdata->ep[i].fifo_size;
+		ep->udc = udc;
+		INIT_LIST_HEAD(&ep->queue);
+		ep->nr_banks = pdata->ep[i].nr_banks;
+		ep->index = pdata->ep[i].index;
+		ep->can_dma = pdata->ep[i].can_dma;
+		ep->can_isoc = pdata->ep[i].can_isoc;
+
+		if (i)
+			list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
+	}
+
+	return eps;
+}
+
+static int __init usba_udc_probe(struct platform_device *pdev)
+{
 	struct resource *regs, *fifo;
 	struct clk *pclk, *hclk;
 	struct usba_udc *udc = &the_udc;
@@ -1862,7 +2000,7 @@ static int __init usba_udc_probe(struct platform_device *pdev)
 
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, CTRL_IOMEM_ID);
 	fifo = platform_get_resource(pdev, IORESOURCE_MEM, FIFO_IOMEM_ID);
-	if (!regs || !fifo || !pdata)
+	if (!regs || !fifo)
 		return -ENXIO;
 
 	irq = platform_get_irq(pdev, 0);
@@ -1912,46 +2050,14 @@ static int __init usba_udc_probe(struct platform_device *pdev)
 	usba_writel(udc, CTRL, USBA_DISABLE_MASK);
 	clk_disable(pclk);
 
-	usba_ep = kzalloc(sizeof(struct usba_ep) * pdata->num_ep,
-			  GFP_KERNEL);
-	if (!usba_ep)
-		goto err_alloc_ep;
-
-	the_udc.gadget.ep0 = &usba_ep[0].ep;
-
-	INIT_LIST_HEAD(&usba_ep[0].ep.ep_list);
-	usba_ep[0].ep_regs = udc->regs + USBA_EPT_BASE(0);
-	usba_ep[0].dma_regs = udc->regs + USBA_DMA_BASE(0);
-	usba_ep[0].fifo = udc->fifo + USBA_FIFO_BASE(0);
-	usba_ep[0].ep.ops = &usba_ep_ops;
-	usba_ep[0].ep.name = pdata->ep[0].name;
-	usba_ep[0].ep.maxpacket = pdata->ep[0].fifo_size;
-	usba_ep[0].udc = &the_udc;
-	INIT_LIST_HEAD(&usba_ep[0].queue);
-	usba_ep[0].fifo_size = pdata->ep[0].fifo_size;
-	usba_ep[0].nr_banks = pdata->ep[0].nr_banks;
-	usba_ep[0].index = pdata->ep[0].index;
-	usba_ep[0].can_dma = pdata->ep[0].can_dma;
-	usba_ep[0].can_isoc = pdata->ep[0].can_isoc;
-
-	for (i = 1; i < pdata->num_ep; i++) {
-		struct usba_ep *ep = &usba_ep[i];
-
-		ep->ep_regs = udc->regs + USBA_EPT_BASE(i);
-		ep->dma_regs = udc->regs + USBA_DMA_BASE(i);
-		ep->fifo = udc->fifo + USBA_FIFO_BASE(i);
-		ep->ep.ops = &usba_ep_ops;
-		ep->ep.name = pdata->ep[i].name;
-		ep->ep.maxpacket = pdata->ep[i].fifo_size;
-		ep->udc = &the_udc;
-		INIT_LIST_HEAD(&ep->queue);
-		ep->fifo_size = pdata->ep[i].fifo_size;
-		ep->nr_banks = pdata->ep[i].nr_banks;
-		ep->index = pdata->ep[i].index;
-		ep->can_dma = pdata->ep[i].can_dma;
-		ep->can_isoc = pdata->ep[i].can_isoc;
+	if (pdev->dev.of_node)
+		usba_ep = atmel_udc_of_init(pdev, udc);
+	else
+		usba_ep = usba_udc_pdata(pdev, udc);
 
-		list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
+	if (IS_ERR(usba_ep)) {
+		ret = PTR_ERR(usba_ep);
+		goto err_alloc_ep;
 	}
 
 	ret = request_irq(irq, usba_udc_irq, 0, "atmel_usba_udc", udc);
@@ -1968,10 +2074,8 @@ static int __init usba_udc_probe(struct platform_device *pdev)
 		goto err_device_add;
 	}
 
-	if (gpio_is_valid(pdata->vbus_pin)) {
-		if (!gpio_request(pdata->vbus_pin, "atmel_usba_udc")) {
-			udc->vbus_pin = pdata->vbus_pin;
-			udc->vbus_pin_inverted = pdata->vbus_pin_inverted;
+	if (gpio_is_valid(udc->vbus_pin)) {
+		if (!gpio_request(udc->vbus_pin, "atmel_usba_udc")) {
 
 			ret = request_irq(gpio_to_irq(udc->vbus_pin),
 					usba_vbus_irq, 0,
@@ -1996,13 +2100,13 @@ static int __init usba_udc_probe(struct platform_device *pdev)
 		goto err_add_udc;
 
 	usba_init_debugfs(udc);
-	for (i = 1; i < pdata->num_ep; i++)
+	for (i = 1; i < udc->num_ep; i++)
 		usba_ep_init_debugfs(udc, &usba_ep[i]);
 
 	return 0;
 
 err_add_udc:
-	if (gpio_is_valid(pdata->vbus_pin)) {
+	if (gpio_is_valid(udc->vbus_pin)) {
 		free_irq(gpio_to_irq(udc->vbus_pin), udc);
 		gpio_free(udc->vbus_pin);
 	}
@@ -2031,13 +2135,12 @@ static int __exit usba_udc_remove(struct platform_device *pdev)
 {
 	struct usba_udc *udc;
 	int i;
-	struct usba_platform_data *pdata = pdev->dev.platform_data;
 
 	udc = platform_get_drvdata(pdev);
 
 	usb_del_gadget_udc(&udc->gadget);
 
-	for (i = 1; i < pdata->num_ep; i++)
+	for (i = 1; i < udc->num_ep; i++)
 		usba_ep_cleanup_debugfs(&usba_ep[i]);
 	usba_cleanup_debugfs(udc);
 
@@ -2058,11 +2161,21 @@ static int __exit usba_udc_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#if defined(CONFIG_OF)
+static const struct of_device_id atmel_udc_dt_ids[] = {
+	{ .compatible = "atmel,at91sam9rl-udc" },
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, atmel_udc_dt_ids);
+#endif
+
 static struct platform_driver udc_driver = {
 	.remove		= __exit_p(usba_udc_remove),
 	.driver		= {
 		.name		= "atmel_usba_udc",
 		.owner		= THIS_MODULE,
+		.of_match_table	= of_match_ptr(atmel_udc_dt_ids),
 	},
 };
 
diff --git a/drivers/usb/gadget/atmel_usba_udc.h b/drivers/usb/gadget/atmel_usba_udc.h
index 9791259..a7b2d25 100644
--- a/drivers/usb/gadget/atmel_usba_udc.h
+++ b/drivers/usb/gadget/atmel_usba_udc.h
@@ -323,6 +323,7 @@ struct usba_udc {
 	int irq;
 	int vbus_pin;
 	int vbus_pin_inverted;
+	int num_ep;
 	struct clk *pclk;
 	struct clk *hclk;
 
diff --git a/include/uapi/linux/netfilter_bridge/ebt_nat.h b/include/uapi/linux/netfilter_bridge/ebt_nat.h
index 5e74e3b..1024b62 100644
--- a/include/uapi/linux/netfilter_bridge/ebt_nat.h
+++ b/include/uapi/linux/netfilter_bridge/ebt_nat.h
@@ -9,5 +9,6 @@ struct ebt_nat_info {
 };
 #define EBT_SNAT_TARGET "snat"
 #define EBT_DNAT_TARGET "dnat"
+#define EBT_ARPNAT_TARGET "arpnat"
 
 #endif
diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
index d9576e6..fe73224 100644
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -674,3 +674,4 @@ int br_fdb_delete(struct ndmsg *ndm, struct net_device *dev,
 
 	return err;
 }
+
diff --git a/net/bridge/netfilter/Kconfig b/net/bridge/netfilter/Kconfig
index a9aff9c..0bcf1d9 100644
--- a/net/bridge/netfilter/Kconfig
+++ b/net/bridge/netfilter/Kconfig
@@ -177,6 +177,16 @@ config BRIDGE_EBT_SNAT
 	  source address of frames.
 
 	  To compile it as a module, choose M here.  If unsure, say N.
+
+config BRIDGE_EBT_ARPNAT
+	tristate "ebt: arpnat target support"
+	depends on BRIDGE_NF_EBTABLES
+	help
+	  This option adds the ARP match, which allows ARP and RARP header field
+	  filtering
+ 
+	  To compile it as a module, choose M here. If unsure, say N.
+
 #
 # watchers
 #
diff --git a/net/bridge/netfilter/Makefile b/net/bridge/netfilter/Makefile
index 0718699..2017bc4 100644
--- a/net/bridge/netfilter/Makefile
+++ b/net/bridge/netfilter/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_BRIDGE_EBT_MARK_T) += ebt_mark.o
 obj-$(CONFIG_BRIDGE_EBT_DNAT) += ebt_dnat.o
 obj-$(CONFIG_BRIDGE_EBT_REDIRECT) += ebt_redirect.o
 obj-$(CONFIG_BRIDGE_EBT_SNAT) += ebt_snat.o
+obj-$(CONFIG_BRIDGE_EBT_ARPNAT) += ebt_arpnat.o
 
 # watchers
 obj-$(CONFIG_BRIDGE_EBT_LOG) += ebt_log.o
diff --git a/net/bridge/netfilter/ebt_arpnat.c b/net/bridge/netfilter/ebt_arpnat.c
new file mode 100644
index 0000000..4023340
--- /dev/null
+++ b/net/bridge/netfilter/ebt_arpnat.c
@@ -0,0 +1,650 @@
+/*
+ *  ebt_arpnat
+ *
+ *	Authors:
+ *      Kestutis Barkauskas <gpl@wilibox.com>
+ *
+ *  November, 2005
+ *
+ *	Rewritten by:
+ *         Kestutis Barkauskas and Kestutis Kupciunas <gpl@ubnt.com>
+ *
+ *  June, 2010
+ *
+ *      Updated to work with more recent kernel versions (e.g., 2.6.30)
+ *      Ditched entry expiration in favor of wiping entries with duplicate ips, when situation arises
+ *      Fixed arpnat procfs (though both arpnat_cache and arpnat_info are both in root procfs directory now)
+ *      
+ *      Eric Bishop <eric@gargoyle-router.com>
+ *
+ *  September 18, 2011
+ *
+ *      Updated code to work with kernel v3.0.0
+ *      Various bridging structures have changed
+ *      Added debugging information
+ *      Christopher Cole <chris.cole@lairdtech.com>
+ *
+ * February 11, 2012
+ *
+ *      Added DHCP Relay code
+ *      Christopher Cole <chris.cole@lairdtech.com>
+ */
+
+
+
+
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter_bridge/ebtables.h>
+#include <linux/netfilter_bridge/ebt_nat.h>
+#include <linux/module.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/if_pppox.h>
+#include <linux/if_vlan.h>
+#include <linux/rtnetlink.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/proc_fs.h>
+#include <linux/inetdevice.h>
+#include <net/arp.h>
+#include <net/ip.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/in.h>
+#include <net/checksum.h>
+
+
+#include "../br_private.h"
+
+#define STRMAC "%02x:%02x:%02x:%02x:%02x:%02x"
+#define STRIP "%d.%d.%d.%d"
+#define MAC2STR(x) (x)[0],(x)[1],(x)[2],(x)[3],(x)[4],(x)[5]
+#define IP2STR(x) (x)>>24&0xff,(x)>>16&0xff,(x)>>8&0xff,(x)&0xff
+
+#define GIADDR_OFFSET (24)
+#define CHADDR_OFFSET (28)
+
+
+
+//#define ARPNAT_DEBUG 1
+
+
+#ifdef ARPNAT_DEBUG
+static uint8_t debug = 1;
+#else
+static uint8_t debug = 0;
+#endif
+
+
+
+#ifndef __packed
+#define __packed __attribute__((__packed__))
+#endif
+
+static uint8_t chaddr_orig_bootp_relay[6] = {0};
+
+struct arpnat_dat
+{
+	uint32_t ip;
+	uint8_t mac[ETH_ALEN];
+} __packed;
+
+struct mac2ip
+{
+	struct hlist_node node;
+	struct arpnat_dat data;
+};
+
+static HLIST_HEAD(arpnat_table);
+static spinlock_t arpnat_lock = __SPIN_LOCK_UNLOCKED(arpnat_lock);
+
+static uint8_t bootpnat = 1;
+
+static struct mac2ip* find_mac_nat(struct hlist_head* head, const uint8_t* mac)
+{
+	struct mac2ip* tpos;
+	struct mac2ip* result = NULL;
+	struct hlist_node* pos;
+	struct hlist_node* n;
+	hlist_for_each_entry_safe(tpos, pos, n, head, node)
+	{
+		if (memcmp(tpos->data.mac, mac, ETH_ALEN) == 0)
+		{
+			result = tpos;
+			break;
+		}
+	}
+	return result;
+}
+
+static struct mac2ip* find_ip_nat(struct hlist_head* head, uint32_t ip)
+{
+	struct mac2ip* tpos;
+	struct mac2ip* result = NULL;
+	struct hlist_node* pos;
+	struct hlist_node* n;
+
+	hlist_for_each_entry_safe(tpos, pos, n, head, node)
+	{
+		if (tpos->data.ip == ip)
+		{
+			result = tpos;
+			break;
+		}
+	}
+	return result;
+}
+
+
+static void clear_ip_nat(struct hlist_head* head, uint32_t ip)
+{
+	struct mac2ip* tpos;
+	struct hlist_node* pos;
+	struct hlist_node* n;
+
+	hlist_for_each_entry_safe(tpos, pos, n, head, node)
+	{
+		if (tpos->data.ip == ip)
+		{
+			hlist_del(pos);
+	   		kfree(tpos);
+		}
+	}
+}
+
+static void free_arp_nat(struct hlist_head* head)
+{
+	struct mac2ip* tpos;
+	struct hlist_node* pos;
+	struct hlist_node* n;
+	hlist_for_each_entry_safe(tpos, pos, n, head, node)
+	{
+		hlist_del(pos);
+		kfree(tpos);
+	}
+}
+
+static struct mac2ip* update_arp_nat(struct hlist_head* head, const uint8_t* mac, uint32_t ip)
+{
+	struct mac2ip* entry;
+
+	entry = find_mac_nat(head, mac);
+	if (!entry)
+	{
+		clear_ip_nat(head, ip); /* if entries with new ip exist, wipe them */ 
+		entry = kmalloc(sizeof(*entry), GFP_ATOMIC);
+		if (!entry)
+		{
+			return NULL;
+		}
+		INIT_HLIST_NODE(&entry->node);
+		hlist_add_head(&entry->node, head);
+		memcpy(entry->data.mac, mac, ETH_ALEN);
+		entry->data.ip = ip;
+	}
+	else if(entry->data.ip != ip)
+	{
+		clear_ip_nat(head, ip); /* if entries with new ip exist, wipe them */ 
+		entry->data.ip = ip;
+	}
+	return entry;
+}
+
+#ifdef CONFIG_PROC_FS
+
+static void *arpnat_start(struct seq_file *seq, loff_t *loff_pos)
+{
+	static unsigned long counter = 0;
+
+	/* beginning a new sequence ? */	
+	if ( *loff_pos == 0 )
+	{	
+		/* yes => return a non null value to begin the sequence */
+		return &counter;
+	}
+	else
+	{
+		/* no => it's the end of the sequence, return end to stop reading */
+		*loff_pos = 0;
+		return NULL;
+	}
+}
+
+static void *arpnat_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	return NULL;
+}
+
+
+static void arpnat_stop(struct seq_file *seq, void *v)
+{
+	//don't need to do anything
+}
+
+
+static int arpnat_cache_show(struct seq_file *s, void *v)
+{
+	struct mac2ip* tpos;
+	struct hlist_node* pos;
+	struct hlist_node* n;
+	unsigned long flags;
+
+	spin_lock_irqsave(&arpnat_lock, flags);
+	hlist_for_each_entry_safe(tpos, pos, n, &arpnat_table, node)
+	{
+		seq_printf(s, STRMAC"\t"STRIP"\n", MAC2STR(tpos->data.mac), IP2STR(tpos->data.ip));
+	}
+	spin_unlock_irqrestore(&arpnat_lock, flags);
+
+	return 0;
+}
+static int arpnat_info_show(struct seq_file *s, void *v)
+{
+	seq_printf(s, "Debug: %d\nBOOTPNAT: %d\n", debug, bootpnat);
+	return 0;
+}
+
+
+static struct seq_operations arpnat_cache_sops = {
+	.start = arpnat_start,
+	.next  = arpnat_next,
+	.stop  = arpnat_stop,
+	.show  = arpnat_cache_show
+};
+static struct seq_operations arpnat_info_sops = {
+	.start = arpnat_start,
+	.next  = arpnat_next,
+	.stop  = arpnat_stop,
+	.show  = arpnat_info_show
+};
+
+static int arpnat_cache_open(struct inode *inode, struct file* file)
+{
+	return seq_open(file, &arpnat_cache_sops);
+}
+static int arpnat_info_open(struct inode *inode, struct file* file)
+{
+	return seq_open(file, &arpnat_info_sops);
+}
+
+
+static struct file_operations arpnat_cache_fops = {
+	.owner   = THIS_MODULE,
+	.open    = arpnat_cache_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release
+};
+static struct file_operations arpnat_info_fops = {
+	.owner   = THIS_MODULE,
+	.open    = arpnat_info_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release
+};
+
+
+
+#endif
+
+
+static unsigned int ebt_target_arpnat(struct sk_buff *pskb, const struct xt_action_param *par)
+{
+	const struct net_device *in  =  par->in;
+	const struct net_device *out =  par->out;
+
+	const struct ebt_nat_info *info = (struct ebt_nat_info *) par->targinfo;
+
+	struct arphdr *ah = NULL;
+	struct arphdr _arph;
+
+
+	//used for target only
+	uint8_t* eth_smac = eth_hdr(pskb)->h_source;
+	uint8_t* eth_dmac = eth_hdr(pskb)->h_dest;
+	uint32_t* arp_sip = NULL;
+	uint8_t* arp_smac = NULL;
+	uint32_t* arp_dip = NULL;
+	uint8_t* arp_dmac = NULL;
+	struct mac2ip* entry = NULL;
+	unsigned long flags;
+
+	/* if it's an arp packet, initialize pointers to arp source/dest ip/mac addresses in skb */
+	if (eth_hdr(pskb)->h_proto == __constant_htons(ETH_P_ARP))
+	{
+		if(debug)
+		{
+			printk("ARPNAT ARP DETECTED\n");
+		}
+		ah = skb_header_pointer(pskb, 0, sizeof(_arph), &_arph);
+		if (ah->ar_hln == ETH_ALEN && ah->ar_pro == htons(ETH_P_IP) && ah->ar_pln == 4)
+		{
+			unsigned char *raw = skb_network_header(pskb);
+			arp_sip = (uint32_t*)(raw + sizeof(struct arphdr) + (arp_hdr(pskb)->ar_hln));
+			arp_smac = raw + sizeof(struct arphdr);
+			arp_dip = (uint32_t*)(raw + sizeof(struct arphdr) + (2*(arp_hdr(pskb)->ar_hln)) + arp_hdr(pskb)->ar_pln);
+			arp_dmac = raw + sizeof(struct arphdr) + arp_hdr(pskb)->ar_hln + arp_hdr(pskb)->ar_pln;
+		}
+		else
+		{
+			ah = NULL;
+		}
+	}
+	
+	if (in)
+	{
+		struct net_bridge_port *in_br_port;
+		in_br_port = br_port_get_rcu(in);
+
+		/* handle input packets */
+		if(debug)
+		{
+			printk("ARPNAT INBOUND DETECTED\n");
+		}
+
+		if (ah)
+		{
+			if(debug)
+			{
+				printk("IN ARPNAT:\n");
+				printk("          arp_smac="STRMAC", arp_dmac="STRMAC"\n", MAC2STR(arp_smac), MAC2STR(arp_dmac));
+				printk("          arp_sip ="STRIP", arp_dip ="STRIP"\n", IP2STR(*arp_sip), IP2STR(*arp_dip));
+				if(ah->ar_op == __constant_htons(ARPOP_REPLY))
+				{
+					printk("          arp_op=reply\n");
+				}
+				else if(ah->ar_op == __constant_htons(ARPOP_REQUEST))
+				{
+					printk("          arp_op=request\n");
+				}
+				else
+				{
+					printk("          arp_op=%d\n", ntohs(ah->ar_op));
+				}
+
+			}
+
+
+			if (inet_confirm_addr( __in_dev_get_rcu(in_br_port->br->dev) , 0, *arp_dip, RT_SCOPE_HOST))
+			{
+				if (debug)
+				{
+					printk("          TO US\n");
+				}
+				return info->target;
+			}
+
+
+			spin_lock_irqsave(&arpnat_lock, flags);
+			entry = find_ip_nat(&arpnat_table, *arp_dip);
+			switch (ah->ar_op)
+			{
+				case __constant_htons(ARPOP_REPLY):
+	 			case __constant_htons(ARPOP_REQUEST):
+				if (entry)
+				{
+					uint32_t dip = *arp_dip;
+					uint32_t sip = inet_select_addr(in_br_port->br->dev, dip, RT_SCOPE_LINK);
+					if (! (eth_dmac[0] & 1))
+					{
+						if (debug)
+						{
+							printk("          "STRMAC" -> "STRMAC"\n", MAC2STR(eth_dmac), MAC2STR(entry->data.mac));
+						}
+						memcpy(arp_dmac, entry->data.mac, ETH_ALEN);
+						memcpy(eth_dmac, entry->data.mac, ETH_ALEN);
+						(pskb)->pkt_type = (dip != sip) ? PACKET_OTHERHOST : (pskb)->pkt_type;
+					}
+					spin_unlock_irqrestore(&arpnat_lock, flags);
+					/*if (dip != sip)
+					{
+						if (debug)
+							printk("SEND ARP REQUEST: "STRIP" -> "STRIP"\n", IP2STR(sip), IP2STR(dip));
+						arp_send(ARPOP_REQUEST, ETH_P_ARP, dip, &in_br_port->br->dev, sip, NULL, in_br_port->br->dev.dev_addr, NULL);
+					}*/
+					return info->target;
+				}
+				break;
+			}
+			spin_unlock_irqrestore(&arpnat_lock, flags);
+		}
+		else if (eth_hdr(pskb)->h_proto == __constant_htons(ETH_P_IP))
+		{
+			struct iphdr *iph = ip_hdr(pskb);
+			struct udphdr *uh = NULL;
+			if (bootpnat && (unsigned char)iph->protocol == (unsigned char)IPPROTO_UDP && !(iph->frag_off & htons(IP_OFFSET)))
+			{
+				uh = (struct udphdr*)((u_int32_t *)iph + iph->ihl);
+				if(uh->dest == htons(67) || uh->dest == htons(68) )
+				{
+					//do something illegal for BOOTP
+					uint32_t* giaddrp = (uint32_t*)(((uint8_t*)uh) + sizeof(*uh) + GIADDR_OFFSET);
+					uint8_t* mac = (uint8_t*)(giaddrp + 1);
+					uint32_t ihl = iph->ihl << 2;
+					uint32_t size = (pskb)->len - ihl;
+					uint32_t orig_daddr = iph->daddr;
+
+					//iph->daddr = 0xffffffff;
+					// Recall the original BOOTP CHADDR
+					memcpy(mac, &chaddr_orig_bootp_relay, ETH_ALEN);
+					if (debug)
+					{
+						printk("IN BOOTPRELAY: "STRMAC"["STRIP"] -> "STRMAC"["STRIP"]\n", MAC2STR(eth_dmac), IP2STR(orig_daddr), MAC2STR(mac), IP2STR(iph->daddr));
+					}
+					memcpy(eth_dmac, mac, ETH_ALEN);
+					*giaddrp = 0;
+					uh->dest = htons(68);
+					iph->check = 0;
+					uh->check = 0;
+					iph->check = ip_fast_csum((uint8_t*)iph, iph->ihl);
+					(pskb)->csum = csum_partial((uint8_t*)iph + ihl, size, 0);
+					uh->check = csum_tcpudp_magic(iph->saddr, iph->daddr, size, iph->protocol, (pskb)->csum);
+					
+					if (uh->check == 0)
+					{
+						uh->check = 0xFFFF;
+					}
+					return info->target;
+				}
+				else
+				{
+					goto HANDLE_IP_PKT;
+				}
+			}	
+			else
+			{
+				HANDLE_IP_PKT:
+				spin_lock_irqsave(&arpnat_lock, flags);
+				entry = find_ip_nat(&arpnat_table, iph->daddr);
+				if (entry)
+				{
+					if (inet_confirm_addr( __in_dev_get_rcu(in_br_port->br->dev),  0, entry->data.ip, RT_SCOPE_HOST))
+					{
+						//to me
+						if (debug)
+						{
+							printk("IP PKT TO ME: "STRMAC"["STRIP"] -> "STRMAC"[type: %d]\n", MAC2STR(eth_dmac), IP2STR(iph->daddr), MAC2STR(in_br_port->br->dev->dev_addr), (pskb)->pkt_type);
+						}
+						memcpy(eth_dmac, in_br_port->br->dev->dev_addr, ETH_ALEN);
+					}
+					else
+					{
+						if (debug)
+						{
+							printk("IP PKT TO OTHER: "STRMAC"["STRIP"] -> "STRMAC"[type: %d]\n", MAC2STR(eth_dmac), IP2STR(iph->daddr), MAC2STR(entry->data.mac), (pskb)->pkt_type);
+						}
+						memcpy(eth_dmac, entry->data.mac, ETH_ALEN);
+						(pskb)->pkt_type = PACKET_OTHERHOST;
+					}
+					spin_unlock_irqrestore(&arpnat_lock, flags);
+					return info->target;
+				}
+				spin_unlock_irqrestore(&arpnat_lock, flags);
+			}
+		}
+		
+		if (! (eth_dmac[0] & 1))
+		{
+			if (memcmp(in_br_port->br->dev->dev_addr, eth_dmac, ETH_ALEN) && memcmp(in->dev_addr, eth_dmac, ETH_ALEN))
+			{
+				return EBT_DROP;
+			}
+			spin_lock_irqsave(&arpnat_lock, flags);
+			entry = find_mac_nat(&arpnat_table, eth_dmac);
+			if (entry)
+			{
+				memcpy(eth_dmac, entry->data.mac, ETH_ALEN);
+			}
+			else
+			{
+				memcpy(eth_dmac, in_br_port->br->dev->dev_addr, ETH_ALEN);
+			}
+			spin_unlock_irqrestore(&arpnat_lock, flags);
+		}
+	}
+	else if (out)
+	{
+		struct net_bridge_port *out_br_port;
+		out_br_port = br_port_get_rcu(out);
+
+
+		/* handle outbound packets */
+		if (ah)
+		{
+			switch (ah->ar_op)
+			{
+				case __constant_htons(ARPOP_REQUEST):
+				case __constant_htons(ARPOP_REPLY):
+
+				
+				/* do BR ip lookup */
+				if(inet_confirm_addr( __in_dev_get_rcu(out_br_port->br->dev), 0, *arp_dip, RT_SCOPE_HOST))
+				{
+					return info->target;
+				}
+				if(!inet_confirm_addr( __in_dev_get_rcu(out_br_port->br->dev), 0, *arp_sip, RT_SCOPE_HOST))
+				{
+					spin_lock_irqsave(&arpnat_lock, flags);
+					update_arp_nat(&arpnat_table, arp_smac, *arp_sip);
+					spin_unlock_irqrestore(&arpnat_lock, flags);
+				}
+
+				//pskb = skb_unshare(pskb, GFP_ATOMIC);
+				eth_smac = eth_hdr(pskb)->h_source;
+				arp_smac = skb_network_header(pskb) + sizeof(struct arphdr);
+				if (debug)
+				{
+					printk("OUT ARPNAT: "STRMAC" -> "STRMAC"\n", MAC2STR(eth_smac), MAC2STR(out->dev_addr));
+					printk("           arp_smac="STRMAC", arp_dmac="STRMAC"\n", MAC2STR(arp_smac), MAC2STR(arp_dmac));
+					printk("           arp_sip ="STRIP", arp_dip ="STRIP"\n", IP2STR(*arp_sip), IP2STR(*arp_dip));
+					if(ah->ar_op == __constant_htons(ARPOP_REPLY))
+					{
+						printk("           arp_op=reply\n");
+					}
+					else if(ah->ar_op == __constant_htons(ARPOP_REQUEST))
+					{
+						printk("           arp_op=request\n");
+					}
+					else
+					{
+						printk("           arp_op=%d\n", ntohs(ah->ar_op));
+					}
+				}
+				memcpy(arp_smac, out->dev_addr, ETH_ALEN);
+				memcpy(eth_smac, out->dev_addr, ETH_ALEN);
+				return info->target;
+				break;
+			}
+		}
+		else if (bootpnat && eth_hdr(pskb)->h_proto == __constant_htons(ETH_P_IP) && memcmp(out_br_port->br->dev->dev_addr, eth_smac, ETH_ALEN))
+		{
+			struct iphdr *iph = ip_hdr(pskb);
+			struct udphdr *uh = NULL;
+			if ( (unsigned char)iph->protocol == (unsigned char)IPPROTO_UDP && !(iph->frag_off & htons(IP_OFFSET)))
+			{
+				uh = (struct udphdr*)((u_int32_t *)iph + iph->ihl);
+				if (uh->dest == htons(67) || uh->dest == htons(68) )
+				{
+					//do something illegal for BOOTP
+					uint32_t giaddr = inet_select_addr(out_br_port->br->dev, iph->daddr, RT_SCOPE_LINK);
+					uint32_t* giaddrp = (uint32_t*)(((uint8_t*)uh) + sizeof(*uh) + GIADDR_OFFSET);
+					uint8_t *chaddrp = (uint8_t*)(((uint8_t*)uh) + sizeof(*uh) + CHADDR_OFFSET);
+					uint32_t ihl = iph->ihl << 2;
+					uint32_t size = (pskb)->len - ihl;
+					if (debug)
+					{
+						printk("OUT BOOTPRELAY: "STRIP" -> "STRIP"\n", IP2STR(*giaddrp), IP2STR(giaddr));
+					}
+					*giaddrp = giaddr;
+					// Save off the original BOOTP CHADDR
+					memcpy(&chaddr_orig_bootp_relay, chaddrp, ETH_ALEN);
+					// Change the DHCP HWADDR of the requestor to the HDADDR of the out device
+					memcpy(chaddrp, out->dev_addr, ETH_ALEN);
+
+					/* Fix the checksum */
+					uh->check = 0;
+					(pskb)->csum = csum_partial((uint8_t*)iph + ihl, size, 0);
+					uh->check = csum_tcpudp_magic(iph->saddr, iph->daddr, size, iph->protocol, (pskb)->csum);
+					
+					if (uh->check == 0)
+					{
+						uh->check = 0xFFFF;
+					}
+				}
+			}
+		}
+		memcpy(eth_smac, out->dev_addr, ETH_ALEN);
+	}
+	return info->target;
+}
+
+static int ebt_target_nat_arpcheck(const struct xt_tgchk_param *par)
+{
+	return 0;
+}
+static struct xt_target arpnat =
+{
+	.name		= EBT_ARPNAT_TARGET,
+	.revision	= 0,
+	.family		= NFPROTO_BRIDGE,
+	.table		= "nat",
+	.hooks		= (1 << NF_BR_NUMHOOKS) | (1 << NF_BR_POST_ROUTING) |  (1 << NF_BR_PRE_ROUTING) ,
+	.target		= ebt_target_arpnat, 
+	.checkentry	= ebt_target_nat_arpcheck,
+	.targetsize	= XT_ALIGN(sizeof(struct ebt_nat_info)),
+	.me		= THIS_MODULE
+};
+
+static int __init init(void)
+{
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *proc_arpnat_info  = create_proc_entry("arpnat_info", 0, NULL);
+	struct proc_dir_entry *proc_arpnat_cache = create_proc_entry("arpnat_cache", 0, NULL);
+	if(proc_arpnat_info)
+	{
+		proc_arpnat_info->proc_fops = &arpnat_info_fops;
+	}
+	
+	if(proc_arpnat_cache)
+	{
+		proc_arpnat_cache->proc_fops = &arpnat_cache_fops;
+	}
+#endif
+	return xt_register_target(&arpnat);
+}
+
+static void __exit fini(void)
+{
+	xt_unregister_target(&arpnat);
+	free_arp_nat(&arpnat_table);
+#ifdef CONFIG_PROC_FS
+	remove_proc_entry("arpnat_info", NULL);
+	remove_proc_entry("arpnat_cache", NULL);
+#endif
+}
+
+module_init(init);
+module_exit(fini);
+MODULE_LICENSE("GPL");
+
+
diff --git a/net/wireless/core.c b/net/wireless/core.c
index b677eab..f6ca501 100644
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -868,8 +868,7 @@ static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
 
 		netdev_set_default_ethtool_ops(dev, &cfg80211_ethtool_ops);
 
-		if ((wdev->iftype == NL80211_IFTYPE_STATION ||
-		     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT ||
+		if ((wdev->iftype == NL80211_IFTYPE_P2P_CLIENT ||
 		     wdev->iftype == NL80211_IFTYPE_ADHOC) && !wdev->use_4addr)
 			dev->priv_flags |= IFF_DONT_BRIDGE;
 		break;
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index f45706a..b6752cb 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -1960,8 +1960,6 @@ static int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,
 			       enum nl80211_iftype iftype)
 {
 	if (!use_4addr) {
-		if (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))
-			return -EBUSY;
 		return 0;
 	}
 
diff --git a/net/wireless/util.c b/net/wireless/util.c
index 16d76a8..08e1653 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -817,7 +817,6 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 	/* if it's part of a bridge, reject changing type to station/ibss */
 	if ((dev->priv_flags & IFF_BRIDGE_PORT) &&
 	    (ntype == NL80211_IFTYPE_ADHOC ||
-	     ntype == NL80211_IFTYPE_STATION ||
 	     ntype == NL80211_IFTYPE_P2P_CLIENT))
 		return -EBUSY;
 
@@ -864,14 +863,11 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 	if (!err) {
 		dev->priv_flags &= ~IFF_DONT_BRIDGE;
 		switch (ntype) {
-		case NL80211_IFTYPE_STATION:
-			if (dev->ieee80211_ptr->use_4addr)
-				break;
-			/* fall through */
 		case NL80211_IFTYPE_P2P_CLIENT:
 		case NL80211_IFTYPE_ADHOC:
 			dev->priv_flags |= IFF_DONT_BRIDGE;
 			break;
+		case NL80211_IFTYPE_STATION:
 		case NL80211_IFTYPE_P2P_GO:
 		case NL80211_IFTYPE_AP:
 		case NL80211_IFTYPE_AP_VLAN:
-- 
1.7.9.5

