From 5fde794a76780fc826d34c6025f411d2ff8ecbdc Mon Sep 17 00:00:00 2001
From: Dimitrios Siganos <dimitris@siganos.org>
Date: Tue, 12 Nov 2013 14:37:36 +0000
Subject: [PATCH] Open sourcing the Laird fips modules.

Bug 4560.
---
 arch/arm/configs/wb45n_defconfig               |   1 +
 drivers/net/wireless/Kconfig                   |   1 +
 drivers/net/wireless/Makefile                  |   2 +
 drivers/net/wireless/ath/ath6kl/common.h       |   2 +-
 drivers/net/wireless/ath/ath6kl/core.c         |   2 +-
 drivers/net/wireless/ath/ath6kl/init.c         |   2 +-
 drivers/net/wireless/ath/ath6kl/laird.h        |  86 ---
 drivers/net/wireless/ath/ath6kl/laird_common.h |  66 --
 drivers/net/wireless/ath/ath6kl/main.c         |   2 +-
 drivers/net/wireless/ath/ath6kl/txrx.c         |   2 +-
 drivers/net/wireless/ath/ath6kl/wmi.c          |   2 +-
 drivers/net/wireless/laird_fips/Kconfig        |   5 +
 drivers/net/wireless/laird_fips/Makefile       |   7 +
 drivers/net/wireless/laird_fips/laird.c        | 614 +++++++++++++++++++
 drivers/net/wireless/laird_fips/laird.h        | 108 ++++
 drivers/net/wireless/laird_fips/laird_common.h |  70 +++
 drivers/net/wireless/laird_fips/laird_i.h      |  36 ++
 drivers/net/wireless/laird_fips/laird_mod.c    |  47 ++
 drivers/net/wireless/laird_fips/mod2urw.c      | 802 +++++++++++++++++++++++++
 drivers/net/wireless/laird_fips/mod2urw.h      |  46 ++
 drivers/net/wireless/laird_fips/moddebug.c     |  60 ++
 drivers/net/wireless/laird_fips/moddebug.h     |  26 +
 drivers/net/wireless/laird_fips/touser.h       |  53 ++
 23 files changed, 1884 insertions(+), 158 deletions(-)
 delete mode 100644 drivers/net/wireless/ath/ath6kl/laird.h
 delete mode 100644 drivers/net/wireless/ath/ath6kl/laird_common.h
 create mode 100644 drivers/net/wireless/laird_fips/Kconfig
 create mode 100644 drivers/net/wireless/laird_fips/Makefile
 create mode 100644 drivers/net/wireless/laird_fips/laird.c
 create mode 100644 drivers/net/wireless/laird_fips/laird.h
 create mode 100644 drivers/net/wireless/laird_fips/laird_common.h
 create mode 100644 drivers/net/wireless/laird_fips/laird_i.h
 create mode 100644 drivers/net/wireless/laird_fips/laird_mod.c
 create mode 100644 drivers/net/wireless/laird_fips/mod2urw.c
 create mode 100644 drivers/net/wireless/laird_fips/mod2urw.h
 create mode 100644 drivers/net/wireless/laird_fips/moddebug.c
 create mode 100644 drivers/net/wireless/laird_fips/moddebug.h
 create mode 100644 drivers/net/wireless/laird_fips/touser.h

diff --git a/arch/arm/configs/wb45n_defconfig b/arch/arm/configs/wb45n_defconfig
index 58fd4d5..73e9fc7 100644
--- a/arch/arm/configs/wb45n_defconfig
+++ b/arch/arm/configs/wb45n_defconfig
@@ -179,6 +179,7 @@ CONFIG_ATH6KL=m
 CONFIG_ATH6KL_SDIO=m
 CONFIG_ATH6KL_DEBUG=y
 CONFIG_ATH6KL_REGDOMAIN=y
+CONFIG_LAIRD_FIPS=m
 # CONFIG_INPUT_MOUSEDEV is not set
 CONFIG_INPUT_EVDEV=y
 # CONFIG_KEYBOARD_ATKBD is not set
diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index 28aa05f..e012565 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -280,5 +280,6 @@ source "drivers/net/wireless/rtlwifi/Kconfig"
 source "drivers/net/wireless/ti/Kconfig"
 source "drivers/net/wireless/zd1211rw/Kconfig"
 source "drivers/net/wireless/mwifiex/Kconfig"
+source "drivers/net/wireless/laird_fips/Kconfig"
 
 endif # WLAN
diff --git a/drivers/net/wireless/Makefile b/drivers/net/wireless/Makefile
index 67156ef..15277e2 100644
--- a/drivers/net/wireless/Makefile
+++ b/drivers/net/wireless/Makefile
@@ -57,3 +57,5 @@ obj-$(CONFIG_MWIFIEX)	+= mwifiex/
 
 obj-$(CONFIG_BRCMFMAC)	+= brcm80211/
 obj-$(CONFIG_BRCMSMAC)	+= brcm80211/
+
+obj-$(CONFIG_LAIRD_FIPS)	+= laird_fips/
diff --git a/drivers/net/wireless/ath/ath6kl/common.h b/drivers/net/wireless/ath/ath6kl/common.h
index 63e4101..6d6844c 100644
--- a/drivers/net/wireless/ath/ath6kl/common.h
+++ b/drivers/net/wireless/ath/ath6kl/common.h
@@ -84,6 +84,6 @@ struct ath6kl_htc_credit_info;
 
 struct sk_buff *ath6kl_buf_alloc(int size);
 
-#include "laird.h"
+#include "../../laird_fips/laird.h"
 
 #endif /* COMMON_H */
diff --git a/drivers/net/wireless/ath/ath6kl/core.c b/drivers/net/wireless/ath/ath6kl/core.c
index ea527d4..ad83ee0 100644
--- a/drivers/net/wireless/ath/ath6kl/core.c
+++ b/drivers/net/wireless/ath/ath6kl/core.c
@@ -27,7 +27,7 @@
 #include "htc-ops.h"
 #include "cfg80211.h"
 
-#include "laird.h"
+#include "../../laird_fips/laird.h"
 
 unsigned int debug_mask;
 static unsigned int suspend_mode;
diff --git a/drivers/net/wireless/ath/ath6kl/init.c b/drivers/net/wireless/ath/ath6kl/init.c
index 57d7096..176b89c 100644
--- a/drivers/net/wireless/ath/ath6kl/init.c
+++ b/drivers/net/wireless/ath/ath6kl/init.c
@@ -32,7 +32,7 @@
 #include "hif-ops.h"
 #include "htc-ops.h"
 
-#include "laird.h"
+#include "../../laird_fips/laird.h"
 
 static const struct ath6kl_hw hw_list[] = {
 	{
diff --git a/drivers/net/wireless/ath/ath6kl/laird.h b/drivers/net/wireless/ath/ath6kl/laird.h
deleted file mode 100644
index 03464a5..0000000
--- a/drivers/net/wireless/ath/ath6kl/laird.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (c) 2012 Laird Technologies, Inc.
- */
-#ifndef LAIRD_DRIVER_H
-#define LAIRD_DRIVER_H
-
-// Laird version is 32bit value.  Parsed in the form w.x.y.z.  
-// increment y.z as needed for each change
-#define LAIRD_DRV_VERSION 0x03040006
-
-#ifdef LAIRD_FIPS
-#include <linux/etherdevice.h>
-#include "laird_common.h"
-
-extern bool fips_mode;
-extern const laird_register_data_t *laird_register_data;
-
-// receive: laird_skb_rx will return non-zero to let driver process packet
-static inline int  laird_skb_rx_prep(struct sk_buff *skb, pfn_laird_skb_rx_continue pfncb)
-{
-	if (!laird_register_data) return -1;
-	if (!laird_register_data->pfn_rx_prep) return -1;
-	return (*(laird_register_data->pfn_rx_prep))(skb, pfncb);
-}
-
-// transmit: prepare sk_buff -- encryption/encapsulation
-static inline int laird_skb_encrypt_prep(struct sk_buff *skb, struct net_device *dev, int wmm, pfn_laird_skb_tx_continue pfncb)
-{
-	if (!laird_register_data) return -1;
-	if (!laird_register_data->pfn_tx_prep) return -1;
-	return (*(laird_register_data->pfn_tx_prep))(skb, dev, wmm, pfncb);
-}
-
-// transmit: flow control
-static inline void laird_stop_queue(struct net_device *dev)
-{
-	if (!laird_register_data) return;
-	if (!laird_register_data->pfn_stop_queue) return;
-	return (*(laird_register_data->pfn_stop_queue))(dev);
-}
-
-static inline void laird_wake_queue(struct net_device *dev)
-{
-	if (!laird_register_data) return;
-	if (!laird_register_data->pfn_wake_queue) return;
-	(*(laird_register_data->pfn_wake_queue))(dev);
-}
-
-// key operations
-static inline void laird_addkey(struct net_device *ndev, u8 key_index,
-                         bool pairwise,
-                         const u8 *mac_addr,
-                         const u8 *key, int keylen,
-                         const u8 *seq, int seqlen)
-{
-	if (!laird_register_data) return;
-	if (!laird_register_data->pfn_addkey) return;
-	(*(laird_register_data->pfn_addkey))
-		(ndev, key_index, pairwise, mac_addr, key, keylen, seq, seqlen);
-}
-
-static inline void laird_delkey(struct net_device *ndev, u8 key_index)
-{
-	if (!laird_register_data) return;
-	if (!laird_register_data->pfn_delkey) return;
-	(*(laird_register_data->pfn_delkey))(ndev, key_index);
-}
-
-// bssid
-static inline void laird_setbssid(const u8 *bssid)
-{
-	if (!laird_register_data) return;
-	if (!laird_register_data->pfn_setbssid) return;
-	(*(laird_register_data->pfn_setbssid))(bssid);
-}
-
-// stopping the driver (rmmod) support
-static inline void laird_stop_txrx(void)
-{
-	if (!laird_register_data) return;
-	if (!laird_register_data->pfn_stop_txrx) return;
-	(*(laird_register_data->pfn_stop_txrx))();
-}
-
-#endif // LAIRD_FIPS
-#endif /* LAIRD_DRIVER_H */
diff --git a/drivers/net/wireless/ath/ath6kl/laird_common.h b/drivers/net/wireless/ath/ath6kl/laird_common.h
deleted file mode 100644
index a848610..0000000
--- a/drivers/net/wireless/ath/ath6kl/laird_common.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2012 Laird Technologies, Inc.
- */
-#ifndef LAIRD_COMMON_H
-#define LAIRD_COMMON_H
-
-#ifdef LAIRD_FIPS
-
-// res<0 to fail packet, else continue receive
-typedef void (*pfn_laird_skb_rx_continue)(struct sk_buff *skb, int res);
-
-// transmit: continue transmit after encryption/encapsulation
-// routine in driver
-// isfips=-1 to fail the skb
-// isfips=1 to indicate that skb has been encrypted/encapsulated in 802.11
-typedef int (*pfn_laird_skb_tx_continue)(
-    struct sk_buff *skb, struct net_device *dev, int isfips);
-
-// receive: laird_skb_rx will return non-zero to let driver process packet
-// return<0 if a failure occurs
-// 0 on success and pfncb will be called later (possibly not with same skb)
-typedef int (*pfn_laird_skb_rx_prep)(
-	struct sk_buff *skb, pfn_laird_skb_rx_continue pfncb);
-
-// transmit: prepare sk_buff -- encryption/encapsulation
-// return<0 if a failure occurs
-// 0 on success and pfncb will be called later (possibly not with same skb)
-typedef int (*pfn_laird_skb_tx_prep)(
-	struct sk_buff *skb, struct net_device *dev, int wmm,
-	pfn_laird_skb_tx_continue pfncb);
-
-// transmit: flow control
-typedef void (*pfn_laird_stop_queue)(struct net_device *dev);
-typedef void (*pfn_laird_wake_queue)(struct net_device *dev);
-
-// key operations
-typedef void (*pfn_laird_addkey)(struct net_device *ndev, u8 key_index,
-                         bool pairwise,
-                         const u8 *mac_addr,
-                         const u8 *key, int keylen,
-                         const u8 *seq, int seqlen);
-typedef void (*pfn_laird_delkey)(struct net_device *ndev, u8 key_index);
-
-// bssid
-typedef void (*pfn_laird_setbssid)(const u8 *bssid);
-
-// stopping the driver (rmmod) support
-typedef int (*pfn_laird_stop_txrx)(void);
-
-typedef struct {
-	pfn_laird_skb_rx_prep pfn_rx_prep;
-	pfn_laird_skb_tx_prep pfn_tx_prep;
-	pfn_laird_stop_queue pfn_stop_queue;
-	pfn_laird_wake_queue pfn_wake_queue;
-	pfn_laird_addkey pfn_addkey;
-	pfn_laird_delkey pfn_delkey;
-	pfn_laird_setbssid pfn_setbssid;
-	pfn_laird_stop_txrx pfn_stop_txrx;
-} laird_register_data_t;
-
-// external driver function that the laird module will call
-extern int ath6kl_laird_register(const laird_register_data_t *ptr);
-
-#endif // LAIRD_FIPS
-#endif /* LAIRD_COMMON_H */
-
diff --git a/drivers/net/wireless/ath/ath6kl/main.c b/drivers/net/wireless/ath/ath6kl/main.c
index 5f38b8e..032fe72 100644
--- a/drivers/net/wireless/ath/ath6kl/main.c
+++ b/drivers/net/wireless/ath/ath6kl/main.c
@@ -23,7 +23,7 @@
 #include "target.h"
 #include "debug.h"
 #include "wmiconfig.h"
-#include "laird.h"
+#include "../../laird_fips/laird.h"
 
 struct ath6kl_sta *ath6kl_find_sta(struct ath6kl_vif *vif, u8 *node_addr)
 {
diff --git a/drivers/net/wireless/ath/ath6kl/txrx.c b/drivers/net/wireless/ath/ath6kl/txrx.c
index dede2f2..999d79f 100644
--- a/drivers/net/wireless/ath/ath6kl/txrx.c
+++ b/drivers/net/wireless/ath/ath6kl/txrx.c
@@ -21,7 +21,7 @@
 #include "debug.h"
 #include "htc-ops.h"
 
-#include "laird.h"
+#include "../../laird_fips/laird.h"
 
 /*
  * tid - tid_mux0..tid_mux3
diff --git a/drivers/net/wireless/ath/ath6kl/wmi.c b/drivers/net/wireless/ath/ath6kl/wmi.c
index 7bcfc09..a468565 100644
--- a/drivers/net/wireless/ath/ath6kl/wmi.c
+++ b/drivers/net/wireless/ath/ath6kl/wmi.c
@@ -23,7 +23,7 @@
 #include "testmode.h"
 #include "../regd.h"
 #include "../regd_common.h"
-#include "laird.h"
+#include "../../laird_fips/laird.h"
 #include "wmiconfig.h"
 
 static int ath6kl_wmi_sync_point(struct wmi *wmi, u8 if_idx);
diff --git a/drivers/net/wireless/laird_fips/Kconfig b/drivers/net/wireless/laird_fips/Kconfig
new file mode 100644
index 0000000..f554ba2
--- /dev/null
+++ b/drivers/net/wireless/laird_fips/Kconfig
@@ -0,0 +1,5 @@
+config LAIRD_FIPS
+    tristate "Laird FIPS support"
+    depends on m
+    ---help---
+        Laird FIPS support.
diff --git a/drivers/net/wireless/laird_fips/Makefile b/drivers/net/wireless/laird_fips/Makefile
new file mode 100644
index 0000000..870b99e
--- /dev/null
+++ b/drivers/net/wireless/laird_fips/Makefile
@@ -0,0 +1,7 @@
+obj-$(CONFIG_LAIRD_FIPS) += sdc2u.o
+sdc2u-y := mod2urw.o moddebug.o
+
+obj-$(CONFIG_LAIRD_FIPS) += ath6kl_laird.o
+ath6kl_laird-y := laird.o laird_mod.o moddebug.o
+
+ccflags-y += -DLAIRD_FIPS
diff --git a/drivers/net/wireless/laird_fips/laird.c b/drivers/net/wireless/laird_fips/laird.c
new file mode 100644
index 0000000..564036a
--- /dev/null
+++ b/drivers/net/wireless/laird_fips/laird.c
@@ -0,0 +1,614 @@
+/*
+ * Copyright (c) 2013 Laird, Inc.
+ * Licensed under GPLv2.
+ */
+
+#include <linux/moduleparam.h>
+#include <linux/stat.h>
+#include "laird_i.h"
+#include "moddebug.h"
+#include "touser.h"
+
+#define ETHTYPE_IP     0x0800
+
+/* statistics for debugging */
+#define FIPS_STAT_INC(name) fips_stat_##name += 1
+#define FIPS_STAT_DEF(name) \
+	static uint fips_stat_##name; \
+	module_param(fips_stat_##name, uint, S_IRUGO)
+
+FIPS_STAT_DEF(rx_unencrypted_ok);
+FIPS_STAT_DEF(rx_decrypt_ok);
+FIPS_STAT_DEF(rx_no_memory);
+FIPS_STAT_DEF(rx_bad_packet);
+FIPS_STAT_DEF(rx_discard_amsdu);
+FIPS_STAT_DEF(rx_fragment);
+FIPS_STAT_DEF(rx_discard_unencrypted);
+FIPS_STAT_DEF(rx_decrypt_fail);
+FIPS_STAT_DEF(rx_decrypt_replay);
+FIPS_STAT_DEF(rx_decrypt_no_key);
+FIPS_STAT_DEF(rx_unspecified_error);
+
+FIPS_STAT_DEF(tx_unencrypted_ok);
+FIPS_STAT_DEF(tx_encrypt_ok);
+FIPS_STAT_DEF(tx_no_memory);
+FIPS_STAT_DEF(tx_bad_packet);
+FIPS_STAT_DEF(tx_unencrypted_fail);
+FIPS_STAT_DEF(tx_encrypt_fail);
+FIPS_STAT_DEF(tx_encrypt_no_key);
+FIPS_STAT_DEF(tx_unspecified_error);
+
+#if 0
+#define DEBUG_IDX(p,res) \
+	printk(KERN_ALERT "%s: index %d, line %d, status=%d\n", \
+	       __FUNCTION__, laird_skb_idx((p)), __LINE__, res);
+#define DEBUG_DUMP(skb) \
+	_printkhexs(__FUNCTION__, "skb", skb->data, skb->len);
+#else
+#define DEBUG_IDX(p,res)
+#define DEBUG_DUMP(skb)
+#endif
+
+typedef unsigned long long lrd_seq_t;
+
+static void error_stat_rx(int res)
+{
+	int *perr;
+	if (res >= 0) {
+		if (res == 0)
+			perr = &fips_stat_rx_decrypt_ok;
+		else if (res == 1)
+			perr = &fips_stat_rx_unencrypted_ok;
+		else
+			return;
+	} else {
+		switch (-res) {
+		case ENOMEM:
+		case E_LRD_RX_NO_MEMORY:
+			perr = &fips_stat_rx_no_memory;
+			break;
+		case E_LRD_RX_BAD_PACKET:
+			perr = &fips_stat_rx_bad_packet;
+			break;
+		case E_LRD_RX_DISCARD_AMSDU:
+			perr = &fips_stat_rx_discard_amsdu;
+			break;
+		case E_LRD_RX_FRAGMENT:
+			perr = &fips_stat_rx_fragment;
+			break;
+		case E_LRD_RX_DISCARD_UNENCRYPTED:
+			perr = &fips_stat_rx_discard_unencrypted;
+			break;
+		case E_LRD_RX_DECRYPT_FAIL:
+			perr = &fips_stat_rx_decrypt_fail;
+			break;
+		case E_LRD_RX_DECRYPT_REPLAY:
+			perr = &fips_stat_rx_decrypt_replay;
+			break;
+		case E_LRD_RX_DECRYPT_NO_KEY:
+			perr = &fips_stat_rx_decrypt_no_key;
+			break;
+		default:
+			perr = &fips_stat_rx_unspecified_error;
+			break;
+		}
+	}
+	*perr += 1;
+}
+
+static void error_stat_tx(int res)
+{
+	int *perr;
+	if (res >= 0) {
+		if (res == 0)
+			perr = &fips_stat_tx_encrypt_ok;
+		else if (res == 1)
+			perr = &fips_stat_tx_unencrypted_ok;
+		else
+			return;
+	} else {
+		switch (-res) {
+		case ENOMEM:
+		case E_LRD_TX_NO_MEMORY:
+			perr = &fips_stat_tx_no_memory;
+			break;
+		case E_LRD_TX_BAD_PACKET:
+			perr = &fips_stat_tx_bad_packet;
+			break;
+		case E_LRD_TX_UNENCRYPTED_FAIL:
+			perr = &fips_stat_tx_unencrypted_fail;
+			break;
+		case E_LRD_TX_ENCRYPT_FAIL:
+			perr = &fips_stat_tx_encrypt_fail;
+			break;
+		case E_LRD_TX_ENCRYPT_NO_KEY:
+			perr = &fips_stat_tx_encrypt_no_key;
+			break;
+		default:
+			perr = &fips_stat_tx_unspecified_error;
+			break;
+		}
+	}
+	*perr += 1;
+}
+
+#include "mod2urw.h"
+
+static struct {
+	struct sk_buff_head skbq_tx;
+	struct sk_buff_head skbq_rx;
+	int tx_stop_tasklet;
+	int stopping_txrx;	/* rmmod */
+} __glob;
+
+/* spinlock for protecting the queues */
+static DEFINE_SPINLOCK(skbq_tx_lock);
+static DEFINE_SPINLOCK(skbq_rx_lock);
+
+static DEFINE_MUTEX(mutex_stopping_txrx);
+
+static int cryp_counter;
+
+/* private data stored in socket buffer (using skb.cb[]) */
+typedef struct {
+	int res;
+	int done;
+	union {
+		pfn_laird_skb_rx_continue rxcontinue;
+		pfn_laird_skb_tx_continue txcontinue;
+		void *pfn;
+	} fn;
+	struct net_device *dev;
+	int up;			/* user priority (-1 is non-wmm) */
+	int idx;
+} laird_skb_priv_t;
+
+/* laird_skb_priv_set() - save private data in tx/rx skb
+ * use skb cb[] to store private data
+ * TBD: save original skb->cb
+ */
+static laird_skb_priv_t *laird_skb_priv_set(struct sk_buff *skb,
+					    void *pfn,
+					    struct net_device *dev, int up)
+{
+	laird_skb_priv_t *pd = (void *)skb->cb;
+	DEBUG_TRACE;
+	pd->res = -1;
+	pd->done = 0;
+	pd->fn.pfn = pfn;
+	pd->dev = dev;
+	pd->idx = cryp_counter++;
+	pd->up = up;
+	return pd;
+}
+
+static laird_skb_priv_t *laird_skb_priv_get(struct sk_buff *skb)
+{
+	laird_skb_priv_t *pd = (void *)skb->cb;
+	return pd;
+}
+
+static inline int laird_skb_idx(struct sk_buff *skb)
+{
+	laird_skb_priv_t *pd = (void *)skb->cb;
+	return pd->idx;
+}
+
+/* return true if both rx/txq are empty */
+static inline int __crypqs_empty(void)
+{
+	int res = 1;
+	DEBUG_TRACE;
+	spin_lock_bh(&skbq_tx_lock);
+	if (!skb_queue_empty(&__glob.skbq_tx))
+		res = 0;
+	spin_unlock_bh(&skbq_tx_lock);
+	spin_lock_bh(&skbq_rx_lock);
+	if (!skb_queue_empty(&__glob.skbq_rx))
+		res = 0;
+	spin_unlock_bh(&skbq_rx_lock);
+	return res;
+}
+
+/* called when exitting the driver (rmmod)
+ * note -- process level, not softirq/bh
+ */
+static int __cryp_wait_txrx_completed(void)
+{
+	DEBUG_TRACE;
+	mutex_lock(&mutex_stopping_txrx);
+	__glob.stopping_txrx = 1;
+	if (!__crypqs_empty()) {
+		/* wait for unlock when queues go empty */
+		if (mutex_lock_interruptible(&mutex_stopping_txrx)) {
+			return -1;
+		}
+	}
+	__glob.stopping_txrx = 0;
+	/* check if mutex is locked, and unlock it if it is locked */
+	if (mutex_is_locked(&mutex_stopping_txrx)) {
+		mutex_unlock(&mutex_stopping_txrx);
+	}
+	return 0;
+}
+
+/* if we are stopping txrx and queues are empty signal */
+static void inline __cryp_signal_if_txrx_completed(void)
+{
+	DEBUG_TRACE;
+	if (!__glob.stopping_txrx)
+		return;
+	if (!__crypqs_empty())
+		return;
+	if (mutex_is_locked(&mutex_stopping_txrx)) {
+		/* unlock the mutex to allow wait to finish */
+		mutex_unlock(&mutex_stopping_txrx);
+	}
+}
+
+#include "linux/interrupt.h"
+/* multiprocessor system can execute multiple tasklets simultaneously
+ * so only use one tasklet for both rx/tx processing
+ * tasklet for post-crypto operation processing
+ */
+static void __tasklet_exec(unsigned long);
+DECLARE_TASKLET(__tasklet, __tasklet_exec, 0);
+
+/* callback when sdclkm_xxx crypto operation completes */
+static void __callback_rx(void *din, int res);
+
+/* socket buffer encryption
+ * return: -1 failure, 0 processed, 1 driver to process
+ */
+int laird_skb_rx_prep(struct sk_buff *skb, pfn_laird_skb_rx_continue pfn)
+{
+	int res;
+	sdclkm_cb_t cbd;
+
+	DEBUG_TRACE;
+	if (__glob.stopping_txrx) {
+		return -1;
+	}
+	laird_skb_priv_set(skb, pfn, NULL, 0);
+	DEBUG_IDX(skb, 0);
+	DEBUG_DUMP(skb);
+	cbd.pfn = __callback_rx;
+	cbd.pdata = skb;
+	res = sdclkm_skb_receive(&cbd, skb);
+	if (res != 0) {
+		DEBUG_IDX(skb, res);
+		error_stat_rx(res);
+		return res;
+	}
+
+	/* put on rx queue */
+	spin_lock_bh(&skbq_rx_lock);
+	__skb_queue_tail(&__glob.skbq_rx, skb);
+	spin_unlock_bh(&skbq_rx_lock);
+
+	return 0;
+}
+
+/* callback called at process level when crypto operation completes
+ * note callback could be with different skb than originally submitted
+ */
+static void __callback_rx(void *din, int res)
+{
+	struct sk_buff *skb = din;
+	laird_skb_priv_t *pd = laird_skb_priv_get(skb);
+	DEBUG_IDX(skb, res);
+	DEBUG_DUMP(skb);
+	pd->res = res;
+	pd->done = 1;
+	tasklet_schedule(&__tasklet);
+	/* processing continues below in __tasklet_exec() */
+}
+
+/* callback when sdclkm_xxx crypto operation completes
+ * or directly in _part1() if operation fails/doesn't need crypto
+ */
+static void __callback_tx(void *din, int res);
+
+/* set the user priority (up) to be used, -1 for non-wmm packets */
+static int laird_skb_up(struct sk_buff *skb, int wmm)
+{
+	struct ethhdr *eth_hdr;
+	__be16 type;
+	int up;
+
+	if (!wmm) {
+		return -1;
+	}
+
+	up = 0;
+	if (skb->priority >= 256) {
+		up = skb->priority - 256;
+		if (up > 7)
+			up = 0;
+	}
+	if (skb->len >= sizeof(struct ethhdr) + 2) {
+		eth_hdr = (struct ethhdr *)skb->data;
+		type = eth_hdr->h_proto;
+		if (type == be16_to_cpu(ETHTYPE_IP)) {
+			u8 *iph = (u8 *) (eth_hdr + 1);
+			int upip;
+			if (iph[0] >> 4 == 4) {
+				upip = iph[1] >> 5;
+				if (upip > up)
+					up = upip;
+			}
+		}
+	}
+	return up;
+}
+
+/* socket buffer encryption */
+int laird_skb_tx_prep(struct sk_buff *skbin, struct net_device *dev, int wmm,
+		      pfn_laird_skb_tx_continue pfn)
+{
+	int res;
+	sdclkm_cb_t cbd;
+	struct sk_buff *skb = skbin;
+	laird_skb_priv_t *pd;
+
+	if (__glob.stopping_txrx) {
+		return -1;
+	}
+	if (skb->len < sizeof(struct ethhdr)) {
+		return -1;
+	}
+
+	/* TBD: move this into the other routine... */
+	if (skb_cloned(skb) || skb_tailroom(skb) < 8) {
+		/* tailroom is too small -- try making a copy with more tailroom */
+		skb = skb_copy_expand(skb, skb_headroom(skb), 8, GFP_ATOMIC);
+		if (!skb) {
+			skb = skbin;
+			res = -ENOMEM;
+			goto fail;
+		}
+	}
+
+	pd = laird_skb_priv_set(skb, pfn, dev, laird_skb_up(skb, wmm));
+	DEBUG_IDX(skb, 0);
+	DEBUG_DUMP(skb);
+	cbd.pfn = __callback_tx;
+	cbd.pdata = skb;
+	res = sdclkm_skb_transmit(&cbd, skb, &pd->up);
+	DEBUG_TRACE;
+	if (res != 0) {
+		goto fail;
+	}
+
+	/* put on skb queue */
+	spin_lock_bh(&skbq_tx_lock);
+	__skb_queue_tail(&__glob.skbq_tx, skb);
+	spin_unlock_bh(&skbq_tx_lock);
+
+	res = 0; /* success */
+fail:
+	if (res) {
+		DEBUG_IDX(skb, res);
+	}
+	if (skb != skbin) {
+		/* if we made a copy of the skb...
+		 * if failure, free the new skb; if success, free the input skb
+		 */
+        dev_kfree_skb(res ? skb : skbin);
+	}
+	if (res != 0)
+		error_stat_tx(res);
+	return res;
+}
+
+/* callback called at process level when crypto operation completes
+ * note callback could be with different skb than originally submitted
+ */
+static void __callback_tx(void *din, int res)
+{
+	struct sk_buff *skb = din;
+	laird_skb_priv_t *pd = laird_skb_priv_get(skb);
+	DEBUG_IDX(skb, res);
+	DEBUG_DUMP(skb);
+	pd->res = res;
+	pd->done = 1;
+	tasklet_schedule(&__tasklet);
+	/* processing continues below in __tasklet_exec() */
+}
+
+/* a single tasklet processes both receive and transmit
+ * don't want two tasklets executing simultaneously on multi-processor
+ * tasklet to complete skb processing and pass skb back to driver
+ */
+static void __tasklet_exec(unsigned long unused)
+{
+	struct sk_buff *skb;
+	laird_skb_priv_t *pd;
+
+	DEBUG_TRACE;
+	spin_lock_bh(&skbq_tx_lock);
+	while (1) {
+		if (__glob.tx_stop_tasklet) {
+			/* flow control has stopped transmit packet submission */
+			break;
+		}
+		skb = skb_peek(&__glob.skbq_tx);
+		if (!skb)
+			break;
+		pd = laird_skb_priv_get(skb);
+		if (!pd->done)
+			break;
+		(void)skb_dequeue(&__glob.skbq_tx);
+		DEBUG_IDX(skb, pd->res);
+		error_stat_tx(pd->res);
+		spin_unlock_bh(&skbq_tx_lock);
+		(*(pd->fn.txcontinue)) (skb, pd->dev, pd->res < 0 ? -1 : 1);
+		spin_lock_bh(&skbq_tx_lock);
+	}
+	spin_unlock_bh(&skbq_tx_lock);
+
+	spin_lock_bh(&skbq_rx_lock);
+	while (1) {
+		skb = skb_peek(&__glob.skbq_rx);
+		if (!skb)
+			break;
+		pd = laird_skb_priv_get(skb);
+		if (!pd->done)
+			break;
+		(void)skb_dequeue(&__glob.skbq_rx);
+		DEBUG_IDX(skb, pd->res);
+		error_stat_rx(pd->res);
+		spin_unlock_bh(&skbq_rx_lock);
+		(*(pd->fn.rxcontinue)) (skb, pd->res < 0 ? -1 : 1);
+		spin_lock_bh(&skbq_rx_lock);
+	}
+	spin_unlock_bh(&skbq_rx_lock);
+
+	__cryp_signal_if_txrx_completed();
+}
+
+/* transmit flow control
+ * stop the fips tasklet from submitting transmit packets
+ */
+static DEFINE_SPINLOCK(tx_stop_tasklet_lock);
+void laird_stop_queue(struct net_device *dev)
+{
+	DEBUG_TRACE;
+	spin_lock_bh(&tx_stop_tasklet_lock);
+	__glob.tx_stop_tasklet = 1;
+	spin_unlock_bh(&tx_stop_tasklet_lock);
+}
+
+/* enable the fips tasklet to submit transmit packets */
+void laird_wake_queue(struct net_device *dev)
+{
+	int val;
+	DEBUG_TRACE;
+	spin_lock_bh(&tx_stop_tasklet_lock);
+	val = __glob.tx_stop_tasklet;
+	__glob.tx_stop_tasklet = 0;
+	spin_unlock_bh(&tx_stop_tasklet_lock);
+	if (val) {
+		/* transmit was unblocked */
+		DEBUG_TRACE;
+		tasklet_schedule(&__tasklet);
+	}
+}
+
+/* callback called at process level when crypto operation completes */
+static void __callback_del_data(void *din, int res)
+{
+	DEBUG_TRACE;
+	kfree(din);
+	(void)res;
+}
+
+/* note, this routine does not return a status as
+ * the operation has not completed when this routine returns
+ */
+void laird_addkey(struct net_device *ndev,
+		  u8 key_index, bool pairwise,
+		  const u8 * mac_addr,
+		  const u8 * key, int keylen, const u8 * seq, int seqlen)
+{
+	int res;
+	sdclkm_cb_t cbd;
+	struct {
+		u32 key_index;
+		u8 key[16];
+		u8 seq[8];
+	} *p;
+
+	DEBUG_TRACE;
+
+	if (key_index >= 4)
+		return;
+	if (keylen != 16 && keylen != 0)
+		return;
+	if (seqlen > 8)
+		return;
+
+	/* store data in allocated memory */
+	p = kmalloc(sizeof(*p), GFP_ATOMIC);
+	if (!p) {
+		printk(KERN_ALERT "%s: alloc failed\n", __FUNCTION__);
+		return;
+	}
+	p->key_index = key_index | (pairwise ? (1UL >> 31) : 0);
+	if (keylen)
+		memcpy(p->key, key, keylen);
+	if (seqlen)
+		memcpy(p->seq, seq, seqlen);
+
+	cbd.pfn = __callback_del_data;
+	cbd.pdata = p;
+
+	res = sdclkm_addkey(&cbd,
+			    &p->key_index, p->key, keylen, p->seq, seqlen);
+	if (res != 0) {
+		kfree(p);
+	}
+
+}
+
+void laird_delkey(struct net_device *ndev, u8 key_index)
+{
+	DEBUG_TRACE;
+	laird_addkey(ndev, key_index, 0, NULL, NULL, 0, NULL, 0);
+}
+
+void laird_setbssid(const u8 * bssid)
+{
+	int res;
+	sdclkm_cb_t cbd;
+	struct {
+		u8 bssid[6];
+	} *p;
+
+	DEBUG_TRACE;
+	_printkhexs(__FUNCTION__, "bssid", bssid, bssid ? 6 : 0);
+
+	/* store data in allocated memory */
+	p = kmalloc(sizeof(*p), GFP_ATOMIC);
+	if (!p) {
+		printk(KERN_ALERT "%s: alloc failed\n", __FUNCTION__);
+		return;
+	}
+	if (bssid)
+		memcpy(p->bssid, bssid, 6);
+
+	cbd.pfn = __callback_del_data;
+	cbd.pdata = p;
+
+	res = sdclkm_setbssid(&cbd, p->bssid, bssid ? 6 : 0);
+	if (res != 0) {
+		kfree(p);
+	}
+}
+
+/* stopping the driver (rmmod) to wait for cryp queues (txrx) to complete */
+int laird_stop_txrx(void)
+{
+	int res;
+	DEBUG_TRACE;
+	res = __cryp_wait_txrx_completed();
+	return res;
+}
+
+int laird_txrx_init(void)
+{
+	skb_queue_head_init(&__glob.skbq_tx);
+	skb_queue_head_init(&__glob.skbq_rx);
+	return 0;
+}
+
+const laird_register_data_t register_data = {
+	.pfn_rx_prep = &laird_skb_rx_prep,
+	.pfn_tx_prep = &laird_skb_tx_prep,
+	.pfn_stop_queue = &laird_stop_queue,
+	.pfn_wake_queue = &laird_wake_queue,
+	.pfn_addkey = &laird_addkey,
+	.pfn_delkey = &laird_delkey,
+	.pfn_setbssid = &laird_setbssid,
+	.pfn_stop_txrx = &laird_stop_txrx
+};
diff --git a/drivers/net/wireless/laird_fips/laird.h b/drivers/net/wireless/laird_fips/laird.h
new file mode 100644
index 0000000..7153f5b
--- /dev/null
+++ b/drivers/net/wireless/laird_fips/laird.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2013 Laird, Inc.
+ * Licensed under GPLv2.
+ */
+
+#ifndef LAIRD_DRIVER_H
+#define LAIRD_DRIVER_H
+
+/* Laird version is 32bit value.  Parsed in the form w.x.y.z.
+ * increment y.z as needed for each change
+ */
+#define LAIRD_DRV_VERSION 0x03040006
+
+#ifdef LAIRD_FIPS
+#include <linux/etherdevice.h>
+#include "laird_common.h"
+
+extern bool fips_mode;
+extern const laird_register_data_t *laird_register_data;
+
+/* receive: laird_skb_rx will return non-zero to let driver process packet */
+static inline int laird_skb_rx_prep(struct sk_buff *skb,
+				    pfn_laird_skb_rx_continue pfncb)
+{
+	if (!laird_register_data)
+		return -1;
+	if (!laird_register_data->pfn_rx_prep)
+		return -1;
+	return (*(laird_register_data->pfn_rx_prep)) (skb, pfncb);
+}
+
+/* transmit: prepare sk_buff -- encryption/encapsulation */
+static inline int laird_skb_encrypt_prep(struct sk_buff *skb,
+					 struct net_device *dev, int wmm,
+					 pfn_laird_skb_tx_continue pfncb)
+{
+	if (!laird_register_data)
+		return -1;
+	if (!laird_register_data->pfn_tx_prep)
+		return -1;
+	return (*(laird_register_data->pfn_tx_prep)) (skb, dev, wmm, pfncb);
+}
+
+/* transmit: flow control */
+static inline void laird_stop_queue(struct net_device *dev)
+{
+	if (!laird_register_data)
+		return;
+	if (!laird_register_data->pfn_stop_queue)
+		return;
+	return (*(laird_register_data->pfn_stop_queue)) (dev);
+}
+
+static inline void laird_wake_queue(struct net_device *dev)
+{
+	if (!laird_register_data)
+		return;
+	if (!laird_register_data->pfn_wake_queue)
+		return;
+	(*(laird_register_data->pfn_wake_queue)) (dev);
+}
+
+/* key operations */
+static inline void laird_addkey(struct net_device *ndev, u8 key_index,
+				bool pairwise,
+				const u8 * mac_addr,
+				const u8 * key, int keylen,
+				const u8 * seq, int seqlen)
+{
+	if (!laird_register_data)
+		return;
+	if (!laird_register_data->pfn_addkey)
+		return;
+	(*(laird_register_data->pfn_addkey))
+	    (ndev, key_index, pairwise, mac_addr, key, keylen, seq, seqlen);
+}
+
+static inline void laird_delkey(struct net_device *ndev, u8 key_index)
+{
+	if (!laird_register_data)
+		return;
+	if (!laird_register_data->pfn_delkey)
+		return;
+	(*(laird_register_data->pfn_delkey)) (ndev, key_index);
+}
+
+/* bssid */
+static inline void laird_setbssid(const u8 * bssid)
+{
+	if (!laird_register_data)
+		return;
+	if (!laird_register_data->pfn_setbssid)
+		return;
+	(*(laird_register_data->pfn_setbssid)) (bssid);
+}
+
+/* stopping the driver (rmmod) support */
+static inline void laird_stop_txrx(void)
+{
+	if (!laird_register_data)
+		return;
+	if (!laird_register_data->pfn_stop_txrx)
+		return;
+	(*(laird_register_data->pfn_stop_txrx)) ();
+}
+
+#endif /* LAIRD_FIPS */
+#endif /* LAIRD_DRIVER_H */
diff --git a/drivers/net/wireless/laird_fips/laird_common.h b/drivers/net/wireless/laird_fips/laird_common.h
new file mode 100644
index 0000000..5d766f7
--- /dev/null
+++ b/drivers/net/wireless/laird_fips/laird_common.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2013 Laird, Inc.
+ * Licensed under GPLv2.
+ */
+
+#ifndef LAIRD_COMMON_H
+#define LAIRD_COMMON_H
+
+#ifdef LAIRD_FIPS
+
+/* res<0 to fail packet, else continue receive */
+typedef void (*pfn_laird_skb_rx_continue) (struct sk_buff * skb, int res);
+
+/* transmit: continue transmit after encryption/encapsulation
+ * routine in driver
+ * isfips=-1 to fail the skb
+ * isfips=1 to indicate that skb has been encrypted/encapsulated in 802.11
+ */
+typedef int (*pfn_laird_skb_tx_continue) (struct sk_buff * skb,
+					  struct net_device * dev, int isfips);
+
+/* receive: laird_skb_rx will return non-zero to let driver process packet
+ * return<0 if a failure occurs
+ * 0 on success and pfncb will be called later (possibly not with same skb)
+ */
+typedef int (*pfn_laird_skb_rx_prep) (struct sk_buff * skb,
+				      pfn_laird_skb_rx_continue pfncb);
+
+/* transmit: prepare sk_buff -- encryption/encapsulation
+ * return<0 if a failure occurs
+ * 0 on success and pfncb will be called later (possibly not with same skb)
+ */
+typedef int (*pfn_laird_skb_tx_prep) (struct sk_buff * skb,
+				      struct net_device * dev, int wmm,
+				      pfn_laird_skb_tx_continue pfncb);
+
+/* transmit: flow control */
+typedef void (*pfn_laird_stop_queue) (struct net_device * dev);
+typedef void (*pfn_laird_wake_queue) (struct net_device * dev);
+
+/* key operations */
+typedef void (*pfn_laird_addkey) (struct net_device * ndev, u8 key_index,
+				  bool pairwise,
+				  const u8 * mac_addr,
+				  const u8 * key, int keylen,
+				  const u8 * seq, int seqlen);
+typedef void (*pfn_laird_delkey) (struct net_device * ndev, u8 key_index);
+
+/* bssid */
+typedef void (*pfn_laird_setbssid) (const u8 * bssid);
+
+/* stopping the driver (rmmod) support */
+typedef int (*pfn_laird_stop_txrx) (void);
+
+typedef struct {
+	pfn_laird_skb_rx_prep pfn_rx_prep;
+	pfn_laird_skb_tx_prep pfn_tx_prep;
+	pfn_laird_stop_queue pfn_stop_queue;
+	pfn_laird_wake_queue pfn_wake_queue;
+	pfn_laird_addkey pfn_addkey;
+	pfn_laird_delkey pfn_delkey;
+	pfn_laird_setbssid pfn_setbssid;
+	pfn_laird_stop_txrx pfn_stop_txrx;
+} laird_register_data_t;
+
+/* external driver function that the laird module will call */
+extern int ath6kl_laird_register(const laird_register_data_t * ptr);
+
+#endif /* LAIRD_FIPS */
+#endif /* LAIRD_COMMON_H */
diff --git a/drivers/net/wireless/laird_fips/laird_i.h b/drivers/net/wireless/laird_fips/laird_i.h
new file mode 100644
index 0000000..73f3663
--- /dev/null
+++ b/drivers/net/wireless/laird_fips/laird_i.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2013 Laird, Inc.
+ * Licensed under GPLv2.
+ */
+
+#ifndef LAIRD_I_H
+#define LAIRD_I_H
+
+#include <linux/etherdevice.h>
+#include "laird_common.h"
+
+struct laird_wlanhdr {
+	u8 fc[2];
+#define FC0_FTYPE      (3<<2)
+#define FC0_FTYPE_DATA (2<<2)
+#define FC0_STYPE_QOS  (1<<7)
+#define FC1_TODS       (1<<0)
+#define FC1_FROMDS     (1<<1)
+#define FC1_MOREFRAGS  (1<<2)
+#define FC1_PROTECTED  (1<<6)
+	__le16 dur;
+	u8 addr1[6];
+	u8 addr2[6];
+	u8 addr3[6];
+	u8 seq[2];
+#define SEQ0_FRAG (0xF)
+} __packed;
+
+void laird_printhexs(const char *psz, const char *pf, const void *buf, int len);
+int ecr_wlanhdr_len(struct laird_wlanhdr *hdr);
+
+/* stopping the driver (rmmod) support */
+extern int laird_stop_txrx(void);
+extern const laird_register_data_t register_data;
+
+#endif /* LAIRD_I_H */
diff --git a/drivers/net/wireless/laird_fips/laird_mod.c b/drivers/net/wireless/laird_fips/laird_mod.c
new file mode 100644
index 0000000..cf4fd59
--- /dev/null
+++ b/drivers/net/wireless/laird_fips/laird_mod.c
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2013 Laird, Inc.
+ * Licensed under GPLv2.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include "laird_i.h"
+
+extern int laird_txrx_init(void);
+
+#define VERSION_STRING "1.0"
+
+/* initialization */
+static int __init laird_init(void)
+{
+	int ret;
+	printk(KERN_INFO "ath6kl_laird.ko: version %s\n", VERSION_STRING);
+	ret = laird_txrx_init();
+	if (ret) {
+		printk(KERN_ALERT "laird_txrx_init() return error (%d)\n",
+		       -ret);
+		return -1;
+	}
+	/* register with driver */
+	if (ath6kl_laird_register(&register_data) < 0)
+		return -1;
+	return 0;
+}
+
+/* cleanup and exit */
+static void __exit laird_exit(void)
+{
+	/* clear the driver specific registration */
+	(void)ath6kl_laird_register(NULL);
+	/* stop/flush transmit/receive for unloading */
+	laird_stop_txrx();
+}
+
+module_init(laird_init);
+module_exit(laird_exit);
+
+MODULE_AUTHOR("Laird");
+MODULE_DESCRIPTION("Laird fips support");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(VERSION_STRING);
diff --git a/drivers/net/wireless/laird_fips/mod2urw.c b/drivers/net/wireless/laird_fips/mod2urw.c
new file mode 100644
index 0000000..5f75512
--- /dev/null
+++ b/drivers/net/wireless/laird_fips/mod2urw.c
@@ -0,0 +1,802 @@
+/*
+ * Copyright (c) 2013 Laird, Inc.
+ * Licensed under GPLv2.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* size_t */
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h>	/* O_ACCMODE */
+#include <linux/seq_file.h>
+#include <linux/cdev.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+
+#include <asm/system.h>		/* cli(), *_flags */
+#include <asm/uaccess.h>	/* copy_*_user */
+
+#include "laird_i.h"
+#include "moddebug.h"
+
+static int cmd_to_host(char __user * buf, size_t count);
+static int cmd_from_host(const char __user * buf, size_t count);
+static void cmd_set_state(int enabled);
+
+/*======================================================================*/
+static int mod2urw_close(struct inode *inode, struct file *filp)
+{
+	cmd_set_state(0);
+	return 0;
+}
+
+static int mod2urw_open(struct inode *inode, struct file *filp)
+{
+	/* TBD: prevent multiple instances */
+	cmd_set_state(1);
+	return 0;
+}
+
+static DECLARE_WAIT_QUEUE_HEAD(wq_read);
+static unsigned short mod2urw_read_ready;
+
+static void __mod2urw_read_wake(void)
+{
+	DEBUG_TRACE;
+	mod2urw_read_ready = 1;
+	wake_up_interruptible(&wq_read);	/* update poll status */
+}
+
+static ssize_t mod2urw_read(struct file *filp, char __user * buf, size_t count,
+		       loff_t * f_pos)
+{
+	int res;
+	/* TBD: device mutex ? */
+	DEBUG_TRACE;
+	while (1) {
+		mod2urw_read_ready = 0;
+		res = cmd_to_host(buf, count);
+		if (res != 0)
+			break;
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		if (wait_event_interruptible(wq_read, mod2urw_read_ready))
+			return -ERESTARTSYS;
+	}
+	return res;
+}
+
+static ssize_t mod2urw_write(struct file *filp, const char __user * buf,
+			size_t count, loff_t * f_pos)
+{
+	DEBUG_TRACE;
+	cmd_from_host(buf, count);
+	return count;
+}
+
+static const struct file_operations mod2urw_fops = {
+	.open = mod2urw_open,
+	.release = mod2urw_close,
+	.write = mod2urw_write,
+	.read = mod2urw_read,
+};
+
+/* use device file /dev/sdc2u0 */
+static int mod2urw_major = 0;
+static int mod2urw_minor = 0;
+static int mod2urw_nr_devs = 1;	/* number of bare devices */
+struct mod2urw_dev {
+	struct cdev cdev;	/* Char device structure */
+};
+static struct mod2urw_dev *mod2urw_devices;	/* allocated in mod2urw_init_module */
+#define MYDEVSTR	"sdc2u"
+
+/*
+ * The cleanup function is used to handle initialization failures as well.
+ * Thefore, it must be careful to work correctly even if some of the items
+ * have not been initialized
+ */
+void mod2urw_cleanup_module(void)
+{
+	int i;
+	dev_t devno = MKDEV(mod2urw_major, mod2urw_minor);
+
+	DEBUG_TRACE;
+	/* Get rid of our char dev entries */
+	if (mod2urw_devices) {
+		for (i = 0; i < mod2urw_nr_devs; i++) {
+			cdev_del(&mod2urw_devices[i].cdev);
+		}
+		kfree(mod2urw_devices);
+	}
+
+	/* cleanup_module is never called if registering failed */
+	unregister_chrdev_region(devno, mod2urw_nr_devs);
+}
+
+/*
+ * Set up the char_dev structure for this device.
+ */
+static void mod2urw_setup_cdev(struct mod2urw_dev *dev, int index)
+{
+	int err, devno = MKDEV(mod2urw_major, mod2urw_minor + index);
+
+	DEBUG_TRACE;
+	cdev_init(&dev->cdev, &mod2urw_fops);
+	dev->cdev.owner = THIS_MODULE;
+	dev->cdev.ops = &mod2urw_fops;
+	err = cdev_add(&dev->cdev, devno, 1);
+	/* Fail gracefully if need be */
+	if (err)
+		printk(KERN_NOTICE "Error %d adding mydev%d", err, index);
+}
+
+static int mod2urw_init_module(void)
+{
+	int result, i;
+	dev_t dev = 0;
+	DEBUG_TRACE;
+
+	/*
+	 * Get a range of minor numbers to work with, asking for a dynamic
+	 * major unless directed otherwise at load time.
+	 */
+	if (mod2urw_major) {
+		dev = MKDEV(mod2urw_major, mod2urw_minor);
+		result = register_chrdev_region(dev, mod2urw_nr_devs, MYDEVSTR);
+	} else {
+		result = alloc_chrdev_region(&dev, mod2urw_minor, mod2urw_nr_devs,
+					     MYDEVSTR);
+		mod2urw_major = MAJOR(dev);
+	}
+	if (result < 0) {
+		printk(KERN_WARNING "mydev: can't get major %d\n", mod2urw_major);
+		return result;
+	}
+
+	/*
+	 * allocate the devices -- we can't have them static, as the number
+	 * can be specified at load time
+	 */
+	mod2urw_devices = kmalloc(mod2urw_nr_devs * sizeof(struct mod2urw_dev), GFP_KERNEL);
+	if (!mod2urw_devices) {
+		result = -ENOMEM;
+		goto fail;	/* Make this more graceful */
+	}
+	memset(mod2urw_devices, 0, mod2urw_nr_devs * sizeof(struct mod2urw_dev));
+
+	/* Initialize each device. */
+	for (i = 0; i < mod2urw_nr_devs; i++) {
+		mod2urw_setup_cdev(&mod2urw_devices[i], i);
+	}
+
+	return 0;		/* succeed */
+
+fail:
+	mod2urw_cleanup_module();
+	return result;
+}
+
+/* driver register data -- pointer to functions */
+#include "touser.h"
+#include "mod2urw.h"
+
+#define VERSION_STRING "1.0"
+
+/* initialization */
+static int __init sdclkm_init(void)
+{
+	DEBUG_TRACE;
+	printk(KERN_INFO "%s.ko: version %s\n", MYDEVSTR, VERSION_STRING);
+	if (mod2urw_init_module() < 0)
+		goto failure;
+	return 0;
+failure:
+	return -1;
+}
+
+/* cleanup and exit */
+static void __exit sdclkm_exit(void)
+{
+	DEBUG_TRACE;
+	mod2urw_cleanup_module();
+}
+
+module_init(sdclkm_init);
+module_exit(sdclkm_exit);
+
+MODULE_AUTHOR("Laird");
+MODULE_DESCRIPTION("Laird fips userland interface");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(VERSION_STRING);
+
+/*======================================================================*/
+/*======================================================================*/
+
+/* defines the cmd -- number of parameters and handling for each
+ * this will be constant for a given command
+ */
+typedef struct {		/* command control handling */
+	int cmd;
+	int numit;
+	int flags[MAXIT];
+#define ITEM_TO_HOST 1
+#define ITEM_FROM_HOST 2
+#define ITEM_SKB 4
+} cmd_def_t;
+
+typedef struct {
+	void *p;		/* pointer to item */
+	int len;		/* length of item */
+	void *skb;		/* for socket buffers passed to/from user space */
+} item_ptr_t;
+
+/* command control */
+typedef struct cmd_ctl_s {
+	cmd_hdr_t hdr;		/* command header to pass to user space */
+	int hdr_len;		/* length of command header adjusted for numitems */
+	const cmd_def_t *def;
+	item_ptr_t itp[MAXIT];	/* pointers to the kernel data items */
+	sdclkm_cb_t cbd;	/* callback function and callback data */
+	struct cmd_ctl_s *next;
+} cmd_ctl_t;
+
+/* queue of cmd submitted for processing */
+static struct {
+	int enabled;		/* set when user-space app registers */
+	cmd_ctl_t *active;
+	cmd_ctl_t *first;
+	cmd_ctl_t *last;
+} cmd_glob;
+
+/* spinlock to protect the queue of pending requests */
+static DEFINE_SPINLOCK(cmdq_lock);
+
+static inline cmd_ctl_t *cmd_ctl_alloc(void)
+{
+	cmd_ctl_t *ctl;		/* command control */
+	ctl = kmalloc(sizeof(*ctl), GFP_ATOMIC);
+	return ctl;
+}
+
+static inline void cmd_ctl_free(cmd_ctl_t * ctl)
+{
+	kfree(ctl);
+}
+
+/* note, this function may be called at process, or bottom half level
+ * called at bh level from driver transmit/receive processing
+ */
+static int cmd_ctl_submit(cmd_ctl_t * ctl)
+{
+	DEBUG_TRACE;
+	ctl->next = NULL;
+	spin_lock_bh(&cmdq_lock);
+	if (!cmd_glob.enabled) {
+		/* no user-space module to process command, fail it */
+		spin_unlock_bh(&cmdq_lock);
+		cmd_ctl_free(ctl);
+		return -1;
+	}
+	if (cmd_glob.last) {
+		cmd_glob.last->next = ctl;
+	} else {
+		cmd_glob.first = ctl;
+	}
+	cmd_glob.last = ctl;
+	spin_unlock_bh(&cmdq_lock);
+	__mod2urw_read_wake();
+	return 0;
+}
+
+/* called only at process level in read */
+static cmd_ctl_t *cmd_ctl_get_next(void)
+{
+	cmd_ctl_t *ctl;
+	DEBUG_TRACE;
+	spin_lock_bh(&cmdq_lock);
+	ctl = cmd_glob.first;
+	if (ctl) {
+		cmd_glob.first = ctl->next;
+		if (cmd_glob.first == NULL) {
+			cmd_glob.last = NULL;
+		}
+	}
+	cmd_glob.active = ctl;
+	spin_unlock_bh(&cmdq_lock);
+	return ctl;
+}
+
+/* called only at process level in write */
+static cmd_ctl_t *cmd_ctl_get_active(void)
+{
+	DEBUG_TRACE;
+	/* don't need spinlock here */
+	return cmd_glob.active;
+}
+
+static void cmd_ctl_free_active(void)
+{
+	DEBUG_TRACE;
+	if (cmd_glob.active) {
+		cmd_ctl_free(cmd_glob.active);
+		cmd_glob.active = NULL;
+	}
+}
+
+/* copies available command into host buffer
+ * returns total length of data, -Exxx on fail, 0 if no data available
+ */
+static int cmd_to_host(char __user * buf, size_t count)
+{
+	cmd_ctl_t *ctl;
+	cmd_hdr_t *hdr;
+	const cmd_def_t *def;
+	int i;
+	int err = 0;
+
+	DEBUG_TRACE;
+	ctl = cmd_ctl_get_next();
+	if (!ctl) {
+		return 0;	/* no command to pass to user space */
+	}
+
+	def = ctl->def;
+	hdr = &ctl->hdr;
+	if (count < hdr->len) {
+		printk(KERN_ALERT "%s: buffer too small\n", __FUNCTION__);
+		return -EFBIG;	/* insufficient space */
+	}
+
+	/* copy header to the buffer */
+	err = copy_to_user((void __user *)buf, hdr, ctl->hdr_len);
+	/* copy each data item to the buffer */
+	for (i = 0; i < def->numit && !err; i++) {
+		if ((def->flags[i] & ITEM_TO_HOST) == 0)
+			continue;
+		if (hdr->it[i].len == 0)
+			continue;
+		err = copy_to_user((void __user *)&buf[hdr->it[i].offset],
+				   ctl->itp[i].p, hdr->it[i].len);
+	}
+	/* return length of the data */
+	if (err)
+		return -EFAULT;
+	return hdr->len;
+}
+
+static inline int __skb_from_user(struct sk_buff *skb,
+				  const char __user * buf,
+				  int oldoff, int newoff, int newlen)
+{
+	int headchg, tailchg;
+	int headroom, tailroom;
+	headchg = oldoff - newoff;
+	tailchg = newlen - skb->len - headchg;
+
+	DEBUG_TRACE;
+	headroom = skb_headroom(skb);
+	tailroom = skb_tailroom(skb);
+	if (headroom < headchg) {
+		printk(KERN_ALERT "\n<%s: headroom %d, need %d>\n",
+		       __FUNCTION__, headroom, headchg);
+		return -1;
+	}
+
+	if (skb_tailroom(skb) < tailchg) {
+		printk(KERN_ALERT "\n<%s: tailroom %d, need %d>\n",
+		       __FUNCTION__, tailroom, tailchg);
+		return -1;
+	}
+	if (headchg > 0) {
+		skb_push(skb, headchg);		/* add to head */
+	} else if (headchg < 0) {
+		skb_pull(skb, -headchg);	/* remove from head */
+	}
+	if (tailchg > 0) {
+		skb_put(skb, tailchg);		/* add to tail */
+	} else if (tailchg < 0) {
+		skb_trim(skb, newlen);		/* remove from tail */
+	}
+	return copy_from_user(skb->data, (void __user *)&buf[newoff], newlen);
+}
+
+static int cmd_from_host(const char __user * buf, size_t count)
+{
+	cmd_ctl_t *ctl;
+	cmd_hdr_t *hdr;
+	const cmd_def_t *def;
+	cmd_hdr_t cin;
+	int i;
+	int res;
+	int err = 0;
+
+	DEBUG_TRACE;
+	ctl = cmd_ctl_get_active();
+	if (!ctl) {
+		printk(KERN_ALERT "%s: ERROR!! unsolicited cmd\n",
+		       __FUNCTION__);
+		return 0;
+	}
+
+	def = ctl->def;
+	hdr = &ctl->hdr;
+	if (count != hdr->len) {
+		printk(KERN_ALERT "%s: ERROR!! incorrect response length\n",
+		       __FUNCTION__);
+		printk(KERN_ALERT "%s: len %d; but, expected %d\n",
+		       __FUNCTION__, count, hdr->len);
+		res = -1;
+	} else {
+		/* copy the result from the header */
+		err = copy_from_user(&cin, (void __user *)buf, ctl->hdr_len);
+		res = cin.res;
+		/* copy each data item from the buffer */
+		for (i = 0; i < def->numit && !err; i++) {
+			if ((def->flags[i] & ITEM_FROM_HOST) == 0)
+				continue;
+			if (hdr->it[i].len == 0)
+				continue;
+			if ((def->flags[i] & ITEM_SKB) != 0) {
+				/* both offset and length may have changed... */
+				err = __skb_from_user(ctl->itp[i].skb, buf,
+						      hdr->it[i].offset,
+						      cin.it[i].offset,
+						      cin.it[i].len);
+				/* TBD: if necessary to change skb, then must pass back in ctl->cbd.pdata */
+				continue;
+			}
+			err = copy_from_user(ctl->itp[i].p,
+					     (void __user *)&buf[hdr->it[i].
+								 offset],
+					     hdr->it[i].len);
+		}
+	}
+	/* if an error occurred, ensure failure result is passed back */
+	if (err)
+		res = -1;
+	/* call the callback function to indicate command is complete */
+	(*(ctl->cbd.pfn)) (ctl->cbd.pdata, res);
+	/* release the command control structure */
+	cmd_ctl_free_active();
+	return 0;
+}
+
+/* user-space app has exitted -- fail all commands */
+static void cmd_fail_all(void)
+{
+	cmd_ctl_t *ctl;
+	DEBUG_TRACE;
+	do {
+		ctl = cmd_ctl_get_active();
+		if (!ctl)
+			ctl = cmd_ctl_get_next();
+		if (ctl) {
+			printk(KERN_ALERT "%s: cancel in progress command\n",
+			       __FUNCTION__);
+			/* call the callback function to indicate command is complete */
+			(*(ctl->cbd.pfn)) (ctl->cbd.pdata, -1);
+			/* release the command control structure */
+			cmd_ctl_free_active();
+		}
+	} while (ctl);
+}
+
+/* set enabled when user-space processing is available */
+static void cmd_set_state(int enabled)
+{
+	DEBUG_TRACE;
+	spin_lock_bh(&cmdq_lock);
+	cmd_glob.enabled = enabled;
+	spin_unlock_bh(&cmdq_lock);
+	if (!enabled) {
+		cmd_fail_all();	/* fail all in progress commands */
+	}
+}
+
+/* default callback where caller can wait for completion
+ * create callback data
+ */
+typedef struct {
+	struct mutex m;
+	int res;
+} defcb_data;
+
+/* callback function when operation completes */
+static void callback_wait(void *din, int res)
+{
+	defcb_data *data = (defcb_data *) din;
+	DEBUG_TRACE;
+	/* save result */
+	data->res = res;
+	/* signal the waiting thread */
+	mutex_unlock(&data->m);
+}
+
+/* does a cmd_submit() and then waits for completion using above callback
+ * can only be used if caller may wait -- user level, not softirq/tasklet
+ */
+static int cmd_ctl_submit_and_wait(cmd_ctl_t * ctl)
+{
+	defcb_data *data;
+	int res;
+
+	DEBUG_TRACE;
+	data = kmalloc(sizeof(*data), GFP_ATOMIC);
+	if (!data) {
+		printk(KERN_ALERT "%s: alloc failed\n", __FUNCTION__);
+		cmd_ctl_free(ctl);	/* release the control structure */
+		return -ENOMEM;
+	}
+	/* initialize the mutex in the locked state */
+	mutex_init(&data->m);
+	mutex_lock(&data->m);
+	/* set the callback fields in the control structure and submit */
+	ctl->cbd.pfn = callback_wait;
+	ctl->cbd.pdata = data;
+	res = cmd_ctl_submit(ctl);
+	if (res) {
+		/* failed to submit -- fail it now
+		 * do not free ctl, released in cmd_ctl_submit()
+		 */
+		kfree(data);
+		return res;
+	}
+	/* wait for callback to complete and unlock mutex */
+	if (mutex_lock_interruptible(&data->m)) {
+		/* this case will not occur with drivers, only with test utility
+		 * so not important to deal with immediately
+		 * TBD: deal with this case!!!!
+		 */
+		printk(KERN_ALERT "%s: interrupted!!!\n", __FUNCTION__);
+		return -1;
+	}
+	/* fetch the result */
+	res = data->res;
+	/* free the callback data */
+	kfree(data);
+	/* do NOT free ctl as it was already freed after the callback was called */
+	return res;
+}
+
+/* commands to user space are passed in as a command number,
+ * and a number of items each consisting of an offset  and length
+ * input: def - const command definition
+ * input: itp - data items (pointer, length)
+ * output: command is enqueued for transfer to user space
+ */
+static int sdclkm_command(sdclkm_cb_t * cbd,
+			  const cmd_def_t * def, item_ptr_t * itp)
+{
+	cmd_ctl_t *ctl;		/* command control */
+	cmd_hdr_t *hdr;		/* command header */
+	int i;
+	int offset;
+
+	DEBUG_TRACE;
+
+	ctl = cmd_ctl_alloc();
+	if (!ctl) {
+		printk(KERN_ALERT "%s: allocation failed\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	/* save data item pointers */
+	memcpy(&ctl->itp, itp, sizeof(*itp) * def->numit);
+	/* save the command/item definition */
+	ctl->def = def;
+
+	/* build the command header to be passed to user space */
+	hdr = &ctl->hdr;
+	offset = (u8 *) (&hdr->it[def->numit]) - (u8 *) hdr;
+	ctl->hdr_len = offset;
+	for (i = 0; i < def->numit; i++) {
+		hdr->it[i].len = itp[i].len;
+		if (def->flags[i] & ITEM_SKB) {
+			/* this item is enclosed in previous item (wrapper) */
+			hdr->it[i].offset = hdr->it[i - 1].offset +
+			    ((u8 *) itp[i].p - (u8 *) itp[i - 1].p);
+		} else {
+			hdr->it[i].offset = offset;
+			offset += (hdr->it[i].len + 3) & (~3);
+		}
+	}
+	hdr->len = offset;
+	hdr->cmd = def->cmd;
+	hdr->res = -1;
+	hdr->numit = def->numit;
+
+	/* if using callback, submit and let callback get result */
+	if (cbd) {
+		ctl->cbd = *cbd;
+		return cmd_ctl_submit(ctl);
+	}
+
+	/* if no callback -- wait for operation to complete and return result */
+	return cmd_ctl_submit_and_wait(ctl);
+}
+
+static const cmd_def_t def_ecb = {
+	SDCCMD_ECB_ENCRYPT, 2,
+	{
+	 ITEM_TO_HOST,			/* key */
+	 ITEM_TO_HOST | ITEM_FROM_HOST,	/* data */
+	 0}
+};
+
+int sdclkm_fnecbencrypt(sdclkm_cb_t * cbd,
+			fips_ccm_key_t * pkey, void *text, int len)
+{
+	item_ptr_t it[2];
+	DEBUG_TRACE;
+	it[0].p = pkey;
+	it[0].len = sizeof(*pkey);
+	it[1].p = text;
+	it[1].len = len;
+	return sdclkm_command(cbd, &def_ecb, it);
+}
+
+static const cmd_def_t def_ccmencrypt = {
+	SDCCMD_CCM_ENCRYPT, 5,
+	{
+	 ITEM_TO_HOST,			/* key */
+	 ITEM_TO_HOST,			/* n */
+	 ITEM_TO_HOST,			/* a */
+	 ITEM_TO_HOST | ITEM_FROM_HOST,	/* m */
+	 ITEM_FROM_HOST,		/* t */
+	 0}
+};
+
+int sdclkm_fnccmencrypt_ex(sdclkm_cb_t * cbd,
+			   fips_ccm_key_t * pkey,
+			   void *n, int ln,
+			   void *a, int la, void *m, int lm, void *t, int lt)
+{
+	item_ptr_t it[5];
+	DEBUG_TRACE;
+	it[0].p = pkey;
+	it[0].len = sizeof(*pkey);
+	it[1].p = n;
+	it[1].len = ln;
+	it[2].p = a;
+	it[2].len = la;
+	it[3].p = m;
+	it[3].len = lm;
+	it[4].p = t;
+	it[4].len = lt;
+	return sdclkm_command(cbd, &def_ccmencrypt, it);
+}
+
+static const cmd_def_t def_ccmdecrypt = {
+	SDCCMD_CCM_DECRYPT, 5,
+	{
+	 ITEM_TO_HOST,			/* key */
+	 ITEM_TO_HOST,			/* n */
+	 ITEM_TO_HOST,			/* a */
+	 ITEM_TO_HOST | ITEM_FROM_HOST,	/* m */
+	 ITEM_TO_HOST,			/* t */
+	 0}
+};
+
+int sdclkm_fnccmdecrypt_ex(sdclkm_cb_t * cbd,
+			   fips_ccm_key_t * pkey,
+			   void *n, int ln,
+			   void *a, int la, void *m, int lm, void *t, int lt)
+{
+	item_ptr_t it[5];
+	DEBUG_TRACE;
+	it[0].p = pkey;
+	it[0].len = sizeof(*pkey);
+	it[1].p = n;
+	it[1].len = ln;
+	it[2].p = a;
+	it[2].len = la;
+	it[3].p = m;
+	it[3].len = lm;
+	it[4].p = t;
+	it[4].len = lt;
+	return sdclkm_command(cbd, &def_ccmdecrypt, it);
+}
+
+EXPORT_SYMBOL(sdclkm_fnecbencrypt);
+EXPORT_SYMBOL(sdclkm_fnccmencrypt_ex);
+EXPORT_SYMBOL(sdclkm_fnccmdecrypt_ex);
+
+/*======================================================================*/
+#define DVR_HEADROOM 64
+static const cmd_def_t def_skb_receive = {
+	SDCCMD_DVR_RECEIVE, 2,
+	{
+	 0,			/* socket buffer wrapper (with head/tail) */
+	 ITEM_TO_HOST | ITEM_FROM_HOST | ITEM_SKB,	/* socket buffer data */
+	 0}
+};
+
+int sdclkm_skb_receive(sdclkm_cb_t * cbd, struct sk_buff *skb)
+{
+	item_ptr_t it[2];
+	int headroom;
+	DEBUG_TRACE;
+	headroom = (skb_headroom(skb) & 3) + DVR_HEADROOM;
+	it[0].p = skb->data - headroom;
+	it[0].len = 2048;
+	it[1].p = skb->data;
+	it[1].len = skb->len;
+	it[1].skb = skb;
+	return sdclkm_command(cbd, &def_skb_receive, it);
+}
+
+static const cmd_def_t def_skb_transmit = {
+	SDCCMD_DVR_TRANSMIT, 3,
+	{
+	 0,			/* socket buffer wrapper (with head/tail) */
+	 ITEM_TO_HOST | ITEM_FROM_HOST | ITEM_SKB,	/* socket buffer data */
+	 ITEM_TO_HOST,		/* up (user priority) */
+	 0}
+};
+
+int sdclkm_skb_transmit(sdclkm_cb_t * cbd, struct sk_buff *skb, int *up)
+{
+	item_ptr_t it[3];
+	int headroom;
+	DEBUG_TRACE;
+	headroom = (skb_headroom(skb) & 3) + DVR_HEADROOM;
+	it[0].p = skb->data - headroom;
+	it[0].len = 2048;
+	it[1].p = skb->data;
+	it[1].len = skb->len;
+	it[1].skb = skb;
+	it[2].p = up;
+	it[2].len = sizeof(*up);
+	return sdclkm_command(cbd, &def_skb_transmit, it);
+}
+
+static const cmd_def_t def_addkey = {
+	SDCCMD_DVR_ADDKEY, 3,
+	{
+	 ITEM_TO_HOST,		/* key_index, pairwise */
+	 ITEM_TO_HOST,		/* key */
+	 ITEM_TO_HOST,		/* seq */
+	 0}
+};
+
+int sdclkm_addkey(sdclkm_cb_t * cbd,
+		  u32 * key_index, u8 * key, int keylen, u8 * seq, int seqlen)
+{
+	item_ptr_t it[3];
+	DEBUG_TRACE;
+	it[0].p = key_index;
+	it[0].len = sizeof(*key_index);
+	it[1].p = key;
+	it[1].len = keylen;
+	it[2].p = seq;
+	it[2].len = seqlen;
+	return sdclkm_command(cbd, &def_addkey, it);
+}
+
+static const cmd_def_t def_setbssid = {
+	SDCCMD_DVR_SETBSSID, 1,
+	{
+	 ITEM_TO_HOST,		/* bssid */
+	 0}
+};
+
+int sdclkm_setbssid(sdclkm_cb_t * cbd, u8 * bssid, int bssidlen)
+{
+	item_ptr_t it[1];
+	DEBUG_TRACE;
+	it[0].p = bssid;
+	it[0].len = bssidlen;
+	return sdclkm_command(cbd, &def_setbssid, it);
+}
+
+EXPORT_SYMBOL(sdclkm_skb_receive);
+EXPORT_SYMBOL(sdclkm_skb_transmit);
+EXPORT_SYMBOL(sdclkm_addkey);
+EXPORT_SYMBOL(sdclkm_setbssid);
diff --git a/drivers/net/wireless/laird_fips/mod2urw.h b/drivers/net/wireless/laird_fips/mod2urw.h
new file mode 100644
index 0000000..4b5d09f
--- /dev/null
+++ b/drivers/net/wireless/laird_fips/mod2urw.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2013 Laird, Inc.
+ * Licensed under GPLv2.
+ */
+
+#ifndef _MOD2URW_H_
+#define _MOD2URW_H_
+
+#include <linux/skbuff.h>
+typedef int FIPS_STATUS;
+#define FIPS_STATUS_SUCCESS		0
+#define FIPS_STATUS_FAILURE		(-1)
+
+#ifndef fips_ccm_key_t
+typedef struct {
+	unsigned char key[16];	/* 128-bit aes key */
+} fips_ccm_key_t;
+#define fips_ccm_key_t fips_ccm_key_t
+#endif
+
+/* allocate items to be passed to sdclkm_xxx using sdclkm_alloc/free */
+#define sdclkm_alloc(len) kmalloc(len, GFP_ATOMIC)
+#define sdclkm_free(p)    kfree(p)
+
+/* callback function to be used if context cannot wait (e.g. softirq/bh) */
+typedef void (*sdclkm_callback_fn_ptr_t) (void *callback_data, int result);
+typedef struct {
+	sdclkm_callback_fn_ptr_t pfn;
+	void *pdata;
+} sdclkm_cb_t;
+extern int sdclkm_fnecbencrypt(sdclkm_cb_t * cbd,
+			       fips_ccm_key_t * pkey, void *m, int lm);
+extern int sdclkm_fnccmencrypt_ex(sdclkm_cb_t * cbd,
+				  fips_ccm_key_t * pkey,
+				  void *n, int ln, void *a, int la,
+				  void *m, int lm, void *t, int lt);
+extern int sdclkm_fnccmdecrypt_ex(sdclkm_cb_t * cbd, fips_ccm_key_t * pkey,
+				  void *n, int ln, void *a, int la,
+				  void *m, int lm, void *t, int lt);
+extern int sdclkm_skb_receive(sdclkm_cb_t * cbd, struct sk_buff *skb);
+extern int sdclkm_skb_transmit(sdclkm_cb_t * cbd, struct sk_buff *skb, int *up);
+extern int sdclkm_addkey(sdclkm_cb_t * cbd,
+			 u32 * key_index,
+			 u8 * key, int keylen, u8 * seq, int seqlen);
+extern int sdclkm_setbssid(sdclkm_cb_t * cbd, u8 * bssid, int bssidlen);
+#endif /* _MODLKM_H_ */
diff --git a/drivers/net/wireless/laird_fips/moddebug.c b/drivers/net/wireless/laird_fips/moddebug.c
new file mode 100644
index 0000000..bf61ead
--- /dev/null
+++ b/drivers/net/wireless/laird_fips/moddebug.c
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013 Laird, Inc.
+ * Licensed under GPLv2.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* size_t */
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h>	/* O_ACCMODE */
+#include <linux/seq_file.h>
+#include <linux/cdev.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+
+#include <asm/system.h>		/* cli(), *_flags */
+#include <asm/uaccess.h>	/* copy_*_user */
+
+#include "moddebug.h"
+
+#ifndef _printkhexs
+static char _dnib2hex(int x)
+{
+	if (x < 10)
+		return '0' + x;
+	if (x < 16)
+		return 'a' + (x - 10);
+	return '?';
+}
+
+void _printkhexs(const char *psz, const char *pfx, const void *buf, int len)
+{
+	const char *src = buf;
+	printk(KERN_ALERT "%s: %s 0x%x[%d]\n", psz, pfx, (unsigned int)buf,
+	       len);
+	if (len > 128)
+		len = 128;
+	while (len) {
+		int thislen = len > 16 ? 16 : len;
+		char hexs[16 * 3];
+		char *dst = &hexs[0];
+		len -= thislen;
+		while (thislen) {
+			*dst++ = _dnib2hex(*src >> 4);
+			*dst++ = _dnib2hex(*src & 0xf);
+			*dst++ = ' ';
+			src++;
+			thislen--;
+		}
+		*(dst - 1) = 0;
+		printk(KERN_ALERT "%s: %s\n", pfx, hexs);
+	}
+}
+#endif
diff --git a/drivers/net/wireless/laird_fips/moddebug.h b/drivers/net/wireless/laird_fips/moddebug.h
new file mode 100644
index 0000000..0bdafea
--- /dev/null
+++ b/drivers/net/wireless/laird_fips/moddebug.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2013 Laird, Inc.
+ * Licensed under GPLv2.
+ */
+
+#ifndef _MODDEBUG_H_
+#define _MODDEBUG_H_
+
+#define DEBUG_TRACE0
+#define DEBUG_TRACE1 \
+	printk(KERN_ALERT "%s: line %d\n", __FUNCTION__, __LINE__);
+
+/* debug output disabled */
+#define _printkhexs(psz,pfx,buf,len)
+#define DEBUG_TRACE DEBUG_TRACE0
+
+#ifndef _printkhexs
+extern void _printkhexs(const char *psz, const char *pfx,
+			const void *buf, int len);
+#endif
+
+#ifndef DEBUG_TRACE
+#define DEBUG_TRACE DEBUG_TRACE1
+#endif
+
+#endif
diff --git a/drivers/net/wireless/laird_fips/touser.h b/drivers/net/wireless/laird_fips/touser.h
new file mode 100644
index 0000000..8bf53a7
--- /dev/null
+++ b/drivers/net/wireless/laird_fips/touser.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2013 Laird, Inc.
+ * Licensed under GPLv2.
+ */
+
+#ifndef _TOUSER_H_
+#define _TOUSER_H_
+
+typedef struct {
+	int offset;		/* offset from beginning of cmd_hdr_t */
+	int len;		/* length of item */
+} item_t;
+
+/* command structure */
+#define MAXIT 10
+typedef struct {
+	int len;		/* total length including this field */
+	int cmd;		/* command to execute -- set to zero when completed */
+#define SDCCMD_CCM_ENCRYPT	3
+#define SDCCMD_CCM_DECRYPT	4
+#define SDCCMD_ECB_ENCRYPT	5
+#define SDCCMD_DVR_RECEIVE  6
+#define SDCCMD_DVR_TRANSMIT 7
+#define SDCCMD_DVR_ADDKEY   8
+#define SDCCMD_DVR_SETBSSID 9
+	int res;		/* result of command */
+	int numit;		/* number of items used */
+	item_t it[MAXIT];
+	/* items follow at offsets relative to beginning of cmd_hdt_t */
+} cmd_hdr_t;
+
+#define E_LRD_BASE  1000
+#define E_LRD_RX_NO_MEMORY           (E_LRD_BASE+0)
+#define E_LRD_RX_BAD_PACKET          (E_LRD_BASE+1)
+#define E_LRD_RX_UNENCRYPTED         (E_LRD_BASE+2)
+#define E_LRD_RX_DISCARD_AMSDU       (E_LRD_BASE+3)
+#define E_LRD_RX_FRAGMENT            (E_LRD_BASE+4)
+#define E_LRD_RX_DISCARD_UNENCRYPTED (E_LRD_BASE+5)
+#define E_LRD_RX_DECRYPT_OK          (E_LRD_BASE+6)
+#define E_LRD_RX_DECRYPT_FAIL        (E_LRD_BASE+7)
+#define E_LRD_RX_DECRYPT_REPLAY      (E_LRD_BASE+8)
+#define E_LRD_RX_DECRYPT_NO_KEY      (E_LRD_BASE+9)
+
+#define E_LRD_TX_NO_MEMORY           (E_LRD_BASE+10)
+#define E_LRD_TX_BAD_PACKET          (E_LRD_BASE+11)
+#define E_LRD_TX_UNENCRYPTED_OK      (E_LRD_BASE+12)
+#define E_LRD_TX_UNENCRYPTED_FAIL    (E_LRD_BASE+13)
+#define E_LRD_TX_ENCRYPT_OK          (E_LRD_BASE+14)
+#define E_LRD_TX_ENCRYPT_FAIL        (E_LRD_BASE+15)
+#define E_LRD_TX_ENCRYPT_NO_KEY      (E_LRD_BASE+16)
+#define E_LRD_TX_NOT_CONNECTED       (E_LRD_BASE+17)
+
+#endif
-- 
1.8.1.2

