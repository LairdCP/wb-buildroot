diff -urN a/arch/arm/mach-at91/Kconfig b/arch/arm/mach-at91/Kconfig
--- a/arch/arm/mach-at91/Kconfig	2012-01-04 18:55:44.000000000 -0500
+++ b/arch/arm/mach-at91/Kconfig	2012-11-25 12:57:00.000000000 -0500
@@ -342,6 +342,26 @@
 	  with 2 SD/MMC Slots. This is the case for AT91SAM9G20-EK rev. C and
 	  onwards.
 
+config MACH_WB40N
+	bool "Laird Connectivity Workgroup Bridge"
+	help
+	  Select this if you are using Laird Connectivity 40N-series
+	  Workgroup Bridge.
+	  <http://www.lairdconnect.com>
+
+choice
+	prompt "Select WB40N board revision"
+	depends on MACH_WB40N
+	default MACH_WB40N_REV3
+
+config MACH_WB40N_REV2
+	bool "Rev2"
+
+config MACH_WB40N_REV3
+	bool "Rev3"
+
+endchoice
+
 config MACH_CPU9G20
 	bool "Eukrea CPU9G20 board"
 	help
@@ -506,6 +526,7 @@
 	  On AT91sam926x chips, or otherwise when using a higher precision
 	  system clock (of at least several MHz), rounding is less of a
 	  problem so it can be safer to use a decimal values like 100.
+	  default y
 
 choice
 	prompt "Select a UART for early kernel messages"
diff -urN a/arch/arm/mach-at91/Makefile b/arch/arm/mach-at91/Makefile
--- a/arch/arm/mach-at91/Makefile	2012-01-04 18:55:44.000000000 -0500
+++ b/arch/arm/mach-at91/Makefile	2012-11-25 12:57:00.000000000 -0500
@@ -62,6 +62,7 @@
 
 # AT91SAM9G20 board-specific support
 obj-$(CONFIG_MACH_AT91SAM9G20EK) += board-sam9g20ek.o
+obj-$(CONFIG_MACH_WB40N)	+= board-wb40n.o
 obj-$(CONFIG_MACH_CPU9G20)	+= board-cpu9krea.o
 obj-$(CONFIG_MACH_ACMENETUSFOXG20) += board-foxg20.o
 obj-$(CONFIG_MACH_STAMP9G20)	+= board-stamp9g20.o
diff -urN a/arch/arm/mach-at91/at91sam9_alt_reset.S b/arch/arm/mach-at91/at91sam9_alt_reset.S
--- a/arch/arm/mach-at91/at91sam9_alt_reset.S	2012-01-04 18:55:44.000000000 -0500
+++ b/arch/arm/mach-at91/at91sam9_alt_reset.S	2012-11-25 12:57:00.000000000 -0500
@@ -31,12 +31,12 @@
 			ldr	r1, .at91_va_base_rstc_cr
 
 			mov	r2, #1
-			mov	r3, #AT91_SDRAMC_LPCB_POWER_DOWN
+			mov	r3, #AT91_SDRAMC_LPCB_DISABLE
 			ldr	r4, =AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST
 
 			.balign	32				@ align to cache line
 
-			str	r2, [r0, #AT91_SDRAMC_TR]	@ disable SDRAM access
+@			str	r2, [r0, #AT91_SDRAMC_TR]	@ disable SDRAM access
 			str	r3, [r0, #AT91_SDRAMC_LPR]	@ power down SDRAM
 			str	r4, [r1]			@ reset processor
 
diff -urN a/arch/arm/mach-at91/board-wb40n.c b/arch/arm/mach-at91/board-wb40n.c
--- a/arch/arm/mach-at91/board-wb40n.c	1969-12-31 19:00:00.000000000 -0500
+++ b/arch/arm/mach-at91/board-wb40n.c	2012-11-25 12:57:00.000000000 -0500
@@ -0,0 +1,357 @@
+/*
+ * Copyright (C) 2011 Laird Connectivity, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <mach/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <mach/board.h>
+#include <mach/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <mach/at91sam9_smc.h>
+#include <mach/system_rev.h>
+
+#include "sam9_smc.h"
+#include "generic.h"
+
+static void __init wb40n_init_early(void)
+{
+	/* Initialize processor: 18.432 MHz crystal */
+	at91_initialize(18432000);
+
+	/* DBGU on ttyS0. (Rx & Tx only) */
+	at91_register_uart(0, 0, 0);
+
+	/* USART0 on ttyS1. (Rx, Tx, CTS, RTS, DTR, DSR, DCD, RI) */
+	at91_register_uart(AT91SAM9260_ID_US0, 1, ATMEL_UART_CTS | ATMEL_UART_RTS
+			   | ATMEL_UART_DTR | ATMEL_UART_DSR | ATMEL_UART_DCD
+			   | ATMEL_UART_RI);
+
+	/* USART1 on ttyS2. (Rx, Tx, RTS, CTS) */
+	at91_register_uart(AT91SAM9260_ID_US1, 2, ATMEL_UART_CTS | ATMEL_UART_RTS);
+
+	/* USART3 on ttyS3 - Bluetooth interface. (Rx, Tx, RTS, CTS) */
+	at91_register_uart(AT91SAM9260_ID_US3, 3, ATMEL_UART_CTS | ATMEL_UART_RTS);
+
+	/* set serial console to ttyS0 (ie, DBGU) */
+	at91_set_serial_console(0);
+}
+
+/*
+ * USB Host port
+ */
+static struct at91_usbh_data __initdata wb40n_usbh_data = {
+	.ports		= 2,
+};
+
+/*
+ * USB Device port
+ */
+static struct at91_udc_data __initdata wb40n_udc_data = {
+	.vbus_pin	= AT91_PIN_PC21,
+	.vbus_active_low = 1,
+	.pullup_pin	= 0, /* pull-up driven by UDC on the AT91SAM9G20 */
+};
+
+/*
+ * Audio (BlueTooth PCM interface)
+ */
+struct ssd40nbt_info {
+	int		ssc_id;
+	struct clk	*dac_clk;
+	char		shortname[32];
+};
+
+static struct ssd40nbt_info ssd40nbt_data = {
+	.ssc_id		= 0,
+	.shortname	= "SSD40NBT Bluetooth Audio Path",
+};
+
+#if defined(CONFIG_SND_SSD40NBT)
+static void __init ssd40nbt_set_clk(struct ssd40nbt_info *info)
+{
+	struct clk *pck0;
+	struct clk *plla;
+
+	pck0 = clk_get(NULL, "pck0");
+	plla = clk_get(NULL, "plla");
+
+	/* SSD40NBT MCK Clock */
+	at91_set_B_periph(AT91_PIN_PB16, 0);	/* PCK0 */
+
+	clk_set_parent(pck0, plla);
+	clk_put(plla);
+
+	info->dac_clk = pck0;
+}
+#else
+static void __init ssd40nbt_set_clk(struct ssd40nbt_info *info) {}
+#endif
+
+/*
+ * MACB Ethernet device
+ */
+static struct at91_eth_data __initdata wb40n_macb_data = {
+	.phy_irq_pin	= AT91_PIN_PB1,
+	.is_rmii	= 1,
+};
+
+static void __init wb40n_add_device_macb(void)
+{
+	at91_add_device_eth(&wb40n_macb_data);
+}
+
+/*
+ * NAND flash
+ */
+static struct mtd_partition __initdata wb40n_nand_partition[] = {
+	{
+		.name   = "at91bs",
+		.offset = 0,
+		.size   = 0x00020000,
+	},
+	{
+		.name	= "u-boot",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 0x00080000,
+	},
+	{
+		.name	= "u-boot-env-a",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 0x00020000,
+	},
+	{
+		.name	= "u-boot-env-b",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 0x00020000,
+	},
+	{
+		.name	= "kernel-a",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 0x00500000,
+	},
+	{
+		.name	= "kernel-b",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 0x00500000,
+	},
+	{
+		.name	= "rootfs-a",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 0x03000000,
+	},
+	{
+		.name	= "rootfs-b",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 0x03000000,
+	},
+	{
+		.name	= "user",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 0x014a0000,
+	},
+};
+
+static struct atmel_nand_data __initdata wb40n_nand_data = {
+	.ale		= 21,
+	.cle		= 22,
+//	.det_pin	= ... not connected
+	.rdy_pin	= AT91_PIN_PC13,
+	.enable_pin	= AT91_PIN_PC14,
+	.parts		= wb40n_nand_partition,
+	.num_parts	= ARRAY_SIZE(wb40n_nand_partition),
+};
+
+static struct sam9_smc_config __initdata wb40n_nand_smc_config = {
+	.ncs_read_setup		= 0,
+	.nrd_setup		= 2,
+	.ncs_write_setup	= 0,
+	.nwe_setup		= 2,
+
+	.ncs_read_pulse		= 6,
+	.nrd_pulse		= 3,
+	.ncs_write_pulse	= 6,
+	.nwe_pulse		= 3,
+
+	.read_cycle		= 6,
+	.write_cycle		= 6,
+
+	.mode			= AT91_SMC_READMODE | AT91_SMC_WRITEMODE | \
+				  AT91_SMC_EXNWMODE_DISABLE | AT91_SMC_TDFMODE,
+	.tdf_cycles		= 12,
+};
+
+static void __init wb40n_add_device_nand(void)
+{
+	wb40n_nand_data.bus_width_16 = board_have_nand_16bit();
+	/* setup bus-width (8 or 16) */
+	if (wb40n_nand_data.bus_width_16)
+		wb40n_nand_smc_config.mode |= AT91_SMC_DBW_16;
+	else
+		wb40n_nand_smc_config.mode |= AT91_SMC_DBW_8;
+
+	/* configure chip-select 3 (NAND) */
+	sam9_smc_configure(3, &wb40n_nand_smc_config);
+
+	at91_add_device_nand(&wb40n_nand_data);
+}
+
+/*
+ * MCI (SD/MMC)
+ * wp_pin and vcc_pin are not connected
+ */
+#if defined(CONFIG_MMC_ATMELMCI) || defined(CONFIG_MMC_ATMELMCI_MODULE)
+static struct mci_platform_data __initdata wb40n_mmc_data = {
+	.slot[0] = {
+		.bus_width	= 4,
+		.detect_pin	= AT91_PIN_PC5,
+	},
+	.slot[1] = {
+		.bus_width	= 4,
+//		.detect_pin	= AT91_PIN_PC11,
+	},
+
+};
+#else
+static unsigned int wb40n_slot_b = 0;
+
+static int __init wb40n_slot_b_setup(char *options)
+{
+	if (!strcmp(options, "0"))
+		wb40n_slot_b = 0;
+	else if (!strcmp(options, "no"))
+		wb40n_slot_b = 0;
+	return 0;
+}
+__setup("slot_b=", wb40n_slot_b_setup);
+
+static struct at91_mmc_data __initdata wb40n_mmc_data = {
+	.slot_b		= 0,
+	.wire4		= 1,
+//	.det_pin	= AT91_PIN_PC11,
+};
+#endif
+
+static void __init wb40n_add_device_mmc(void)
+{
+#if defined(CONFIG_MMC_ATMELMCI) || defined(CONFIG_MMC_ATMELMCI_MODULE)
+	at91_add_device_mci(0, &wb40n_mmc_data);
+#else
+	wb40n_mmc_data.slot_b = wb40n_slot_b,
+	at91_add_device_mmc(0, &wb40n_mmc_data);
+#endif
+}
+
+/*
+ * LEDs
+ */
+static struct gpio_led wb40n_leds[] = {
+	{	/* stat0 */
+		.name			= "stat0",
+		.gpio			= AT91_PIN_PA28,
+		.active_low		= 1,
+		.default_trigger	= "none",
+	},
+	{	/* stat1 */
+		.name			= "stat1",
+		.gpio			= AT91_PIN_PA29,
+		.active_low		= 1,
+		.default_trigger	= "none",
+	},
+	{	/* led0 */
+		.name			= "led0",
+		.gpio			= AT91_PIN_PA25,
+		.active_low		= 1,
+		.default_trigger	= "none",
+	},
+	{	/* led1 */
+		.name			= "led1",
+		.gpio			= AT91_PIN_PA26,
+		.default_trigger	= "heartbeat",
+	},
+	{	/* led2 */
+		.name			= "led2",
+		.gpio			= AT91_PIN_PA27,
+		.active_low		= 1,
+		.default_trigger	= "none",
+	}
+};
+
+static void __init wb40n_add_device_gpio_leds(void)
+{
+	at91_gpio_leds(wb40n_leds, ARRAY_SIZE(wb40n_leds));
+}
+
+static void __init wb40n_board_init(void)
+{
+	/* Serial */
+	at91_add_device_serial();
+	/* USB Host */
+#if defined(CONFIG_MACH_WB40N_REV2)
+	at91_set_gpio_output(AT91_PIN_PA22, 0); /* USB current switch enable, low true */
+	at91_set_gpio_input(AT91_PIN_PC15, 1); /* USB current limit (FAULT), low true */
+#else /* REV3 */
+	at91_set_gpio_output(AT91_PIN_PC0, 0); /* USB current switch enable, low true */
+	at91_set_gpio_input(AT91_PIN_PC1, 1); /* USB current limit (FAULT), low true */
+#endif
+	at91_add_device_usbh(&wb40n_usbh_data);
+	/* USB Device */
+	at91_set_gpio_input(AT91_PIN_PC21, 0); /* USB BUS voltage detect, internal pullup disabled */
+	at91_set_gpio_output(AT91_PIN_PC20, 0); /* USB device pullup-enable on H+W board - LEAVE THIS TURNED OFF! */
+	at91_add_device_udc(&wb40n_udc_data);
+	/* NAND */
+	wb40n_add_device_nand();
+	/* Ethernet */
+	wb40n_add_device_macb();
+	/* MMC */
+	wb40n_add_device_mmc();
+	/* SSC (BlueTooth interface of SSD40NBT) */
+	ssd40nbt_set_clk(&ssd40nbt_data);
+	at91_add_device_ssc(AT91SAM9260_ID_SSC, ATMEL_SSC_TX | ATMEL_SSC_RD);
+	/* LEDs */
+	wb40n_add_device_gpio_leds();
+	/* Wifi Module config */
+	/* SYS_RST_L - De-assert system reset */
+	at91_set_gpio_output(AT91_PIN_PB13, 1);
+	/* CHIP_PWD_L - De-assert powerdown */
+	at91_set_gpio_output(AT91_PIN_PB31, 1);
+	/* BT_RST_L - Hold BlueTooth in reset until it is needed by the BT stack */
+	at91_set_gpio_output(AT91_PIN_PC11, 0);
+}
+
+MACHINE_START(WB40N, "Workgroup Bridge 40N")
+	/* Maintainer: ccole@summitdata.com */
+	.timer		= &at91sam926x_timer,
+	.map_io		= at91_map_io,
+	.init_early	= wb40n_init_early,
+	.init_irq	= at91_init_irq_default,
+	.init_machine	= wb40n_board_init,
+MACHINE_END
diff -urN a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
--- a/drivers/mmc/host/Kconfig	2012-01-04 18:55:44.000000000 -0500
+++ b/drivers/mmc/host/Kconfig	2012-11-25 12:57:00.000000000 -0500
@@ -297,6 +297,13 @@
 
 endchoice
 
+config MMC_AT91_F_MAX
+	int "Maximum SDIO clock speed"
+	depends on MMC_AT91
+	default 25000000
+	help
+	  This sets the upper limit of the SDIO bus speed.
+
 config MMC_IMX
 	tristate "Motorola i.MX Multimedia Card Interface support"
 	depends on ARCH_MX1
diff -urN a/drivers/mmc/host/at91_mci.c b/drivers/mmc/host/at91_mci.c
--- a/drivers/mmc/host/at91_mci.c	2012-01-04 18:55:44.000000000 -0500
+++ b/drivers/mmc/host/at91_mci.c	2012-11-25 12:57:00.000000000 -0500
@@ -924,6 +924,18 @@
 	.enable_sdio_irq = at91_mci_enable_sdio_irq,
 };
 
+#ifdef CONFIG_MMC_AT91_F_MAX
+static int mmc_at91_f_max = CONFIG_MMC_AT91_F_MAX;
+#else
+static int mmc_at91_f_max = 25000000;
+#endif
+static int __init mmc_at91_f_max_setup(char *options)
+{
+	mmc_at91_f_max = simple_strtol(options, NULL, 0);
+	return 0;
+}
+__setup("sdio_fmax=", mmc_at91_f_max_setup);
+
 /*
  * Probe for the device
  */
@@ -950,7 +962,8 @@
 
 	mmc->ops = &at91_mci_ops;
 	mmc->f_min = 375000;
-	mmc->f_max = 25000000;
+	printk(KERN_INFO "%s: Setting SDIO bus speed to %d\n", pdev->name, mmc_at91_f_max);
+	mmc->f_max = mmc_at91_f_max;
 	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
 	mmc->caps = 0;
 
diff -urN a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c
--- a/drivers/tty/n_tty.c	2012-01-04 18:55:44.000000000 -0500
+++ b/drivers/tty/n_tty.c	2012-11-25 12:57:00.000000000 -0500
@@ -50,7 +50,6 @@
 #include <linux/uaccess.h>
 #include <linux/module.h>
 
-#include <asm/system.h>
 
 /* number of characters left in xmit buffer before select has we have room */
 #define WAKEUP_CHARS 256
@@ -1637,6 +1636,7 @@
 	int retval;
 	size_t n;
 	unsigned long flags;
+	bool is_eof;
 
 	retval = 0;
 	spin_lock_irqsave(&tty->read_lock, flags);
@@ -1646,15 +1646,15 @@
 	if (n) {
 		retval = copy_to_user(*b, &tty->read_buf[tty->read_tail], n);
 		n -= retval;
+		is_eof = n == 1 &&
+			tty->read_buf[tty->read_tail] == EOF_CHAR(tty);
 		tty_audit_add_data(tty, &tty->read_buf[tty->read_tail], n);
 		spin_lock_irqsave(&tty->read_lock, flags);
 		tty->read_tail = (tty->read_tail + n) & (N_TTY_BUF_SIZE-1);
 		tty->read_cnt -= n;
 		/* Turn single EOF into zero-length read */
-		if (L_EXTPROC(tty) && tty->icanon && n == 1) {
-			if (!tty->read_cnt && (*b)[n-1] == EOF_CHAR(tty))
-				n--;
-		}
+		if (L_EXTPROC(tty) && tty->icanon && is_eof && !tty->read_cnt)
+			n = 0;
 		spin_unlock_irqrestore(&tty->read_lock, flags);
 		*b += n;
 		*nr -= n;
diff -urN a/include/linux/netfilter_bridge/ebt_nat.h b/include/linux/netfilter_bridge/ebt_nat.h
--- a/include/linux/netfilter_bridge/ebt_nat.h	2012-01-04 18:55:44.000000000 -0500
+++ b/include/linux/netfilter_bridge/ebt_nat.h	2012-11-25 12:57:04.000000000 -0500
@@ -9,5 +9,6 @@
 };
 #define EBT_SNAT_TARGET "snat"
 #define EBT_DNAT_TARGET "dnat"
+#define EBT_ARPNAT_TARGET "arpnat"
 
 #endif
diff -urN a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
--- a/net/bridge/br_fdb.c	2012-01-04 18:55:44.000000000 -0500
+++ b/net/bridge/br_fdb.c	2012-11-25 12:57:04.000000000 -0500
@@ -703,3 +703,5 @@
 
 	return err;
 }
+EXPORT_SYMBOL(br_fdb_get);
+
diff -urN a/net/bridge/netfilter/Kconfig b/net/bridge/netfilter/Kconfig
--- a/net/bridge/netfilter/Kconfig	2012-01-04 18:55:44.000000000 -0500
+++ b/net/bridge/netfilter/Kconfig	2012-11-25 12:57:04.000000000 -0500
@@ -177,6 +177,16 @@
 	  source address of frames.
 
 	  To compile it as a module, choose M here.  If unsure, say N.
+
+config BRIDGE_EBT_ARPNAT
+	tristate "ebt: arpnat target support"
+	depends on BRIDGE_NF_EBTABLES
+	help
+	  This option adds the ARP match, which allows ARP and RARP header field
+	  filtering
+ 
+	  To compile it as a module, choose M here. If unsure, say N.
+
 #
 # watchers
 #
diff -urN a/net/bridge/netfilter/Makefile b/net/bridge/netfilter/Makefile
--- a/net/bridge/netfilter/Makefile	2012-01-04 18:55:44.000000000 -0500
+++ b/net/bridge/netfilter/Makefile	2012-11-25 12:57:04.000000000 -0500
@@ -27,6 +27,7 @@
 obj-$(CONFIG_BRIDGE_EBT_DNAT) += ebt_dnat.o
 obj-$(CONFIG_BRIDGE_EBT_REDIRECT) += ebt_redirect.o
 obj-$(CONFIG_BRIDGE_EBT_SNAT) += ebt_snat.o
+obj-$(CONFIG_BRIDGE_EBT_ARPNAT) += ebt_arpnat.o
 
 # watchers
 obj-$(CONFIG_BRIDGE_EBT_LOG) += ebt_log.o
diff -urN a/net/bridge/netfilter/ebt_arpnat.c b/net/bridge/netfilter/ebt_arpnat.c
--- a/net/bridge/netfilter/ebt_arpnat.c	1969-12-31 19:00:00.000000000 -0500
+++ b/net/bridge/netfilter/ebt_arpnat.c	2012-11-25 19:17:11.000000000 -0500
@@ -0,0 +1,650 @@
+/*
+ *  ebt_arpnat
+ *
+ *	Authors:
+ *      Kestutis Barkauskas <gpl@wilibox.com>
+ *
+ *  November, 2005
+ *
+ *	Rewritten by:
+ *         Kestutis Barkauskas and Kestutis Kupciunas <gpl@ubnt.com>
+ *
+ *  June, 2010
+ *
+ *      Updated to work with more recent kernel versions (e.g., 2.6.30)
+ *      Ditched entry expiration in favor of wiping entries with duplicate ips, when situation arises
+ *      Fixed arpnat procfs (though both arpnat_cache and arpnat_info are both in root procfs directory now)
+ *      
+ *      Eric Bishop <eric@gargoyle-router.com>
+ *
+ *  September 18, 2011
+ *
+ *      Updated code to work with kernel v3.0.0
+ *      Various bridging structures have changed
+ *      Added debugging information
+ *      Christopher Cole <chris.cole@lairdtech.com>
+ *
+ * February 11, 2012
+ *
+ *      Added DHCP Relay code
+ *      Christopher Cole <chris.cole@lairdtech.com>
+ */
+
+
+
+
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter_bridge/ebtables.h>
+#include <linux/netfilter_bridge/ebt_nat.h>
+#include <linux/module.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/if_pppox.h>
+#include <linux/if_vlan.h>
+#include <linux/rtnetlink.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/proc_fs.h>
+#include <linux/inetdevice.h>
+#include <net/arp.h>
+#include <net/ip.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/in.h>
+#include <net/checksum.h>
+
+
+#include "../br_private.h"
+
+#define STRMAC "%02x:%02x:%02x:%02x:%02x:%02x"
+#define STRIP "%d.%d.%d.%d"
+#define MAC2STR(x) (x)[0],(x)[1],(x)[2],(x)[3],(x)[4],(x)[5]
+#define IP2STR(x) (x)>>24&0xff,(x)>>16&0xff,(x)>>8&0xff,(x)&0xff
+
+#define GIADDR_OFFSET (24)
+#define CHADDR_OFFSET (28)
+
+
+
+//#define ARPNAT_DEBUG 1
+
+
+#ifdef ARPNAT_DEBUG
+static uint8_t debug = 1;
+#else
+static uint8_t debug = 0;
+#endif
+
+
+
+#ifndef __packed
+#define __packed __attribute__((__packed__))
+#endif
+
+static uint8_t chaddr_orig_bootp_relay[6] = {0};
+
+struct arpnat_dat
+{
+	uint32_t ip;
+	uint8_t mac[ETH_ALEN];
+} __packed;
+
+struct mac2ip
+{
+	struct hlist_node node;
+	struct arpnat_dat data;
+};
+
+static HLIST_HEAD(arpnat_table);
+static spinlock_t arpnat_lock = __SPIN_LOCK_UNLOCKED(arpnat_lock);
+
+static uint8_t bootpnat = 1;
+
+static struct mac2ip* find_mac_nat(struct hlist_head* head, const uint8_t* mac)
+{
+	struct mac2ip* tpos;
+	struct mac2ip* result = NULL;
+	struct hlist_node* pos;
+	struct hlist_node* n;
+	hlist_for_each_entry_safe(tpos, pos, n, head, node)
+	{
+		if (memcmp(tpos->data.mac, mac, ETH_ALEN) == 0)
+		{
+			result = tpos;
+			break;
+		}
+	}
+	return result;
+}
+
+static struct mac2ip* find_ip_nat(struct hlist_head* head, uint32_t ip)
+{
+	struct mac2ip* tpos;
+	struct mac2ip* result = NULL;
+	struct hlist_node* pos;
+	struct hlist_node* n;
+
+	hlist_for_each_entry_safe(tpos, pos, n, head, node)
+	{
+		if (tpos->data.ip == ip)
+		{
+			result = tpos;
+			break;
+		}
+	}
+	return result;
+}
+
+
+static void clear_ip_nat(struct hlist_head* head, uint32_t ip)
+{
+	struct mac2ip* tpos;
+	struct hlist_node* pos;
+	struct hlist_node* n;
+
+	hlist_for_each_entry_safe(tpos, pos, n, head, node)
+	{
+		if (tpos->data.ip == ip)
+		{
+			hlist_del(pos);
+	   		kfree(tpos);
+		}
+	}
+}
+
+static void free_arp_nat(struct hlist_head* head)
+{
+	struct mac2ip* tpos;
+	struct hlist_node* pos;
+	struct hlist_node* n;
+	hlist_for_each_entry_safe(tpos, pos, n, head, node)
+	{
+		hlist_del(pos);
+		kfree(tpos);
+	}
+}
+
+static struct mac2ip* update_arp_nat(struct hlist_head* head, const uint8_t* mac, uint32_t ip)
+{
+	struct mac2ip* entry;
+
+	entry = find_mac_nat(head, mac);
+	if (!entry)
+	{
+		clear_ip_nat(head, ip); /* if entries with new ip exist, wipe them */ 
+		entry = kmalloc(sizeof(*entry), GFP_ATOMIC);
+		if (!entry)
+		{
+			return NULL;
+		}
+		INIT_HLIST_NODE(&entry->node);
+		hlist_add_head(&entry->node, head);
+		memcpy(entry->data.mac, mac, ETH_ALEN);
+		entry->data.ip = ip;
+	}
+	else if(entry->data.ip != ip)
+	{
+		clear_ip_nat(head, ip); /* if entries with new ip exist, wipe them */ 
+		entry->data.ip = ip;
+	}
+	return entry;
+}
+
+#ifdef CONFIG_PROC_FS
+
+static void *arpnat_start(struct seq_file *seq, loff_t *loff_pos)
+{
+	static unsigned long counter = 0;
+
+	/* beginning a new sequence ? */	
+	if ( *loff_pos == 0 )
+	{	
+		/* yes => return a non null value to begin the sequence */
+		return &counter;
+	}
+	else
+	{
+		/* no => it's the end of the sequence, return end to stop reading */
+		*loff_pos = 0;
+		return NULL;
+	}
+}
+
+static void *arpnat_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	return NULL;
+}
+
+
+static void arpnat_stop(struct seq_file *seq, void *v)
+{
+	//don't need to do anything
+}
+
+
+static int arpnat_cache_show(struct seq_file *s, void *v)
+{
+	struct mac2ip* tpos;
+	struct hlist_node* pos;
+	struct hlist_node* n;
+	unsigned long flags;
+
+	spin_lock_irqsave(&arpnat_lock, flags);
+	hlist_for_each_entry_safe(tpos, pos, n, &arpnat_table, node)
+	{
+		seq_printf(s, STRMAC"\t"STRIP"\n", MAC2STR(tpos->data.mac), IP2STR(tpos->data.ip));
+	}
+	spin_unlock_irqrestore(&arpnat_lock, flags);
+
+	return 0;
+}
+static int arpnat_info_show(struct seq_file *s, void *v)
+{
+	seq_printf(s, "Debug: %d\nBOOTPNAT: %d\n", debug, bootpnat);
+	return 0;
+}
+
+
+static struct seq_operations arpnat_cache_sops = {
+	.start = arpnat_start,
+	.next  = arpnat_next,
+	.stop  = arpnat_stop,
+	.show  = arpnat_cache_show
+};
+static struct seq_operations arpnat_info_sops = {
+	.start = arpnat_start,
+	.next  = arpnat_next,
+	.stop  = arpnat_stop,
+	.show  = arpnat_info_show
+};
+
+static int arpnat_cache_open(struct inode *inode, struct file* file)
+{
+	return seq_open(file, &arpnat_cache_sops);
+}
+static int arpnat_info_open(struct inode *inode, struct file* file)
+{
+	return seq_open(file, &arpnat_info_sops);
+}
+
+
+static struct file_operations arpnat_cache_fops = {
+	.owner   = THIS_MODULE,
+	.open    = arpnat_cache_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release
+};
+static struct file_operations arpnat_info_fops = {
+	.owner   = THIS_MODULE,
+	.open    = arpnat_info_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release
+};
+
+
+
+#endif
+
+
+static unsigned int ebt_target_arpnat(struct sk_buff *pskb, const struct xt_action_param *par)
+{
+	const struct net_device *in  =  par->in;
+	const struct net_device *out =  par->out;
+
+	const struct ebt_nat_info *info = (struct ebt_nat_info *) par->targinfo;
+
+	struct arphdr *ah = NULL;
+	struct arphdr _arph;
+
+
+	//used for target only
+	uint8_t* eth_smac = eth_hdr(pskb)->h_source;
+	uint8_t* eth_dmac = eth_hdr(pskb)->h_dest;
+	uint32_t* arp_sip = NULL;
+	uint8_t* arp_smac = NULL;
+	uint32_t* arp_dip = NULL;
+	uint8_t* arp_dmac = NULL;
+	struct mac2ip* entry = NULL;
+	unsigned long flags;
+
+	/* if it's an arp packet, initialize pointers to arp source/dest ip/mac addresses in skb */
+	if (eth_hdr(pskb)->h_proto == __constant_htons(ETH_P_ARP))
+	{
+		if(debug)
+		{
+			printk("ARPNAT ARP DETECTED\n");
+		}
+		ah = skb_header_pointer(pskb, 0, sizeof(_arph), &_arph);
+		if (ah->ar_hln == ETH_ALEN && ah->ar_pro == htons(ETH_P_IP) && ah->ar_pln == 4)
+		{
+			unsigned char *raw = skb_network_header(pskb);
+			arp_sip = (uint32_t*)(raw + sizeof(struct arphdr) + (arp_hdr(pskb)->ar_hln));
+			arp_smac = raw + sizeof(struct arphdr);
+			arp_dip = (uint32_t*)(raw + sizeof(struct arphdr) + (2*(arp_hdr(pskb)->ar_hln)) + arp_hdr(pskb)->ar_pln);
+			arp_dmac = raw + sizeof(struct arphdr) + arp_hdr(pskb)->ar_hln + arp_hdr(pskb)->ar_pln;
+		}
+		else
+		{
+			ah = NULL;
+		}
+	}
+	
+	if (in)
+	{
+		struct net_bridge_port *in_br_port;
+		in_br_port = br_port_get_rcu(in);
+
+		/* handle input packets */
+		if(debug)
+		{
+			printk("ARPNAT INBOUND DETECTED\n");
+		}
+
+		if (ah)
+		{
+			if(debug)
+			{
+				printk("IN ARPNAT:\n");
+				printk("          arp_smac="STRMAC", arp_dmac="STRMAC"\n", MAC2STR(arp_smac), MAC2STR(arp_dmac));
+				printk("          arp_sip ="STRIP", arp_dip ="STRIP"\n", IP2STR(*arp_sip), IP2STR(*arp_dip));
+				if(ah->ar_op == __constant_htons(ARPOP_REPLY))
+				{
+					printk("          arp_op=reply\n");
+				}
+				else if(ah->ar_op == __constant_htons(ARPOP_REQUEST))
+				{
+					printk("          arp_op=request\n");
+				}
+				else
+				{
+					printk("          arp_op=%d\n", ntohs(ah->ar_op));
+				}
+
+			}
+
+
+			if (inet_confirm_addr( __in_dev_get_rcu(in_br_port->br->dev) , 0, *arp_dip, RT_SCOPE_HOST))
+			{
+				if (debug)
+				{
+					printk("          TO US\n");
+				}
+				return info->target;
+			}
+
+
+			spin_lock_irqsave(&arpnat_lock, flags);
+			entry = find_ip_nat(&arpnat_table, *arp_dip);
+			switch (ah->ar_op)
+			{
+				case __constant_htons(ARPOP_REPLY):
+	 			case __constant_htons(ARPOP_REQUEST):
+				if (entry)
+				{
+					uint32_t dip = *arp_dip;
+					uint32_t sip = inet_select_addr(in_br_port->br->dev, dip, RT_SCOPE_LINK);
+					if (! (eth_dmac[0] & 1))
+					{
+						if (debug)
+						{
+							printk("          "STRMAC" -> "STRMAC"\n", MAC2STR(eth_dmac), MAC2STR(entry->data.mac));
+						}
+						memcpy(arp_dmac, entry->data.mac, ETH_ALEN);
+						memcpy(eth_dmac, entry->data.mac, ETH_ALEN);
+						(pskb)->pkt_type = (dip != sip) ? PACKET_OTHERHOST : (pskb)->pkt_type;
+					}
+					spin_unlock_irqrestore(&arpnat_lock, flags);
+					/*if (dip != sip)
+					{
+						if (debug)
+							printk("SEND ARP REQUEST: "STRIP" -> "STRIP"\n", IP2STR(sip), IP2STR(dip));
+						arp_send(ARPOP_REQUEST, ETH_P_ARP, dip, &in_br_port->br->dev, sip, NULL, in_br_port->br->dev.dev_addr, NULL);
+					}*/
+					return info->target;
+				}
+				break;
+			}
+			spin_unlock_irqrestore(&arpnat_lock, flags);
+		}
+		else if (eth_hdr(pskb)->h_proto == __constant_htons(ETH_P_IP))
+		{
+			struct iphdr *iph = ip_hdr(pskb);
+			struct udphdr *uh = NULL;
+			if (bootpnat && (unsigned char)iph->protocol == (unsigned char)IPPROTO_UDP && !(iph->frag_off & htons(IP_OFFSET)))
+			{
+				uh = (struct udphdr*)((u_int32_t *)iph + iph->ihl);
+				if(uh->dest == htons(67) || uh->dest == htons(68) )
+				{
+					//do something illegal for BOOTP
+					uint32_t* giaddrp = (uint32_t*)(((uint8_t*)uh) + sizeof(*uh) + GIADDR_OFFSET);
+					uint8_t* mac = (uint8_t*)(giaddrp + 1);
+					uint32_t ihl = iph->ihl << 2;
+					uint32_t size = (pskb)->len - ihl;
+					uint32_t orig_daddr = iph->daddr;
+
+					//iph->daddr = 0xffffffff;
+					// Recall the original BOOTP CHADDR
+					memcpy(mac, &chaddr_orig_bootp_relay, ETH_ALEN);
+					if (debug)
+					{
+						printk("IN BOOTPRELAY: "STRMAC"["STRIP"] -> "STRMAC"["STRIP"]\n", MAC2STR(eth_dmac), IP2STR(orig_daddr), MAC2STR(mac), IP2STR(iph->daddr));
+					}
+					memcpy(eth_dmac, mac, ETH_ALEN);
+					*giaddrp = 0;
+					uh->dest = htons(68);
+					iph->check = 0;
+					uh->check = 0;
+					iph->check = ip_fast_csum((uint8_t*)iph, iph->ihl);
+					(pskb)->csum = csum_partial((uint8_t*)iph + ihl, size, 0);
+					uh->check = csum_tcpudp_magic(iph->saddr, iph->daddr, size, iph->protocol, (pskb)->csum);
+					
+					if (uh->check == 0)
+					{
+						uh->check = 0xFFFF;
+					}
+					return info->target;
+				}
+				else
+				{
+					goto HANDLE_IP_PKT;
+				}
+			}	
+			else
+			{
+				HANDLE_IP_PKT:
+				spin_lock_irqsave(&arpnat_lock, flags);
+				entry = find_ip_nat(&arpnat_table, iph->daddr);
+				if (entry)
+				{
+					if (inet_confirm_addr( __in_dev_get_rcu(in_br_port->br->dev),  0, entry->data.ip, RT_SCOPE_HOST))
+					{
+						//to me
+						if (debug)
+						{
+							printk("IP PKT TO ME: "STRMAC"["STRIP"] -> "STRMAC"[type: %d]\n", MAC2STR(eth_dmac), IP2STR(iph->daddr), MAC2STR(in_br_port->br->dev->dev_addr), (pskb)->pkt_type);
+						}
+						memcpy(eth_dmac, in_br_port->br->dev->dev_addr, ETH_ALEN);
+					}
+					else
+					{
+						if (debug)
+						{
+							printk("IP PKT TO OTHER: "STRMAC"["STRIP"] -> "STRMAC"[type: %d]\n", MAC2STR(eth_dmac), IP2STR(iph->daddr), MAC2STR(entry->data.mac), (pskb)->pkt_type);
+						}
+						memcpy(eth_dmac, entry->data.mac, ETH_ALEN);
+						(pskb)->pkt_type = PACKET_OTHERHOST;
+					}
+					spin_unlock_irqrestore(&arpnat_lock, flags);
+					return info->target;
+				}
+				spin_unlock_irqrestore(&arpnat_lock, flags);
+			}
+		}
+		
+		if (! (eth_dmac[0] & 1))
+		{
+			if (memcmp(in_br_port->br->dev->dev_addr, eth_dmac, ETH_ALEN) && memcmp(in->dev_addr, eth_dmac, ETH_ALEN))
+			{
+				return EBT_DROP;
+			}
+			spin_lock_irqsave(&arpnat_lock, flags);
+			entry = find_mac_nat(&arpnat_table, eth_dmac);
+			if (entry)
+			{
+				memcpy(eth_dmac, entry->data.mac, ETH_ALEN);
+			}
+			else
+			{
+				memcpy(eth_dmac, in_br_port->br->dev->dev_addr, ETH_ALEN);
+			}
+			spin_unlock_irqrestore(&arpnat_lock, flags);
+		}
+	}
+	else if (out)
+	{
+		struct net_bridge_port *out_br_port;
+		out_br_port = br_port_get_rcu(out);
+
+
+		/* handle outbound packets */
+		if (ah)
+		{
+			switch (ah->ar_op)
+			{
+				case __constant_htons(ARPOP_REQUEST):
+				case __constant_htons(ARPOP_REPLY):
+
+				
+				/* do BR ip lookup */
+				if(inet_confirm_addr( __in_dev_get_rcu(out_br_port->br->dev), 0, *arp_dip, RT_SCOPE_HOST))
+				{
+					return info->target;
+				}
+				if(!inet_confirm_addr( __in_dev_get_rcu(out_br_port->br->dev), 0, *arp_sip, RT_SCOPE_HOST))
+				{
+					spin_lock_irqsave(&arpnat_lock, flags);
+					update_arp_nat(&arpnat_table, arp_smac, *arp_sip);
+					spin_unlock_irqrestore(&arpnat_lock, flags);
+				}
+
+				//pskb = skb_unshare(pskb, GFP_ATOMIC);
+				eth_smac = eth_hdr(pskb)->h_source;
+				arp_smac = skb_network_header(pskb) + sizeof(struct arphdr);
+				if (debug)
+				{
+					printk("OUT ARPNAT: "STRMAC" -> "STRMAC"\n", MAC2STR(eth_smac), MAC2STR(out->dev_addr));
+					printk("           arp_smac="STRMAC", arp_dmac="STRMAC"\n", MAC2STR(arp_smac), MAC2STR(arp_dmac));
+					printk("           arp_sip ="STRIP", arp_dip ="STRIP"\n", IP2STR(*arp_sip), IP2STR(*arp_dip));
+					if(ah->ar_op == __constant_htons(ARPOP_REPLY))
+					{
+						printk("           arp_op=reply\n");
+					}
+					else if(ah->ar_op == __constant_htons(ARPOP_REQUEST))
+					{
+						printk("           arp_op=request\n");
+					}
+					else
+					{
+						printk("           arp_op=%d\n", ntohs(ah->ar_op));
+					}
+				}
+				memcpy(arp_smac, out->dev_addr, ETH_ALEN);
+				memcpy(eth_smac, out->dev_addr, ETH_ALEN);
+				return info->target;
+				break;
+			}
+		}
+		else if (bootpnat && eth_hdr(pskb)->h_proto == __constant_htons(ETH_P_IP) && memcmp(out_br_port->br->dev->dev_addr, eth_smac, ETH_ALEN))
+		{
+			struct iphdr *iph = ip_hdr(pskb);
+			struct udphdr *uh = NULL;
+			if ( (unsigned char)iph->protocol == (unsigned char)IPPROTO_UDP && !(iph->frag_off & htons(IP_OFFSET)))
+			{
+				uh = (struct udphdr*)((u_int32_t *)iph + iph->ihl);
+				if (uh->dest == htons(67) || uh->dest == htons(68) )
+				{
+					//do something illegal for BOOTP
+					uint32_t giaddr = inet_select_addr(out_br_port->br->dev, iph->daddr, RT_SCOPE_LINK);
+					uint32_t* giaddrp = (uint32_t*)(((uint8_t*)uh) + sizeof(*uh) + GIADDR_OFFSET);
+					uint8_t *chaddrp = (uint8_t*)(((uint8_t*)uh) + sizeof(*uh) + CHADDR_OFFSET);
+					uint32_t ihl = iph->ihl << 2;
+					uint32_t size = (pskb)->len - ihl;
+					if (debug)
+					{
+						printk("OUT BOOTPRELAY: "STRIP" -> "STRIP"\n", IP2STR(*giaddrp), IP2STR(giaddr));
+					}
+					*giaddrp = giaddr;
+					// Save off the original BOOTP CHADDR
+					memcpy(&chaddr_orig_bootp_relay, chaddrp, ETH_ALEN);
+					// Change the DHCP HWADDR of the requestor to the HDADDR of the out device
+					memcpy(chaddrp, out->dev_addr, ETH_ALEN);
+
+					/* Fix the checksum */
+					uh->check = 0;
+					(pskb)->csum = csum_partial((uint8_t*)iph + ihl, size, 0);
+					uh->check = csum_tcpudp_magic(iph->saddr, iph->daddr, size, iph->protocol, (pskb)->csum);
+					
+					if (uh->check == 0)
+					{
+						uh->check = 0xFFFF;
+					}
+				}
+			}
+		}
+		memcpy(eth_smac, out->dev_addr, ETH_ALEN);
+	}
+	return info->target;
+}
+
+static int ebt_target_nat_arpcheck(const struct xt_tgchk_param *par)
+{
+	return 0;
+}
+static struct xt_target arpnat =
+{
+	.name		= EBT_ARPNAT_TARGET,
+	.revision	= 0,
+	.family		= NFPROTO_BRIDGE,
+	.table		= "nat",
+	.hooks		= (1 << NF_BR_NUMHOOKS) | (1 << NF_BR_POST_ROUTING) |  (1 << NF_BR_PRE_ROUTING) ,
+	.target		= ebt_target_arpnat, 
+	.checkentry	= ebt_target_nat_arpcheck,
+	.targetsize	= XT_ALIGN(sizeof(struct ebt_nat_info)),
+	.me		= THIS_MODULE
+};
+
+static int __init init(void)
+{
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *proc_arpnat_info  = create_proc_entry("arpnat_info", 0, NULL);
+	struct proc_dir_entry *proc_arpnat_cache = create_proc_entry("arpnat_cache", 0, NULL);
+	if(proc_arpnat_info)
+	{
+		proc_arpnat_info->proc_fops = &arpnat_info_fops;
+	}
+	
+	if(proc_arpnat_cache)
+	{
+		proc_arpnat_cache->proc_fops = &arpnat_cache_fops;
+	}
+#endif
+	return xt_register_target(&arpnat);
+}
+
+static void __exit fini(void)
+{
+	xt_unregister_target(&arpnat);
+	free_arp_nat(&arpnat_table);
+#ifdef CONFIG_PROC_FS
+	remove_proc_entry("arpnat_info", NULL);
+	remove_proc_entry("arpnat_cache", NULL);
+#endif
+}
+
+module_init(init);
+module_exit(fini);
+MODULE_LICENSE("GPL");
+
+
diff -urN a/net/ipv4/devinet.c b/net/ipv4/devinet.c
--- a/net/ipv4/devinet.c	2012-01-04 18:55:44.000000000 -0500
+++ b/net/ipv4/devinet.c	2012-11-25 12:57:04.000000000 -0500
@@ -1846,4 +1846,4 @@
 	rtnl_register(PF_INET, RTM_DELADDR, inet_rtm_deladdr, NULL, NULL);
 	rtnl_register(PF_INET, RTM_GETADDR, NULL, inet_dump_ifaddr, NULL);
 }
-
+EXPORT_SYMBOL(inet_confirm_addr);
diff -urN a/net/wireless/core.c b/net/wireless/core.c
--- a/net/wireless/core.c	2012-01-04 18:55:44.000000000 -0500
+++ b/net/wireless/core.c	2012-11-25 12:57:04.000000000 -0500
@@ -839,8 +839,7 @@
 		if (!dev->ethtool_ops)
 			dev->ethtool_ops = &cfg80211_ethtool_ops;
 
-		if ((wdev->iftype == NL80211_IFTYPE_STATION ||
-		     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT ||
+		if ((wdev->iftype == NL80211_IFTYPE_P2P_CLIENT ||
 		     wdev->iftype == NL80211_IFTYPE_ADHOC) && !wdev->use_4addr)
 			dev->priv_flags |= IFF_DONT_BRIDGE;
 		break;
diff -urN a/net/wireless/nl80211.c b/net/wireless/nl80211.c
--- a/net/wireless/nl80211.c	2012-01-04 18:55:44.000000000 -0500
+++ b/net/wireless/nl80211.c	2012-11-25 12:57:04.000000000 -0500
@@ -1567,8 +1567,6 @@
 			       enum nl80211_iftype iftype)
 {
 	if (!use_4addr) {
-		if (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))
-			return -EBUSY;
 		return 0;
 	}
 
diff -urN a/net/wireless/sme.c b/net/wireless/sme.c
--- a/net/wireless/sme.c	2012-01-04 18:55:44.000000000 -0500
+++ b/net/wireless/sme.c	2012-11-25 12:57:00.000000000 -0500
@@ -470,6 +470,7 @@
 		wdev->conn->state = CFG80211_CONN_IDLE;
 
 	if (status != WLAN_STATUS_SUCCESS) {
+WLAN_NOT_SUCCESSFUL:
 		wdev->sme_state = CFG80211_SME_IDLE;
 		if (wdev->conn)
 			kfree(wdev->conn->ie);
@@ -490,6 +491,18 @@
 				       WLAN_CAPABILITY_ESS,
 				       WLAN_CAPABILITY_ESS);
 
+	if(!bss)
+	{
+/*
+		We occasionally get to this point where cfg80211 thinks we are connected
+		but we have no BSSID.  In order to resync the state machine of cfg80211
+		and the driver, we move to the IDLE state.  This allows the supplicant 
+		to reissue a connect.  Note that we did try calling the device's 
+		disconnect function but that did not help the reconnection speed.
+*/
+		goto WLAN_NOT_SUCCESSFUL;
+	}
+
 	if (WARN_ON(!bss))
 		return;
 
diff -urN a/net/wireless/util.c b/net/wireless/util.c
--- a/net/wireless/util.c	2012-01-04 18:55:44.000000000 -0500
+++ b/net/wireless/util.c	2012-11-25 12:57:04.000000000 -0500
@@ -817,7 +817,6 @@
 	/* if it's part of a bridge, reject changing type to station/ibss */
 	if ((dev->priv_flags & IFF_BRIDGE_PORT) &&
 	    (ntype == NL80211_IFTYPE_ADHOC ||
-	     ntype == NL80211_IFTYPE_STATION ||
 	     ntype == NL80211_IFTYPE_P2P_CLIENT))
 		return -EBUSY;
 
@@ -860,14 +859,11 @@
 	if (!err) {
 		dev->priv_flags &= ~IFF_DONT_BRIDGE;
 		switch (ntype) {
-		case NL80211_IFTYPE_STATION:
-			if (dev->ieee80211_ptr->use_4addr)
-				break;
-			/* fall through */
 		case NL80211_IFTYPE_P2P_CLIENT:
 		case NL80211_IFTYPE_ADHOC:
 			dev->priv_flags |= IFF_DONT_BRIDGE;
 			break;
+		case NL80211_IFTYPE_STATION:
 		case NL80211_IFTYPE_P2P_GO:
 		case NL80211_IFTYPE_AP:
 		case NL80211_IFTYPE_AP_VLAN:
diff -urN a/scripts/setlocalversion b/scripts/setlocalversion
--- a/scripts/setlocalversion	2012-01-04 18:55:44.000000000 -0500
+++ b/scripts/setlocalversion	2012-11-25 15:02:30.000000000 -0500
@@ -170,7 +170,7 @@
 	# LOCALVERSION= is not specified
 	if test "${LOCALVERSION+set}" != "set"; then
 		scm=$(scm_version --short)
-		res="$res${scm:++}"
+#		res="$res${scm:++}"
 	fi
 fi
 
diff -urN a/sound/soc/atmel/Kconfig b/sound/soc/atmel/Kconfig
--- a/sound/soc/atmel/Kconfig	2012-01-04 18:55:44.000000000 -0500
+++ b/sound/soc/atmel/Kconfig	2012-11-25 12:57:00.000000000 -0500
@@ -7,7 +7,7 @@
 	  to select the audio interfaces to support below.
 
 config SND_ATMEL_SOC_SSC
-	tristate
+	tristate "Atmel SSC codec support"
 	depends on SND_ATMEL_SOC
 	help
 	  Say Y or M if you want to add support for codecs the
@@ -24,6 +24,15 @@
 	  Say Y if you want to add support for SoC audio on WM8731-based
 	  AT91sam9g20 evaluation board.
 
+config SND_SSD40NBT
+	tristate "BlueTooth Audio support for Laird Connectivity SSD40NBT"
+	depends on ATMEL_SSC && ARCH_AT91SAM9G20 && SND_ATMEL_SOC && \
+	           AT91_PROGRAMMABLE_CLOCKS
+	select SND_ATMEL_SOC_SSC
+	help
+	  Say Y if you want to add support for Laird Connectivity 
+	  SSD40NBT BlueTooth Audio.
+
 config SND_AT91_SOC_AFEB9260
 	tristate "SoC Audio support for AFEB9260 board"
 	depends on ARCH_AT91 && MACH_AFEB9260 && SND_ATMEL_SOC
diff -urN a/drivers/net/phy/icplus.c b/drivers/net/phy/icplus.c
--- a/drivers/net/phy/icplus.c	2013-04-26 23:20:57.174981268 -0500
+++ b/drivers/net/phy/icplus.c	2013-04-26 23:41:38.219016678 -0500
@@ -30,16 +30,19 @@
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 
-MODULE_DESCRIPTION("ICPlus IP175C/IP101A/IC1001 PHY drivers");
+MODULE_DESCRIPTION("ICPlus IP175C/IP101A/IP101G/IC1001 PHY drivers");
 MODULE_AUTHOR("Michael Barkowski");
 MODULE_LICENSE("GPL");
 
-/* IP101A/IP1001 */
+/* IP101A/G - IP1001 */
 #define IP10XX_SPEC_CTRL_STATUS		16  /* Spec. Control Register */
 #define IP1001_SPEC_CTRL_STATUS_2	20  /* IP1001 Spec. Control Reg 2 */
 #define IP1001_PHASE_SEL_MASK		3 /* IP1001 RX/TXPHASE_SEL */
 #define IP1001_APS_ON			11  /* IP1001 APS Mode  bit */
-#define IP101A_APS_ON			2   /* IP101A APS Mode bit */
+#define IP101A_G_APS_ON			2   /* IP101A/G APS Mode bit */
+#define IP101A_G_IRQ_CONF_STATUS	0x11	/* Conf Info IRQ & Status Reg */
+#define IP101A_G_IRQ_PIN_USED		(1<<15) /* INTR pin used */
+#define IP101A_G_IRQ_DEFAULT		IP101A_G_IRQ_PIN_USED
 
 static int ip175c_config_init(struct phy_device *phydev)
 {
@@ -98,20 +101,24 @@
 
 static int ip1xx_reset(struct phy_device *phydev)
 {
-	int err, bmcr;
+	int bmcr;
 
 	/* Software Reset PHY */
 	bmcr = phy_read(phydev, MII_BMCR);
+	if (bmcr < 0)
+		return bmcr;
 	bmcr |= BMCR_RESET;
-	err = phy_write(phydev, MII_BMCR, bmcr);
-	if (err < 0)
-		return err;
+	bmcr = phy_write(phydev, MII_BMCR, bmcr);
+	if (bmcr < 0)
+		return bmcr;
 
 	do {
 		bmcr = phy_read(phydev, MII_BMCR);
+		if (bmcr < 0)
+			return bmcr;
 	} while (bmcr & BMCR_RESET);
 
-	return err;
+	return 0;
 }
 
 static int ip1001_config_init(struct phy_device *phydev)
@@ -139,7 +146,7 @@
 	return c;
 }
 
-static int ip101a_config_init(struct phy_device *phydev)
+static int ip101a_g_config_init(struct phy_device *phydev)
 {
 	int c;
 
@@ -147,9 +154,14 @@
 	if (c < 0)
 		return c;
 
+	/* INTR pin used: speed/link/duplex will cause an interrupt */
+	c = phy_write(phydev, IP101A_G_IRQ_CONF_STATUS, IP101A_G_IRQ_DEFAULT);
+	if (c < 0)
+		return c;
+
 	/* Enable Auto Power Saving mode */
 	c = phy_read(phydev, IP10XX_SPEC_CTRL_STATUS);
-	c |= IP101A_APS_ON;
+	c |= IP101A_G_APS_ON;
 
 	return phy_write(phydev, IP10XX_SPEC_CTRL_STATUS, c);
 }
@@ -173,6 +185,15 @@
 	return 0;
 }
 
+static int ip101a_g_ack_interrupt(struct phy_device *phydev)
+{
+	int err = phy_read(phydev, IP101A_G_IRQ_CONF_STATUS);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
 static struct phy_driver ip175c_driver = {
 	.phy_id		= 0x02430d80,
 	.name		= "ICPlus IP175C",
@@ -202,11 +223,13 @@
 
 static struct phy_driver ip101a_driver = {
 	.phy_id		= 0x02430c54,
-	.name		= "ICPlus IP101A",
+	.name		= "ICPlus IP101A/G",
 	.phy_id_mask	= 0x0ffffff0,
 	.features	= PHY_BASIC_FEATURES | SUPPORTED_Pause |
 			  SUPPORTED_Asym_Pause,
-	.config_init	= &ip101a_config_init,
+	.flags		= PHY_HAS_INTERRUPT,
+	.ack_interrupt	= ip101a_g_ack_interrupt,
+	.config_init	= &ip101a_g_config_init,
 	.config_aneg	= &genphy_config_aneg,
 	.read_status	= &genphy_read_status,
 	.suspend	= genphy_suspend,
@@ -242,6 +265,7 @@
 static struct mdio_device_id __maybe_unused icplus_tbl[] = {
 	{ 0x02430d80, 0x0ffffff0 },
 	{ 0x02430d90, 0x0ffffff0 },
+	{ 0x02430c54, 0x0ffffff0 },
 	{ }
 };
